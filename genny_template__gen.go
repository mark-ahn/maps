// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package maps

import "fmt"

type OfBoolNBoolIf interface {
	Load(bool) (bool, error)
}

type OfBoolNBoolMutIf interface {
	Store(bool, bool)
	Delete(bool)
}

type OfBoolNBoolIterIf interface {
	Range(func(bool, bool) bool)
}

type OfBoolNBool map[bool]bool

func (__ OfBoolNBool) Load(k bool) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNBool) Store(k bool, v bool) {
	__[k] = v
}
func (__ OfBoolNBool) Delete(k bool, v bool) {
	delete(__, k)
}
func (__ OfBoolNBool) Range(f func(k bool, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNBool = OfBoolNBool
type OfBoolNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNBool
}

func NewOfBoolNBoolSt(somes OfBoolNBool) *OfBoolNBoolSt {
	return &OfBoolNBoolSt{
		_OfBoolNBool: somes,
	}
}

type OfBoolNByteIf interface {
	Load(bool) (byte, error)
}

type OfBoolNByteMutIf interface {
	Store(bool, byte)
	Delete(bool)
}

type OfBoolNByteIterIf interface {
	Range(func(bool, byte) bool)
}

type OfBoolNByte map[bool]byte

func (__ OfBoolNByte) Load(k bool) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNByte) Store(k bool, v byte) {
	__[k] = v
}
func (__ OfBoolNByte) Delete(k bool, v byte) {
	delete(__, k)
}
func (__ OfBoolNByte) Range(f func(k bool, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNByte = OfBoolNByte
type OfBoolNByteSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNByte
}

func NewOfBoolNByteSt(somes OfBoolNByte) *OfBoolNByteSt {
	return &OfBoolNByteSt{
		_OfBoolNByte: somes,
	}
}

type OfBoolNComplex128If interface {
	Load(bool) (complex128, error)
}

type OfBoolNComplex128MutIf interface {
	Store(bool, complex128)
	Delete(bool)
}

type OfBoolNComplex128IterIf interface {
	Range(func(bool, complex128) bool)
}

type OfBoolNComplex128 map[bool]complex128

func (__ OfBoolNComplex128) Load(k bool) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNComplex128) Store(k bool, v complex128) {
	__[k] = v
}
func (__ OfBoolNComplex128) Delete(k bool, v complex128) {
	delete(__, k)
}
func (__ OfBoolNComplex128) Range(f func(k bool, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNComplex128 = OfBoolNComplex128
type OfBoolNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfBoolNComplex128
}

func NewOfBoolNComplex128St(somes OfBoolNComplex128) *OfBoolNComplex128St {
	return &OfBoolNComplex128St{
		_OfBoolNComplex128: somes,
	}
}

type OfBoolNComplex64If interface {
	Load(bool) (complex64, error)
}

type OfBoolNComplex64MutIf interface {
	Store(bool, complex64)
	Delete(bool)
}

type OfBoolNComplex64IterIf interface {
	Range(func(bool, complex64) bool)
}

type OfBoolNComplex64 map[bool]complex64

func (__ OfBoolNComplex64) Load(k bool) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNComplex64) Store(k bool, v complex64) {
	__[k] = v
}
func (__ OfBoolNComplex64) Delete(k bool, v complex64) {
	delete(__, k)
}
func (__ OfBoolNComplex64) Range(f func(k bool, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNComplex64 = OfBoolNComplex64
type OfBoolNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfBoolNComplex64
}

func NewOfBoolNComplex64St(somes OfBoolNComplex64) *OfBoolNComplex64St {
	return &OfBoolNComplex64St{
		_OfBoolNComplex64: somes,
	}
}

type OfBoolNErrorIf interface {
	Load(bool) (error, error)
}

type OfBoolNErrorMutIf interface {
	Store(bool, error)
	Delete(bool)
}

type OfBoolNErrorIterIf interface {
	Range(func(bool, error) bool)
}

type OfBoolNError map[bool]error

func (__ OfBoolNError) Load(k bool) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNError) Store(k bool, v error) {
	__[k] = v
}
func (__ OfBoolNError) Delete(k bool, v error) {
	delete(__, k)
}
func (__ OfBoolNError) Range(f func(k bool, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNError = OfBoolNError
type OfBoolNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNError
}

func NewOfBoolNErrorSt(somes OfBoolNError) *OfBoolNErrorSt {
	return &OfBoolNErrorSt{
		_OfBoolNError: somes,
	}
}

type OfBoolNFloat32If interface {
	Load(bool) (float32, error)
}

type OfBoolNFloat32MutIf interface {
	Store(bool, float32)
	Delete(bool)
}

type OfBoolNFloat32IterIf interface {
	Range(func(bool, float32) bool)
}

type OfBoolNFloat32 map[bool]float32

func (__ OfBoolNFloat32) Load(k bool) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNFloat32) Store(k bool, v float32) {
	__[k] = v
}
func (__ OfBoolNFloat32) Delete(k bool, v float32) {
	delete(__, k)
}
func (__ OfBoolNFloat32) Range(f func(k bool, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNFloat32 = OfBoolNFloat32
type OfBoolNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfBoolNFloat32
}

func NewOfBoolNFloat32St(somes OfBoolNFloat32) *OfBoolNFloat32St {
	return &OfBoolNFloat32St{
		_OfBoolNFloat32: somes,
	}
}

type OfBoolNFloat64If interface {
	Load(bool) (float64, error)
}

type OfBoolNFloat64MutIf interface {
	Store(bool, float64)
	Delete(bool)
}

type OfBoolNFloat64IterIf interface {
	Range(func(bool, float64) bool)
}

type OfBoolNFloat64 map[bool]float64

func (__ OfBoolNFloat64) Load(k bool) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNFloat64) Store(k bool, v float64) {
	__[k] = v
}
func (__ OfBoolNFloat64) Delete(k bool, v float64) {
	delete(__, k)
}
func (__ OfBoolNFloat64) Range(f func(k bool, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNFloat64 = OfBoolNFloat64
type OfBoolNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfBoolNFloat64
}

func NewOfBoolNFloat64St(somes OfBoolNFloat64) *OfBoolNFloat64St {
	return &OfBoolNFloat64St{
		_OfBoolNFloat64: somes,
	}
}

type OfBoolNIntIf interface {
	Load(bool) (int, error)
}

type OfBoolNIntMutIf interface {
	Store(bool, int)
	Delete(bool)
}

type OfBoolNIntIterIf interface {
	Range(func(bool, int) bool)
}

type OfBoolNInt map[bool]int

func (__ OfBoolNInt) Load(k bool) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNInt) Store(k bool, v int) {
	__[k] = v
}
func (__ OfBoolNInt) Delete(k bool, v int) {
	delete(__, k)
}
func (__ OfBoolNInt) Range(f func(k bool, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNInt = OfBoolNInt
type OfBoolNIntSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNInt
}

func NewOfBoolNIntSt(somes OfBoolNInt) *OfBoolNIntSt {
	return &OfBoolNIntSt{
		_OfBoolNInt: somes,
	}
}

type OfBoolNInt16If interface {
	Load(bool) (int16, error)
}

type OfBoolNInt16MutIf interface {
	Store(bool, int16)
	Delete(bool)
}

type OfBoolNInt16IterIf interface {
	Range(func(bool, int16) bool)
}

type OfBoolNInt16 map[bool]int16

func (__ OfBoolNInt16) Load(k bool) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNInt16) Store(k bool, v int16) {
	__[k] = v
}
func (__ OfBoolNInt16) Delete(k bool, v int16) {
	delete(__, k)
}
func (__ OfBoolNInt16) Range(f func(k bool, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNInt16 = OfBoolNInt16
type OfBoolNInt16St struct {
	// do not want to export but want to use embedding method
	_OfBoolNInt16
}

func NewOfBoolNInt16St(somes OfBoolNInt16) *OfBoolNInt16St {
	return &OfBoolNInt16St{
		_OfBoolNInt16: somes,
	}
}

type OfBoolNInt32If interface {
	Load(bool) (int32, error)
}

type OfBoolNInt32MutIf interface {
	Store(bool, int32)
	Delete(bool)
}

type OfBoolNInt32IterIf interface {
	Range(func(bool, int32) bool)
}

type OfBoolNInt32 map[bool]int32

func (__ OfBoolNInt32) Load(k bool) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNInt32) Store(k bool, v int32) {
	__[k] = v
}
func (__ OfBoolNInt32) Delete(k bool, v int32) {
	delete(__, k)
}
func (__ OfBoolNInt32) Range(f func(k bool, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNInt32 = OfBoolNInt32
type OfBoolNInt32St struct {
	// do not want to export but want to use embedding method
	_OfBoolNInt32
}

func NewOfBoolNInt32St(somes OfBoolNInt32) *OfBoolNInt32St {
	return &OfBoolNInt32St{
		_OfBoolNInt32: somes,
	}
}

type OfBoolNInt64If interface {
	Load(bool) (int64, error)
}

type OfBoolNInt64MutIf interface {
	Store(bool, int64)
	Delete(bool)
}

type OfBoolNInt64IterIf interface {
	Range(func(bool, int64) bool)
}

type OfBoolNInt64 map[bool]int64

func (__ OfBoolNInt64) Load(k bool) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNInt64) Store(k bool, v int64) {
	__[k] = v
}
func (__ OfBoolNInt64) Delete(k bool, v int64) {
	delete(__, k)
}
func (__ OfBoolNInt64) Range(f func(k bool, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNInt64 = OfBoolNInt64
type OfBoolNInt64St struct {
	// do not want to export but want to use embedding method
	_OfBoolNInt64
}

func NewOfBoolNInt64St(somes OfBoolNInt64) *OfBoolNInt64St {
	return &OfBoolNInt64St{
		_OfBoolNInt64: somes,
	}
}

type OfBoolNInt8If interface {
	Load(bool) (int8, error)
}

type OfBoolNInt8MutIf interface {
	Store(bool, int8)
	Delete(bool)
}

type OfBoolNInt8IterIf interface {
	Range(func(bool, int8) bool)
}

type OfBoolNInt8 map[bool]int8

func (__ OfBoolNInt8) Load(k bool) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNInt8) Store(k bool, v int8) {
	__[k] = v
}
func (__ OfBoolNInt8) Delete(k bool, v int8) {
	delete(__, k)
}
func (__ OfBoolNInt8) Range(f func(k bool, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNInt8 = OfBoolNInt8
type OfBoolNInt8St struct {
	// do not want to export but want to use embedding method
	_OfBoolNInt8
}

func NewOfBoolNInt8St(somes OfBoolNInt8) *OfBoolNInt8St {
	return &OfBoolNInt8St{
		_OfBoolNInt8: somes,
	}
}

type OfBoolNRuneIf interface {
	Load(bool) (rune, error)
}

type OfBoolNRuneMutIf interface {
	Store(bool, rune)
	Delete(bool)
}

type OfBoolNRuneIterIf interface {
	Range(func(bool, rune) bool)
}

type OfBoolNRune map[bool]rune

func (__ OfBoolNRune) Load(k bool) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNRune) Store(k bool, v rune) {
	__[k] = v
}
func (__ OfBoolNRune) Delete(k bool, v rune) {
	delete(__, k)
}
func (__ OfBoolNRune) Range(f func(k bool, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNRune = OfBoolNRune
type OfBoolNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNRune
}

func NewOfBoolNRuneSt(somes OfBoolNRune) *OfBoolNRuneSt {
	return &OfBoolNRuneSt{
		_OfBoolNRune: somes,
	}
}

type OfBoolNStringIf interface {
	Load(bool) (string, error)
}

type OfBoolNStringMutIf interface {
	Store(bool, string)
	Delete(bool)
}

type OfBoolNStringIterIf interface {
	Range(func(bool, string) bool)
}

type OfBoolNString map[bool]string

func (__ OfBoolNString) Load(k bool) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNString) Store(k bool, v string) {
	__[k] = v
}
func (__ OfBoolNString) Delete(k bool, v string) {
	delete(__, k)
}
func (__ OfBoolNString) Range(f func(k bool, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNString = OfBoolNString
type OfBoolNStringSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNString
}

func NewOfBoolNStringSt(somes OfBoolNString) *OfBoolNStringSt {
	return &OfBoolNStringSt{
		_OfBoolNString: somes,
	}
}

type OfBoolNUintIf interface {
	Load(bool) (uint, error)
}

type OfBoolNUintMutIf interface {
	Store(bool, uint)
	Delete(bool)
}

type OfBoolNUintIterIf interface {
	Range(func(bool, uint) bool)
}

type OfBoolNUint map[bool]uint

func (__ OfBoolNUint) Load(k bool) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNUint) Store(k bool, v uint) {
	__[k] = v
}
func (__ OfBoolNUint) Delete(k bool, v uint) {
	delete(__, k)
}
func (__ OfBoolNUint) Range(f func(k bool, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNUint = OfBoolNUint
type OfBoolNUintSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNUint
}

func NewOfBoolNUintSt(somes OfBoolNUint) *OfBoolNUintSt {
	return &OfBoolNUintSt{
		_OfBoolNUint: somes,
	}
}

type OfBoolNUint16If interface {
	Load(bool) (uint16, error)
}

type OfBoolNUint16MutIf interface {
	Store(bool, uint16)
	Delete(bool)
}

type OfBoolNUint16IterIf interface {
	Range(func(bool, uint16) bool)
}

type OfBoolNUint16 map[bool]uint16

func (__ OfBoolNUint16) Load(k bool) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNUint16) Store(k bool, v uint16) {
	__[k] = v
}
func (__ OfBoolNUint16) Delete(k bool, v uint16) {
	delete(__, k)
}
func (__ OfBoolNUint16) Range(f func(k bool, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNUint16 = OfBoolNUint16
type OfBoolNUint16St struct {
	// do not want to export but want to use embedding method
	_OfBoolNUint16
}

func NewOfBoolNUint16St(somes OfBoolNUint16) *OfBoolNUint16St {
	return &OfBoolNUint16St{
		_OfBoolNUint16: somes,
	}
}

type OfBoolNUint32If interface {
	Load(bool) (uint32, error)
}

type OfBoolNUint32MutIf interface {
	Store(bool, uint32)
	Delete(bool)
}

type OfBoolNUint32IterIf interface {
	Range(func(bool, uint32) bool)
}

type OfBoolNUint32 map[bool]uint32

func (__ OfBoolNUint32) Load(k bool) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNUint32) Store(k bool, v uint32) {
	__[k] = v
}
func (__ OfBoolNUint32) Delete(k bool, v uint32) {
	delete(__, k)
}
func (__ OfBoolNUint32) Range(f func(k bool, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNUint32 = OfBoolNUint32
type OfBoolNUint32St struct {
	// do not want to export but want to use embedding method
	_OfBoolNUint32
}

func NewOfBoolNUint32St(somes OfBoolNUint32) *OfBoolNUint32St {
	return &OfBoolNUint32St{
		_OfBoolNUint32: somes,
	}
}

type OfBoolNUint64If interface {
	Load(bool) (uint64, error)
}

type OfBoolNUint64MutIf interface {
	Store(bool, uint64)
	Delete(bool)
}

type OfBoolNUint64IterIf interface {
	Range(func(bool, uint64) bool)
}

type OfBoolNUint64 map[bool]uint64

func (__ OfBoolNUint64) Load(k bool) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNUint64) Store(k bool, v uint64) {
	__[k] = v
}
func (__ OfBoolNUint64) Delete(k bool, v uint64) {
	delete(__, k)
}
func (__ OfBoolNUint64) Range(f func(k bool, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNUint64 = OfBoolNUint64
type OfBoolNUint64St struct {
	// do not want to export but want to use embedding method
	_OfBoolNUint64
}

func NewOfBoolNUint64St(somes OfBoolNUint64) *OfBoolNUint64St {
	return &OfBoolNUint64St{
		_OfBoolNUint64: somes,
	}
}

type OfBoolNUint8If interface {
	Load(bool) (uint8, error)
}

type OfBoolNUint8MutIf interface {
	Store(bool, uint8)
	Delete(bool)
}

type OfBoolNUint8IterIf interface {
	Range(func(bool, uint8) bool)
}

type OfBoolNUint8 map[bool]uint8

func (__ OfBoolNUint8) Load(k bool) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNUint8) Store(k bool, v uint8) {
	__[k] = v
}
func (__ OfBoolNUint8) Delete(k bool, v uint8) {
	delete(__, k)
}
func (__ OfBoolNUint8) Range(f func(k bool, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNUint8 = OfBoolNUint8
type OfBoolNUint8St struct {
	// do not want to export but want to use embedding method
	_OfBoolNUint8
}

func NewOfBoolNUint8St(somes OfBoolNUint8) *OfBoolNUint8St {
	return &OfBoolNUint8St{
		_OfBoolNUint8: somes,
	}
}

type OfBoolNUintptrIf interface {
	Load(bool) (uintptr, error)
}

type OfBoolNUintptrMutIf interface {
	Store(bool, uintptr)
	Delete(bool)
}

type OfBoolNUintptrIterIf interface {
	Range(func(bool, uintptr) bool)
}

type OfBoolNUintptr map[bool]uintptr

func (__ OfBoolNUintptr) Load(k bool) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNUintptr) Store(k bool, v uintptr) {
	__[k] = v
}
func (__ OfBoolNUintptr) Delete(k bool, v uintptr) {
	delete(__, k)
}
func (__ OfBoolNUintptr) Range(f func(k bool, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNUintptr = OfBoolNUintptr
type OfBoolNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNUintptr
}

func NewOfBoolNUintptrSt(somes OfBoolNUintptr) *OfBoolNUintptrSt {
	return &OfBoolNUintptrSt{
		_OfBoolNUintptr: somes,
	}
}

type OfBoolNInterfaceIf interface {
	Load(bool) (interface{}, error)
}

type OfBoolNInterfaceMutIf interface {
	Store(bool, interface{})
	Delete(bool)
}

type OfBoolNInterfaceIterIf interface {
	Range(func(bool, interface{}) bool)
}

type OfBoolNInterface map[bool]interface{}

func (__ OfBoolNInterface) Load(k bool) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfBoolNInterface) Store(k bool, v interface{}) {
	__[k] = v
}
func (__ OfBoolNInterface) Delete(k bool, v interface{}) {
	delete(__, k)
}
func (__ OfBoolNInterface) Range(f func(k bool, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfBoolNInterface = OfBoolNInterface
type OfBoolNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfBoolNInterface
}

func NewOfBoolNInterfaceSt(somes OfBoolNInterface) *OfBoolNInterfaceSt {
	return &OfBoolNInterfaceSt{
		_OfBoolNInterface: somes,
	}
}

type OfByteNBoolIf interface {
	Load(byte) (bool, error)
}

type OfByteNBoolMutIf interface {
	Store(byte, bool)
	Delete(byte)
}

type OfByteNBoolIterIf interface {
	Range(func(byte, bool) bool)
}

type OfByteNBool map[byte]bool

func (__ OfByteNBool) Load(k byte) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNBool) Store(k byte, v bool) {
	__[k] = v
}
func (__ OfByteNBool) Delete(k byte, v bool) {
	delete(__, k)
}
func (__ OfByteNBool) Range(f func(k byte, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNBool = OfByteNBool
type OfByteNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfByteNBool
}

func NewOfByteNBoolSt(somes OfByteNBool) *OfByteNBoolSt {
	return &OfByteNBoolSt{
		_OfByteNBool: somes,
	}
}

type OfByteNByteIf interface {
	Load(byte) (byte, error)
}

type OfByteNByteMutIf interface {
	Store(byte, byte)
	Delete(byte)
}

type OfByteNByteIterIf interface {
	Range(func(byte, byte) bool)
}

type OfByteNByte map[byte]byte

func (__ OfByteNByte) Load(k byte) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNByte) Store(k byte, v byte) {
	__[k] = v
}
func (__ OfByteNByte) Delete(k byte, v byte) {
	delete(__, k)
}
func (__ OfByteNByte) Range(f func(k byte, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNByte = OfByteNByte
type OfByteNByteSt struct {
	// do not want to export but want to use embedding method
	_OfByteNByte
}

func NewOfByteNByteSt(somes OfByteNByte) *OfByteNByteSt {
	return &OfByteNByteSt{
		_OfByteNByte: somes,
	}
}

type OfByteNComplex128If interface {
	Load(byte) (complex128, error)
}

type OfByteNComplex128MutIf interface {
	Store(byte, complex128)
	Delete(byte)
}

type OfByteNComplex128IterIf interface {
	Range(func(byte, complex128) bool)
}

type OfByteNComplex128 map[byte]complex128

func (__ OfByteNComplex128) Load(k byte) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNComplex128) Store(k byte, v complex128) {
	__[k] = v
}
func (__ OfByteNComplex128) Delete(k byte, v complex128) {
	delete(__, k)
}
func (__ OfByteNComplex128) Range(f func(k byte, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNComplex128 = OfByteNComplex128
type OfByteNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfByteNComplex128
}

func NewOfByteNComplex128St(somes OfByteNComplex128) *OfByteNComplex128St {
	return &OfByteNComplex128St{
		_OfByteNComplex128: somes,
	}
}

type OfByteNComplex64If interface {
	Load(byte) (complex64, error)
}

type OfByteNComplex64MutIf interface {
	Store(byte, complex64)
	Delete(byte)
}

type OfByteNComplex64IterIf interface {
	Range(func(byte, complex64) bool)
}

type OfByteNComplex64 map[byte]complex64

func (__ OfByteNComplex64) Load(k byte) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNComplex64) Store(k byte, v complex64) {
	__[k] = v
}
func (__ OfByteNComplex64) Delete(k byte, v complex64) {
	delete(__, k)
}
func (__ OfByteNComplex64) Range(f func(k byte, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNComplex64 = OfByteNComplex64
type OfByteNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfByteNComplex64
}

func NewOfByteNComplex64St(somes OfByteNComplex64) *OfByteNComplex64St {
	return &OfByteNComplex64St{
		_OfByteNComplex64: somes,
	}
}

type OfByteNErrorIf interface {
	Load(byte) (error, error)
}

type OfByteNErrorMutIf interface {
	Store(byte, error)
	Delete(byte)
}

type OfByteNErrorIterIf interface {
	Range(func(byte, error) bool)
}

type OfByteNError map[byte]error

func (__ OfByteNError) Load(k byte) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNError) Store(k byte, v error) {
	__[k] = v
}
func (__ OfByteNError) Delete(k byte, v error) {
	delete(__, k)
}
func (__ OfByteNError) Range(f func(k byte, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNError = OfByteNError
type OfByteNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfByteNError
}

func NewOfByteNErrorSt(somes OfByteNError) *OfByteNErrorSt {
	return &OfByteNErrorSt{
		_OfByteNError: somes,
	}
}

type OfByteNFloat32If interface {
	Load(byte) (float32, error)
}

type OfByteNFloat32MutIf interface {
	Store(byte, float32)
	Delete(byte)
}

type OfByteNFloat32IterIf interface {
	Range(func(byte, float32) bool)
}

type OfByteNFloat32 map[byte]float32

func (__ OfByteNFloat32) Load(k byte) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNFloat32) Store(k byte, v float32) {
	__[k] = v
}
func (__ OfByteNFloat32) Delete(k byte, v float32) {
	delete(__, k)
}
func (__ OfByteNFloat32) Range(f func(k byte, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNFloat32 = OfByteNFloat32
type OfByteNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfByteNFloat32
}

func NewOfByteNFloat32St(somes OfByteNFloat32) *OfByteNFloat32St {
	return &OfByteNFloat32St{
		_OfByteNFloat32: somes,
	}
}

type OfByteNFloat64If interface {
	Load(byte) (float64, error)
}

type OfByteNFloat64MutIf interface {
	Store(byte, float64)
	Delete(byte)
}

type OfByteNFloat64IterIf interface {
	Range(func(byte, float64) bool)
}

type OfByteNFloat64 map[byte]float64

func (__ OfByteNFloat64) Load(k byte) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNFloat64) Store(k byte, v float64) {
	__[k] = v
}
func (__ OfByteNFloat64) Delete(k byte, v float64) {
	delete(__, k)
}
func (__ OfByteNFloat64) Range(f func(k byte, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNFloat64 = OfByteNFloat64
type OfByteNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfByteNFloat64
}

func NewOfByteNFloat64St(somes OfByteNFloat64) *OfByteNFloat64St {
	return &OfByteNFloat64St{
		_OfByteNFloat64: somes,
	}
}

type OfByteNIntIf interface {
	Load(byte) (int, error)
}

type OfByteNIntMutIf interface {
	Store(byte, int)
	Delete(byte)
}

type OfByteNIntIterIf interface {
	Range(func(byte, int) bool)
}

type OfByteNInt map[byte]int

func (__ OfByteNInt) Load(k byte) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNInt) Store(k byte, v int) {
	__[k] = v
}
func (__ OfByteNInt) Delete(k byte, v int) {
	delete(__, k)
}
func (__ OfByteNInt) Range(f func(k byte, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNInt = OfByteNInt
type OfByteNIntSt struct {
	// do not want to export but want to use embedding method
	_OfByteNInt
}

func NewOfByteNIntSt(somes OfByteNInt) *OfByteNIntSt {
	return &OfByteNIntSt{
		_OfByteNInt: somes,
	}
}

type OfByteNInt16If interface {
	Load(byte) (int16, error)
}

type OfByteNInt16MutIf interface {
	Store(byte, int16)
	Delete(byte)
}

type OfByteNInt16IterIf interface {
	Range(func(byte, int16) bool)
}

type OfByteNInt16 map[byte]int16

func (__ OfByteNInt16) Load(k byte) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNInt16) Store(k byte, v int16) {
	__[k] = v
}
func (__ OfByteNInt16) Delete(k byte, v int16) {
	delete(__, k)
}
func (__ OfByteNInt16) Range(f func(k byte, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNInt16 = OfByteNInt16
type OfByteNInt16St struct {
	// do not want to export but want to use embedding method
	_OfByteNInt16
}

func NewOfByteNInt16St(somes OfByteNInt16) *OfByteNInt16St {
	return &OfByteNInt16St{
		_OfByteNInt16: somes,
	}
}

type OfByteNInt32If interface {
	Load(byte) (int32, error)
}

type OfByteNInt32MutIf interface {
	Store(byte, int32)
	Delete(byte)
}

type OfByteNInt32IterIf interface {
	Range(func(byte, int32) bool)
}

type OfByteNInt32 map[byte]int32

func (__ OfByteNInt32) Load(k byte) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNInt32) Store(k byte, v int32) {
	__[k] = v
}
func (__ OfByteNInt32) Delete(k byte, v int32) {
	delete(__, k)
}
func (__ OfByteNInt32) Range(f func(k byte, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNInt32 = OfByteNInt32
type OfByteNInt32St struct {
	// do not want to export but want to use embedding method
	_OfByteNInt32
}

func NewOfByteNInt32St(somes OfByteNInt32) *OfByteNInt32St {
	return &OfByteNInt32St{
		_OfByteNInt32: somes,
	}
}

type OfByteNInt64If interface {
	Load(byte) (int64, error)
}

type OfByteNInt64MutIf interface {
	Store(byte, int64)
	Delete(byte)
}

type OfByteNInt64IterIf interface {
	Range(func(byte, int64) bool)
}

type OfByteNInt64 map[byte]int64

func (__ OfByteNInt64) Load(k byte) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNInt64) Store(k byte, v int64) {
	__[k] = v
}
func (__ OfByteNInt64) Delete(k byte, v int64) {
	delete(__, k)
}
func (__ OfByteNInt64) Range(f func(k byte, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNInt64 = OfByteNInt64
type OfByteNInt64St struct {
	// do not want to export but want to use embedding method
	_OfByteNInt64
}

func NewOfByteNInt64St(somes OfByteNInt64) *OfByteNInt64St {
	return &OfByteNInt64St{
		_OfByteNInt64: somes,
	}
}

type OfByteNInt8If interface {
	Load(byte) (int8, error)
}

type OfByteNInt8MutIf interface {
	Store(byte, int8)
	Delete(byte)
}

type OfByteNInt8IterIf interface {
	Range(func(byte, int8) bool)
}

type OfByteNInt8 map[byte]int8

func (__ OfByteNInt8) Load(k byte) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNInt8) Store(k byte, v int8) {
	__[k] = v
}
func (__ OfByteNInt8) Delete(k byte, v int8) {
	delete(__, k)
}
func (__ OfByteNInt8) Range(f func(k byte, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNInt8 = OfByteNInt8
type OfByteNInt8St struct {
	// do not want to export but want to use embedding method
	_OfByteNInt8
}

func NewOfByteNInt8St(somes OfByteNInt8) *OfByteNInt8St {
	return &OfByteNInt8St{
		_OfByteNInt8: somes,
	}
}

type OfByteNRuneIf interface {
	Load(byte) (rune, error)
}

type OfByteNRuneMutIf interface {
	Store(byte, rune)
	Delete(byte)
}

type OfByteNRuneIterIf interface {
	Range(func(byte, rune) bool)
}

type OfByteNRune map[byte]rune

func (__ OfByteNRune) Load(k byte) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNRune) Store(k byte, v rune) {
	__[k] = v
}
func (__ OfByteNRune) Delete(k byte, v rune) {
	delete(__, k)
}
func (__ OfByteNRune) Range(f func(k byte, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNRune = OfByteNRune
type OfByteNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfByteNRune
}

func NewOfByteNRuneSt(somes OfByteNRune) *OfByteNRuneSt {
	return &OfByteNRuneSt{
		_OfByteNRune: somes,
	}
}

type OfByteNStringIf interface {
	Load(byte) (string, error)
}

type OfByteNStringMutIf interface {
	Store(byte, string)
	Delete(byte)
}

type OfByteNStringIterIf interface {
	Range(func(byte, string) bool)
}

type OfByteNString map[byte]string

func (__ OfByteNString) Load(k byte) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNString) Store(k byte, v string) {
	__[k] = v
}
func (__ OfByteNString) Delete(k byte, v string) {
	delete(__, k)
}
func (__ OfByteNString) Range(f func(k byte, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNString = OfByteNString
type OfByteNStringSt struct {
	// do not want to export but want to use embedding method
	_OfByteNString
}

func NewOfByteNStringSt(somes OfByteNString) *OfByteNStringSt {
	return &OfByteNStringSt{
		_OfByteNString: somes,
	}
}

type OfByteNUintIf interface {
	Load(byte) (uint, error)
}

type OfByteNUintMutIf interface {
	Store(byte, uint)
	Delete(byte)
}

type OfByteNUintIterIf interface {
	Range(func(byte, uint) bool)
}

type OfByteNUint map[byte]uint

func (__ OfByteNUint) Load(k byte) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNUint) Store(k byte, v uint) {
	__[k] = v
}
func (__ OfByteNUint) Delete(k byte, v uint) {
	delete(__, k)
}
func (__ OfByteNUint) Range(f func(k byte, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNUint = OfByteNUint
type OfByteNUintSt struct {
	// do not want to export but want to use embedding method
	_OfByteNUint
}

func NewOfByteNUintSt(somes OfByteNUint) *OfByteNUintSt {
	return &OfByteNUintSt{
		_OfByteNUint: somes,
	}
}

type OfByteNUint16If interface {
	Load(byte) (uint16, error)
}

type OfByteNUint16MutIf interface {
	Store(byte, uint16)
	Delete(byte)
}

type OfByteNUint16IterIf interface {
	Range(func(byte, uint16) bool)
}

type OfByteNUint16 map[byte]uint16

func (__ OfByteNUint16) Load(k byte) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNUint16) Store(k byte, v uint16) {
	__[k] = v
}
func (__ OfByteNUint16) Delete(k byte, v uint16) {
	delete(__, k)
}
func (__ OfByteNUint16) Range(f func(k byte, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNUint16 = OfByteNUint16
type OfByteNUint16St struct {
	// do not want to export but want to use embedding method
	_OfByteNUint16
}

func NewOfByteNUint16St(somes OfByteNUint16) *OfByteNUint16St {
	return &OfByteNUint16St{
		_OfByteNUint16: somes,
	}
}

type OfByteNUint32If interface {
	Load(byte) (uint32, error)
}

type OfByteNUint32MutIf interface {
	Store(byte, uint32)
	Delete(byte)
}

type OfByteNUint32IterIf interface {
	Range(func(byte, uint32) bool)
}

type OfByteNUint32 map[byte]uint32

func (__ OfByteNUint32) Load(k byte) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNUint32) Store(k byte, v uint32) {
	__[k] = v
}
func (__ OfByteNUint32) Delete(k byte, v uint32) {
	delete(__, k)
}
func (__ OfByteNUint32) Range(f func(k byte, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNUint32 = OfByteNUint32
type OfByteNUint32St struct {
	// do not want to export but want to use embedding method
	_OfByteNUint32
}

func NewOfByteNUint32St(somes OfByteNUint32) *OfByteNUint32St {
	return &OfByteNUint32St{
		_OfByteNUint32: somes,
	}
}

type OfByteNUint64If interface {
	Load(byte) (uint64, error)
}

type OfByteNUint64MutIf interface {
	Store(byte, uint64)
	Delete(byte)
}

type OfByteNUint64IterIf interface {
	Range(func(byte, uint64) bool)
}

type OfByteNUint64 map[byte]uint64

func (__ OfByteNUint64) Load(k byte) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNUint64) Store(k byte, v uint64) {
	__[k] = v
}
func (__ OfByteNUint64) Delete(k byte, v uint64) {
	delete(__, k)
}
func (__ OfByteNUint64) Range(f func(k byte, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNUint64 = OfByteNUint64
type OfByteNUint64St struct {
	// do not want to export but want to use embedding method
	_OfByteNUint64
}

func NewOfByteNUint64St(somes OfByteNUint64) *OfByteNUint64St {
	return &OfByteNUint64St{
		_OfByteNUint64: somes,
	}
}

type OfByteNUint8If interface {
	Load(byte) (uint8, error)
}

type OfByteNUint8MutIf interface {
	Store(byte, uint8)
	Delete(byte)
}

type OfByteNUint8IterIf interface {
	Range(func(byte, uint8) bool)
}

type OfByteNUint8 map[byte]uint8

func (__ OfByteNUint8) Load(k byte) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNUint8) Store(k byte, v uint8) {
	__[k] = v
}
func (__ OfByteNUint8) Delete(k byte, v uint8) {
	delete(__, k)
}
func (__ OfByteNUint8) Range(f func(k byte, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNUint8 = OfByteNUint8
type OfByteNUint8St struct {
	// do not want to export but want to use embedding method
	_OfByteNUint8
}

func NewOfByteNUint8St(somes OfByteNUint8) *OfByteNUint8St {
	return &OfByteNUint8St{
		_OfByteNUint8: somes,
	}
}

type OfByteNUintptrIf interface {
	Load(byte) (uintptr, error)
}

type OfByteNUintptrMutIf interface {
	Store(byte, uintptr)
	Delete(byte)
}

type OfByteNUintptrIterIf interface {
	Range(func(byte, uintptr) bool)
}

type OfByteNUintptr map[byte]uintptr

func (__ OfByteNUintptr) Load(k byte) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNUintptr) Store(k byte, v uintptr) {
	__[k] = v
}
func (__ OfByteNUintptr) Delete(k byte, v uintptr) {
	delete(__, k)
}
func (__ OfByteNUintptr) Range(f func(k byte, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNUintptr = OfByteNUintptr
type OfByteNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfByteNUintptr
}

func NewOfByteNUintptrSt(somes OfByteNUintptr) *OfByteNUintptrSt {
	return &OfByteNUintptrSt{
		_OfByteNUintptr: somes,
	}
}

type OfByteNInterfaceIf interface {
	Load(byte) (interface{}, error)
}

type OfByteNInterfaceMutIf interface {
	Store(byte, interface{})
	Delete(byte)
}

type OfByteNInterfaceIterIf interface {
	Range(func(byte, interface{}) bool)
}

type OfByteNInterface map[byte]interface{}

func (__ OfByteNInterface) Load(k byte) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfByteNInterface) Store(k byte, v interface{}) {
	__[k] = v
}
func (__ OfByteNInterface) Delete(k byte, v interface{}) {
	delete(__, k)
}
func (__ OfByteNInterface) Range(f func(k byte, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfByteNInterface = OfByteNInterface
type OfByteNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfByteNInterface
}

func NewOfByteNInterfaceSt(somes OfByteNInterface) *OfByteNInterfaceSt {
	return &OfByteNInterfaceSt{
		_OfByteNInterface: somes,
	}
}

type OfComplex128NBoolIf interface {
	Load(complex128) (bool, error)
}

type OfComplex128NBoolMutIf interface {
	Store(complex128, bool)
	Delete(complex128)
}

type OfComplex128NBoolIterIf interface {
	Range(func(complex128, bool) bool)
}

type OfComplex128NBool map[complex128]bool

func (__ OfComplex128NBool) Load(k complex128) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NBool) Store(k complex128, v bool) {
	__[k] = v
}
func (__ OfComplex128NBool) Delete(k complex128, v bool) {
	delete(__, k)
}
func (__ OfComplex128NBool) Range(f func(k complex128, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NBool = OfComplex128NBool
type OfComplex128NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NBool
}

func NewOfComplex128NBoolSt(somes OfComplex128NBool) *OfComplex128NBoolSt {
	return &OfComplex128NBoolSt{
		_OfComplex128NBool: somes,
	}
}

type OfComplex128NByteIf interface {
	Load(complex128) (byte, error)
}

type OfComplex128NByteMutIf interface {
	Store(complex128, byte)
	Delete(complex128)
}

type OfComplex128NByteIterIf interface {
	Range(func(complex128, byte) bool)
}

type OfComplex128NByte map[complex128]byte

func (__ OfComplex128NByte) Load(k complex128) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NByte) Store(k complex128, v byte) {
	__[k] = v
}
func (__ OfComplex128NByte) Delete(k complex128, v byte) {
	delete(__, k)
}
func (__ OfComplex128NByte) Range(f func(k complex128, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NByte = OfComplex128NByte
type OfComplex128NByteSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NByte
}

func NewOfComplex128NByteSt(somes OfComplex128NByte) *OfComplex128NByteSt {
	return &OfComplex128NByteSt{
		_OfComplex128NByte: somes,
	}
}

type OfComplex128NComplex128If interface {
	Load(complex128) (complex128, error)
}

type OfComplex128NComplex128MutIf interface {
	Store(complex128, complex128)
	Delete(complex128)
}

type OfComplex128NComplex128IterIf interface {
	Range(func(complex128, complex128) bool)
}

type OfComplex128NComplex128 map[complex128]complex128

func (__ OfComplex128NComplex128) Load(k complex128) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NComplex128) Store(k complex128, v complex128) {
	__[k] = v
}
func (__ OfComplex128NComplex128) Delete(k complex128, v complex128) {
	delete(__, k)
}
func (__ OfComplex128NComplex128) Range(f func(k complex128, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NComplex128 = OfComplex128NComplex128
type OfComplex128NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NComplex128
}

func NewOfComplex128NComplex128St(somes OfComplex128NComplex128) *OfComplex128NComplex128St {
	return &OfComplex128NComplex128St{
		_OfComplex128NComplex128: somes,
	}
}

type OfComplex128NComplex64If interface {
	Load(complex128) (complex64, error)
}

type OfComplex128NComplex64MutIf interface {
	Store(complex128, complex64)
	Delete(complex128)
}

type OfComplex128NComplex64IterIf interface {
	Range(func(complex128, complex64) bool)
}

type OfComplex128NComplex64 map[complex128]complex64

func (__ OfComplex128NComplex64) Load(k complex128) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NComplex64) Store(k complex128, v complex64) {
	__[k] = v
}
func (__ OfComplex128NComplex64) Delete(k complex128, v complex64) {
	delete(__, k)
}
func (__ OfComplex128NComplex64) Range(f func(k complex128, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NComplex64 = OfComplex128NComplex64
type OfComplex128NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NComplex64
}

func NewOfComplex128NComplex64St(somes OfComplex128NComplex64) *OfComplex128NComplex64St {
	return &OfComplex128NComplex64St{
		_OfComplex128NComplex64: somes,
	}
}

type OfComplex128NErrorIf interface {
	Load(complex128) (error, error)
}

type OfComplex128NErrorMutIf interface {
	Store(complex128, error)
	Delete(complex128)
}

type OfComplex128NErrorIterIf interface {
	Range(func(complex128, error) bool)
}

type OfComplex128NError map[complex128]error

func (__ OfComplex128NError) Load(k complex128) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NError) Store(k complex128, v error) {
	__[k] = v
}
func (__ OfComplex128NError) Delete(k complex128, v error) {
	delete(__, k)
}
func (__ OfComplex128NError) Range(f func(k complex128, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NError = OfComplex128NError
type OfComplex128NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NError
}

func NewOfComplex128NErrorSt(somes OfComplex128NError) *OfComplex128NErrorSt {
	return &OfComplex128NErrorSt{
		_OfComplex128NError: somes,
	}
}

type OfComplex128NFloat32If interface {
	Load(complex128) (float32, error)
}

type OfComplex128NFloat32MutIf interface {
	Store(complex128, float32)
	Delete(complex128)
}

type OfComplex128NFloat32IterIf interface {
	Range(func(complex128, float32) bool)
}

type OfComplex128NFloat32 map[complex128]float32

func (__ OfComplex128NFloat32) Load(k complex128) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NFloat32) Store(k complex128, v float32) {
	__[k] = v
}
func (__ OfComplex128NFloat32) Delete(k complex128, v float32) {
	delete(__, k)
}
func (__ OfComplex128NFloat32) Range(f func(k complex128, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NFloat32 = OfComplex128NFloat32
type OfComplex128NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NFloat32
}

func NewOfComplex128NFloat32St(somes OfComplex128NFloat32) *OfComplex128NFloat32St {
	return &OfComplex128NFloat32St{
		_OfComplex128NFloat32: somes,
	}
}

type OfComplex128NFloat64If interface {
	Load(complex128) (float64, error)
}

type OfComplex128NFloat64MutIf interface {
	Store(complex128, float64)
	Delete(complex128)
}

type OfComplex128NFloat64IterIf interface {
	Range(func(complex128, float64) bool)
}

type OfComplex128NFloat64 map[complex128]float64

func (__ OfComplex128NFloat64) Load(k complex128) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NFloat64) Store(k complex128, v float64) {
	__[k] = v
}
func (__ OfComplex128NFloat64) Delete(k complex128, v float64) {
	delete(__, k)
}
func (__ OfComplex128NFloat64) Range(f func(k complex128, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NFloat64 = OfComplex128NFloat64
type OfComplex128NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NFloat64
}

func NewOfComplex128NFloat64St(somes OfComplex128NFloat64) *OfComplex128NFloat64St {
	return &OfComplex128NFloat64St{
		_OfComplex128NFloat64: somes,
	}
}

type OfComplex128NIntIf interface {
	Load(complex128) (int, error)
}

type OfComplex128NIntMutIf interface {
	Store(complex128, int)
	Delete(complex128)
}

type OfComplex128NIntIterIf interface {
	Range(func(complex128, int) bool)
}

type OfComplex128NInt map[complex128]int

func (__ OfComplex128NInt) Load(k complex128) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NInt) Store(k complex128, v int) {
	__[k] = v
}
func (__ OfComplex128NInt) Delete(k complex128, v int) {
	delete(__, k)
}
func (__ OfComplex128NInt) Range(f func(k complex128, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NInt = OfComplex128NInt
type OfComplex128NIntSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NInt
}

func NewOfComplex128NIntSt(somes OfComplex128NInt) *OfComplex128NIntSt {
	return &OfComplex128NIntSt{
		_OfComplex128NInt: somes,
	}
}

type OfComplex128NInt16If interface {
	Load(complex128) (int16, error)
}

type OfComplex128NInt16MutIf interface {
	Store(complex128, int16)
	Delete(complex128)
}

type OfComplex128NInt16IterIf interface {
	Range(func(complex128, int16) bool)
}

type OfComplex128NInt16 map[complex128]int16

func (__ OfComplex128NInt16) Load(k complex128) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NInt16) Store(k complex128, v int16) {
	__[k] = v
}
func (__ OfComplex128NInt16) Delete(k complex128, v int16) {
	delete(__, k)
}
func (__ OfComplex128NInt16) Range(f func(k complex128, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NInt16 = OfComplex128NInt16
type OfComplex128NInt16St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NInt16
}

func NewOfComplex128NInt16St(somes OfComplex128NInt16) *OfComplex128NInt16St {
	return &OfComplex128NInt16St{
		_OfComplex128NInt16: somes,
	}
}

type OfComplex128NInt32If interface {
	Load(complex128) (int32, error)
}

type OfComplex128NInt32MutIf interface {
	Store(complex128, int32)
	Delete(complex128)
}

type OfComplex128NInt32IterIf interface {
	Range(func(complex128, int32) bool)
}

type OfComplex128NInt32 map[complex128]int32

func (__ OfComplex128NInt32) Load(k complex128) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NInt32) Store(k complex128, v int32) {
	__[k] = v
}
func (__ OfComplex128NInt32) Delete(k complex128, v int32) {
	delete(__, k)
}
func (__ OfComplex128NInt32) Range(f func(k complex128, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NInt32 = OfComplex128NInt32
type OfComplex128NInt32St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NInt32
}

func NewOfComplex128NInt32St(somes OfComplex128NInt32) *OfComplex128NInt32St {
	return &OfComplex128NInt32St{
		_OfComplex128NInt32: somes,
	}
}

type OfComplex128NInt64If interface {
	Load(complex128) (int64, error)
}

type OfComplex128NInt64MutIf interface {
	Store(complex128, int64)
	Delete(complex128)
}

type OfComplex128NInt64IterIf interface {
	Range(func(complex128, int64) bool)
}

type OfComplex128NInt64 map[complex128]int64

func (__ OfComplex128NInt64) Load(k complex128) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NInt64) Store(k complex128, v int64) {
	__[k] = v
}
func (__ OfComplex128NInt64) Delete(k complex128, v int64) {
	delete(__, k)
}
func (__ OfComplex128NInt64) Range(f func(k complex128, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NInt64 = OfComplex128NInt64
type OfComplex128NInt64St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NInt64
}

func NewOfComplex128NInt64St(somes OfComplex128NInt64) *OfComplex128NInt64St {
	return &OfComplex128NInt64St{
		_OfComplex128NInt64: somes,
	}
}

type OfComplex128NInt8If interface {
	Load(complex128) (int8, error)
}

type OfComplex128NInt8MutIf interface {
	Store(complex128, int8)
	Delete(complex128)
}

type OfComplex128NInt8IterIf interface {
	Range(func(complex128, int8) bool)
}

type OfComplex128NInt8 map[complex128]int8

func (__ OfComplex128NInt8) Load(k complex128) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NInt8) Store(k complex128, v int8) {
	__[k] = v
}
func (__ OfComplex128NInt8) Delete(k complex128, v int8) {
	delete(__, k)
}
func (__ OfComplex128NInt8) Range(f func(k complex128, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NInt8 = OfComplex128NInt8
type OfComplex128NInt8St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NInt8
}

func NewOfComplex128NInt8St(somes OfComplex128NInt8) *OfComplex128NInt8St {
	return &OfComplex128NInt8St{
		_OfComplex128NInt8: somes,
	}
}

type OfComplex128NRuneIf interface {
	Load(complex128) (rune, error)
}

type OfComplex128NRuneMutIf interface {
	Store(complex128, rune)
	Delete(complex128)
}

type OfComplex128NRuneIterIf interface {
	Range(func(complex128, rune) bool)
}

type OfComplex128NRune map[complex128]rune

func (__ OfComplex128NRune) Load(k complex128) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NRune) Store(k complex128, v rune) {
	__[k] = v
}
func (__ OfComplex128NRune) Delete(k complex128, v rune) {
	delete(__, k)
}
func (__ OfComplex128NRune) Range(f func(k complex128, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NRune = OfComplex128NRune
type OfComplex128NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NRune
}

func NewOfComplex128NRuneSt(somes OfComplex128NRune) *OfComplex128NRuneSt {
	return &OfComplex128NRuneSt{
		_OfComplex128NRune: somes,
	}
}

type OfComplex128NStringIf interface {
	Load(complex128) (string, error)
}

type OfComplex128NStringMutIf interface {
	Store(complex128, string)
	Delete(complex128)
}

type OfComplex128NStringIterIf interface {
	Range(func(complex128, string) bool)
}

type OfComplex128NString map[complex128]string

func (__ OfComplex128NString) Load(k complex128) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NString) Store(k complex128, v string) {
	__[k] = v
}
func (__ OfComplex128NString) Delete(k complex128, v string) {
	delete(__, k)
}
func (__ OfComplex128NString) Range(f func(k complex128, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NString = OfComplex128NString
type OfComplex128NStringSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NString
}

func NewOfComplex128NStringSt(somes OfComplex128NString) *OfComplex128NStringSt {
	return &OfComplex128NStringSt{
		_OfComplex128NString: somes,
	}
}

type OfComplex128NUintIf interface {
	Load(complex128) (uint, error)
}

type OfComplex128NUintMutIf interface {
	Store(complex128, uint)
	Delete(complex128)
}

type OfComplex128NUintIterIf interface {
	Range(func(complex128, uint) bool)
}

type OfComplex128NUint map[complex128]uint

func (__ OfComplex128NUint) Load(k complex128) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NUint) Store(k complex128, v uint) {
	__[k] = v
}
func (__ OfComplex128NUint) Delete(k complex128, v uint) {
	delete(__, k)
}
func (__ OfComplex128NUint) Range(f func(k complex128, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NUint = OfComplex128NUint
type OfComplex128NUintSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NUint
}

func NewOfComplex128NUintSt(somes OfComplex128NUint) *OfComplex128NUintSt {
	return &OfComplex128NUintSt{
		_OfComplex128NUint: somes,
	}
}

type OfComplex128NUint16If interface {
	Load(complex128) (uint16, error)
}

type OfComplex128NUint16MutIf interface {
	Store(complex128, uint16)
	Delete(complex128)
}

type OfComplex128NUint16IterIf interface {
	Range(func(complex128, uint16) bool)
}

type OfComplex128NUint16 map[complex128]uint16

func (__ OfComplex128NUint16) Load(k complex128) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NUint16) Store(k complex128, v uint16) {
	__[k] = v
}
func (__ OfComplex128NUint16) Delete(k complex128, v uint16) {
	delete(__, k)
}
func (__ OfComplex128NUint16) Range(f func(k complex128, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NUint16 = OfComplex128NUint16
type OfComplex128NUint16St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NUint16
}

func NewOfComplex128NUint16St(somes OfComplex128NUint16) *OfComplex128NUint16St {
	return &OfComplex128NUint16St{
		_OfComplex128NUint16: somes,
	}
}

type OfComplex128NUint32If interface {
	Load(complex128) (uint32, error)
}

type OfComplex128NUint32MutIf interface {
	Store(complex128, uint32)
	Delete(complex128)
}

type OfComplex128NUint32IterIf interface {
	Range(func(complex128, uint32) bool)
}

type OfComplex128NUint32 map[complex128]uint32

func (__ OfComplex128NUint32) Load(k complex128) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NUint32) Store(k complex128, v uint32) {
	__[k] = v
}
func (__ OfComplex128NUint32) Delete(k complex128, v uint32) {
	delete(__, k)
}
func (__ OfComplex128NUint32) Range(f func(k complex128, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NUint32 = OfComplex128NUint32
type OfComplex128NUint32St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NUint32
}

func NewOfComplex128NUint32St(somes OfComplex128NUint32) *OfComplex128NUint32St {
	return &OfComplex128NUint32St{
		_OfComplex128NUint32: somes,
	}
}

type OfComplex128NUint64If interface {
	Load(complex128) (uint64, error)
}

type OfComplex128NUint64MutIf interface {
	Store(complex128, uint64)
	Delete(complex128)
}

type OfComplex128NUint64IterIf interface {
	Range(func(complex128, uint64) bool)
}

type OfComplex128NUint64 map[complex128]uint64

func (__ OfComplex128NUint64) Load(k complex128) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NUint64) Store(k complex128, v uint64) {
	__[k] = v
}
func (__ OfComplex128NUint64) Delete(k complex128, v uint64) {
	delete(__, k)
}
func (__ OfComplex128NUint64) Range(f func(k complex128, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NUint64 = OfComplex128NUint64
type OfComplex128NUint64St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NUint64
}

func NewOfComplex128NUint64St(somes OfComplex128NUint64) *OfComplex128NUint64St {
	return &OfComplex128NUint64St{
		_OfComplex128NUint64: somes,
	}
}

type OfComplex128NUint8If interface {
	Load(complex128) (uint8, error)
}

type OfComplex128NUint8MutIf interface {
	Store(complex128, uint8)
	Delete(complex128)
}

type OfComplex128NUint8IterIf interface {
	Range(func(complex128, uint8) bool)
}

type OfComplex128NUint8 map[complex128]uint8

func (__ OfComplex128NUint8) Load(k complex128) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NUint8) Store(k complex128, v uint8) {
	__[k] = v
}
func (__ OfComplex128NUint8) Delete(k complex128, v uint8) {
	delete(__, k)
}
func (__ OfComplex128NUint8) Range(f func(k complex128, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NUint8 = OfComplex128NUint8
type OfComplex128NUint8St struct {
	// do not want to export but want to use embedding method
	_OfComplex128NUint8
}

func NewOfComplex128NUint8St(somes OfComplex128NUint8) *OfComplex128NUint8St {
	return &OfComplex128NUint8St{
		_OfComplex128NUint8: somes,
	}
}

type OfComplex128NUintptrIf interface {
	Load(complex128) (uintptr, error)
}

type OfComplex128NUintptrMutIf interface {
	Store(complex128, uintptr)
	Delete(complex128)
}

type OfComplex128NUintptrIterIf interface {
	Range(func(complex128, uintptr) bool)
}

type OfComplex128NUintptr map[complex128]uintptr

func (__ OfComplex128NUintptr) Load(k complex128) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NUintptr) Store(k complex128, v uintptr) {
	__[k] = v
}
func (__ OfComplex128NUintptr) Delete(k complex128, v uintptr) {
	delete(__, k)
}
func (__ OfComplex128NUintptr) Range(f func(k complex128, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NUintptr = OfComplex128NUintptr
type OfComplex128NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NUintptr
}

func NewOfComplex128NUintptrSt(somes OfComplex128NUintptr) *OfComplex128NUintptrSt {
	return &OfComplex128NUintptrSt{
		_OfComplex128NUintptr: somes,
	}
}

type OfComplex128NInterfaceIf interface {
	Load(complex128) (interface{}, error)
}

type OfComplex128NInterfaceMutIf interface {
	Store(complex128, interface{})
	Delete(complex128)
}

type OfComplex128NInterfaceIterIf interface {
	Range(func(complex128, interface{}) bool)
}

type OfComplex128NInterface map[complex128]interface{}

func (__ OfComplex128NInterface) Load(k complex128) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex128NInterface) Store(k complex128, v interface{}) {
	__[k] = v
}
func (__ OfComplex128NInterface) Delete(k complex128, v interface{}) {
	delete(__, k)
}
func (__ OfComplex128NInterface) Range(f func(k complex128, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex128NInterface = OfComplex128NInterface
type OfComplex128NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfComplex128NInterface
}

func NewOfComplex128NInterfaceSt(somes OfComplex128NInterface) *OfComplex128NInterfaceSt {
	return &OfComplex128NInterfaceSt{
		_OfComplex128NInterface: somes,
	}
}

type OfComplex64NBoolIf interface {
	Load(complex64) (bool, error)
}

type OfComplex64NBoolMutIf interface {
	Store(complex64, bool)
	Delete(complex64)
}

type OfComplex64NBoolIterIf interface {
	Range(func(complex64, bool) bool)
}

type OfComplex64NBool map[complex64]bool

func (__ OfComplex64NBool) Load(k complex64) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NBool) Store(k complex64, v bool) {
	__[k] = v
}
func (__ OfComplex64NBool) Delete(k complex64, v bool) {
	delete(__, k)
}
func (__ OfComplex64NBool) Range(f func(k complex64, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NBool = OfComplex64NBool
type OfComplex64NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NBool
}

func NewOfComplex64NBoolSt(somes OfComplex64NBool) *OfComplex64NBoolSt {
	return &OfComplex64NBoolSt{
		_OfComplex64NBool: somes,
	}
}

type OfComplex64NByteIf interface {
	Load(complex64) (byte, error)
}

type OfComplex64NByteMutIf interface {
	Store(complex64, byte)
	Delete(complex64)
}

type OfComplex64NByteIterIf interface {
	Range(func(complex64, byte) bool)
}

type OfComplex64NByte map[complex64]byte

func (__ OfComplex64NByte) Load(k complex64) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NByte) Store(k complex64, v byte) {
	__[k] = v
}
func (__ OfComplex64NByte) Delete(k complex64, v byte) {
	delete(__, k)
}
func (__ OfComplex64NByte) Range(f func(k complex64, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NByte = OfComplex64NByte
type OfComplex64NByteSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NByte
}

func NewOfComplex64NByteSt(somes OfComplex64NByte) *OfComplex64NByteSt {
	return &OfComplex64NByteSt{
		_OfComplex64NByte: somes,
	}
}

type OfComplex64NComplex128If interface {
	Load(complex64) (complex128, error)
}

type OfComplex64NComplex128MutIf interface {
	Store(complex64, complex128)
	Delete(complex64)
}

type OfComplex64NComplex128IterIf interface {
	Range(func(complex64, complex128) bool)
}

type OfComplex64NComplex128 map[complex64]complex128

func (__ OfComplex64NComplex128) Load(k complex64) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NComplex128) Store(k complex64, v complex128) {
	__[k] = v
}
func (__ OfComplex64NComplex128) Delete(k complex64, v complex128) {
	delete(__, k)
}
func (__ OfComplex64NComplex128) Range(f func(k complex64, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NComplex128 = OfComplex64NComplex128
type OfComplex64NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NComplex128
}

func NewOfComplex64NComplex128St(somes OfComplex64NComplex128) *OfComplex64NComplex128St {
	return &OfComplex64NComplex128St{
		_OfComplex64NComplex128: somes,
	}
}

type OfComplex64NComplex64If interface {
	Load(complex64) (complex64, error)
}

type OfComplex64NComplex64MutIf interface {
	Store(complex64, complex64)
	Delete(complex64)
}

type OfComplex64NComplex64IterIf interface {
	Range(func(complex64, complex64) bool)
}

type OfComplex64NComplex64 map[complex64]complex64

func (__ OfComplex64NComplex64) Load(k complex64) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NComplex64) Store(k complex64, v complex64) {
	__[k] = v
}
func (__ OfComplex64NComplex64) Delete(k complex64, v complex64) {
	delete(__, k)
}
func (__ OfComplex64NComplex64) Range(f func(k complex64, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NComplex64 = OfComplex64NComplex64
type OfComplex64NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NComplex64
}

func NewOfComplex64NComplex64St(somes OfComplex64NComplex64) *OfComplex64NComplex64St {
	return &OfComplex64NComplex64St{
		_OfComplex64NComplex64: somes,
	}
}

type OfComplex64NErrorIf interface {
	Load(complex64) (error, error)
}

type OfComplex64NErrorMutIf interface {
	Store(complex64, error)
	Delete(complex64)
}

type OfComplex64NErrorIterIf interface {
	Range(func(complex64, error) bool)
}

type OfComplex64NError map[complex64]error

func (__ OfComplex64NError) Load(k complex64) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NError) Store(k complex64, v error) {
	__[k] = v
}
func (__ OfComplex64NError) Delete(k complex64, v error) {
	delete(__, k)
}
func (__ OfComplex64NError) Range(f func(k complex64, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NError = OfComplex64NError
type OfComplex64NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NError
}

func NewOfComplex64NErrorSt(somes OfComplex64NError) *OfComplex64NErrorSt {
	return &OfComplex64NErrorSt{
		_OfComplex64NError: somes,
	}
}

type OfComplex64NFloat32If interface {
	Load(complex64) (float32, error)
}

type OfComplex64NFloat32MutIf interface {
	Store(complex64, float32)
	Delete(complex64)
}

type OfComplex64NFloat32IterIf interface {
	Range(func(complex64, float32) bool)
}

type OfComplex64NFloat32 map[complex64]float32

func (__ OfComplex64NFloat32) Load(k complex64) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NFloat32) Store(k complex64, v float32) {
	__[k] = v
}
func (__ OfComplex64NFloat32) Delete(k complex64, v float32) {
	delete(__, k)
}
func (__ OfComplex64NFloat32) Range(f func(k complex64, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NFloat32 = OfComplex64NFloat32
type OfComplex64NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NFloat32
}

func NewOfComplex64NFloat32St(somes OfComplex64NFloat32) *OfComplex64NFloat32St {
	return &OfComplex64NFloat32St{
		_OfComplex64NFloat32: somes,
	}
}

type OfComplex64NFloat64If interface {
	Load(complex64) (float64, error)
}

type OfComplex64NFloat64MutIf interface {
	Store(complex64, float64)
	Delete(complex64)
}

type OfComplex64NFloat64IterIf interface {
	Range(func(complex64, float64) bool)
}

type OfComplex64NFloat64 map[complex64]float64

func (__ OfComplex64NFloat64) Load(k complex64) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NFloat64) Store(k complex64, v float64) {
	__[k] = v
}
func (__ OfComplex64NFloat64) Delete(k complex64, v float64) {
	delete(__, k)
}
func (__ OfComplex64NFloat64) Range(f func(k complex64, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NFloat64 = OfComplex64NFloat64
type OfComplex64NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NFloat64
}

func NewOfComplex64NFloat64St(somes OfComplex64NFloat64) *OfComplex64NFloat64St {
	return &OfComplex64NFloat64St{
		_OfComplex64NFloat64: somes,
	}
}

type OfComplex64NIntIf interface {
	Load(complex64) (int, error)
}

type OfComplex64NIntMutIf interface {
	Store(complex64, int)
	Delete(complex64)
}

type OfComplex64NIntIterIf interface {
	Range(func(complex64, int) bool)
}

type OfComplex64NInt map[complex64]int

func (__ OfComplex64NInt) Load(k complex64) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NInt) Store(k complex64, v int) {
	__[k] = v
}
func (__ OfComplex64NInt) Delete(k complex64, v int) {
	delete(__, k)
}
func (__ OfComplex64NInt) Range(f func(k complex64, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NInt = OfComplex64NInt
type OfComplex64NIntSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NInt
}

func NewOfComplex64NIntSt(somes OfComplex64NInt) *OfComplex64NIntSt {
	return &OfComplex64NIntSt{
		_OfComplex64NInt: somes,
	}
}

type OfComplex64NInt16If interface {
	Load(complex64) (int16, error)
}

type OfComplex64NInt16MutIf interface {
	Store(complex64, int16)
	Delete(complex64)
}

type OfComplex64NInt16IterIf interface {
	Range(func(complex64, int16) bool)
}

type OfComplex64NInt16 map[complex64]int16

func (__ OfComplex64NInt16) Load(k complex64) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NInt16) Store(k complex64, v int16) {
	__[k] = v
}
func (__ OfComplex64NInt16) Delete(k complex64, v int16) {
	delete(__, k)
}
func (__ OfComplex64NInt16) Range(f func(k complex64, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NInt16 = OfComplex64NInt16
type OfComplex64NInt16St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NInt16
}

func NewOfComplex64NInt16St(somes OfComplex64NInt16) *OfComplex64NInt16St {
	return &OfComplex64NInt16St{
		_OfComplex64NInt16: somes,
	}
}

type OfComplex64NInt32If interface {
	Load(complex64) (int32, error)
}

type OfComplex64NInt32MutIf interface {
	Store(complex64, int32)
	Delete(complex64)
}

type OfComplex64NInt32IterIf interface {
	Range(func(complex64, int32) bool)
}

type OfComplex64NInt32 map[complex64]int32

func (__ OfComplex64NInt32) Load(k complex64) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NInt32) Store(k complex64, v int32) {
	__[k] = v
}
func (__ OfComplex64NInt32) Delete(k complex64, v int32) {
	delete(__, k)
}
func (__ OfComplex64NInt32) Range(f func(k complex64, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NInt32 = OfComplex64NInt32
type OfComplex64NInt32St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NInt32
}

func NewOfComplex64NInt32St(somes OfComplex64NInt32) *OfComplex64NInt32St {
	return &OfComplex64NInt32St{
		_OfComplex64NInt32: somes,
	}
}

type OfComplex64NInt64If interface {
	Load(complex64) (int64, error)
}

type OfComplex64NInt64MutIf interface {
	Store(complex64, int64)
	Delete(complex64)
}

type OfComplex64NInt64IterIf interface {
	Range(func(complex64, int64) bool)
}

type OfComplex64NInt64 map[complex64]int64

func (__ OfComplex64NInt64) Load(k complex64) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NInt64) Store(k complex64, v int64) {
	__[k] = v
}
func (__ OfComplex64NInt64) Delete(k complex64, v int64) {
	delete(__, k)
}
func (__ OfComplex64NInt64) Range(f func(k complex64, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NInt64 = OfComplex64NInt64
type OfComplex64NInt64St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NInt64
}

func NewOfComplex64NInt64St(somes OfComplex64NInt64) *OfComplex64NInt64St {
	return &OfComplex64NInt64St{
		_OfComplex64NInt64: somes,
	}
}

type OfComplex64NInt8If interface {
	Load(complex64) (int8, error)
}

type OfComplex64NInt8MutIf interface {
	Store(complex64, int8)
	Delete(complex64)
}

type OfComplex64NInt8IterIf interface {
	Range(func(complex64, int8) bool)
}

type OfComplex64NInt8 map[complex64]int8

func (__ OfComplex64NInt8) Load(k complex64) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NInt8) Store(k complex64, v int8) {
	__[k] = v
}
func (__ OfComplex64NInt8) Delete(k complex64, v int8) {
	delete(__, k)
}
func (__ OfComplex64NInt8) Range(f func(k complex64, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NInt8 = OfComplex64NInt8
type OfComplex64NInt8St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NInt8
}

func NewOfComplex64NInt8St(somes OfComplex64NInt8) *OfComplex64NInt8St {
	return &OfComplex64NInt8St{
		_OfComplex64NInt8: somes,
	}
}

type OfComplex64NRuneIf interface {
	Load(complex64) (rune, error)
}

type OfComplex64NRuneMutIf interface {
	Store(complex64, rune)
	Delete(complex64)
}

type OfComplex64NRuneIterIf interface {
	Range(func(complex64, rune) bool)
}

type OfComplex64NRune map[complex64]rune

func (__ OfComplex64NRune) Load(k complex64) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NRune) Store(k complex64, v rune) {
	__[k] = v
}
func (__ OfComplex64NRune) Delete(k complex64, v rune) {
	delete(__, k)
}
func (__ OfComplex64NRune) Range(f func(k complex64, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NRune = OfComplex64NRune
type OfComplex64NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NRune
}

func NewOfComplex64NRuneSt(somes OfComplex64NRune) *OfComplex64NRuneSt {
	return &OfComplex64NRuneSt{
		_OfComplex64NRune: somes,
	}
}

type OfComplex64NStringIf interface {
	Load(complex64) (string, error)
}

type OfComplex64NStringMutIf interface {
	Store(complex64, string)
	Delete(complex64)
}

type OfComplex64NStringIterIf interface {
	Range(func(complex64, string) bool)
}

type OfComplex64NString map[complex64]string

func (__ OfComplex64NString) Load(k complex64) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NString) Store(k complex64, v string) {
	__[k] = v
}
func (__ OfComplex64NString) Delete(k complex64, v string) {
	delete(__, k)
}
func (__ OfComplex64NString) Range(f func(k complex64, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NString = OfComplex64NString
type OfComplex64NStringSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NString
}

func NewOfComplex64NStringSt(somes OfComplex64NString) *OfComplex64NStringSt {
	return &OfComplex64NStringSt{
		_OfComplex64NString: somes,
	}
}

type OfComplex64NUintIf interface {
	Load(complex64) (uint, error)
}

type OfComplex64NUintMutIf interface {
	Store(complex64, uint)
	Delete(complex64)
}

type OfComplex64NUintIterIf interface {
	Range(func(complex64, uint) bool)
}

type OfComplex64NUint map[complex64]uint

func (__ OfComplex64NUint) Load(k complex64) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NUint) Store(k complex64, v uint) {
	__[k] = v
}
func (__ OfComplex64NUint) Delete(k complex64, v uint) {
	delete(__, k)
}
func (__ OfComplex64NUint) Range(f func(k complex64, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NUint = OfComplex64NUint
type OfComplex64NUintSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NUint
}

func NewOfComplex64NUintSt(somes OfComplex64NUint) *OfComplex64NUintSt {
	return &OfComplex64NUintSt{
		_OfComplex64NUint: somes,
	}
}

type OfComplex64NUint16If interface {
	Load(complex64) (uint16, error)
}

type OfComplex64NUint16MutIf interface {
	Store(complex64, uint16)
	Delete(complex64)
}

type OfComplex64NUint16IterIf interface {
	Range(func(complex64, uint16) bool)
}

type OfComplex64NUint16 map[complex64]uint16

func (__ OfComplex64NUint16) Load(k complex64) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NUint16) Store(k complex64, v uint16) {
	__[k] = v
}
func (__ OfComplex64NUint16) Delete(k complex64, v uint16) {
	delete(__, k)
}
func (__ OfComplex64NUint16) Range(f func(k complex64, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NUint16 = OfComplex64NUint16
type OfComplex64NUint16St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NUint16
}

func NewOfComplex64NUint16St(somes OfComplex64NUint16) *OfComplex64NUint16St {
	return &OfComplex64NUint16St{
		_OfComplex64NUint16: somes,
	}
}

type OfComplex64NUint32If interface {
	Load(complex64) (uint32, error)
}

type OfComplex64NUint32MutIf interface {
	Store(complex64, uint32)
	Delete(complex64)
}

type OfComplex64NUint32IterIf interface {
	Range(func(complex64, uint32) bool)
}

type OfComplex64NUint32 map[complex64]uint32

func (__ OfComplex64NUint32) Load(k complex64) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NUint32) Store(k complex64, v uint32) {
	__[k] = v
}
func (__ OfComplex64NUint32) Delete(k complex64, v uint32) {
	delete(__, k)
}
func (__ OfComplex64NUint32) Range(f func(k complex64, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NUint32 = OfComplex64NUint32
type OfComplex64NUint32St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NUint32
}

func NewOfComplex64NUint32St(somes OfComplex64NUint32) *OfComplex64NUint32St {
	return &OfComplex64NUint32St{
		_OfComplex64NUint32: somes,
	}
}

type OfComplex64NUint64If interface {
	Load(complex64) (uint64, error)
}

type OfComplex64NUint64MutIf interface {
	Store(complex64, uint64)
	Delete(complex64)
}

type OfComplex64NUint64IterIf interface {
	Range(func(complex64, uint64) bool)
}

type OfComplex64NUint64 map[complex64]uint64

func (__ OfComplex64NUint64) Load(k complex64) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NUint64) Store(k complex64, v uint64) {
	__[k] = v
}
func (__ OfComplex64NUint64) Delete(k complex64, v uint64) {
	delete(__, k)
}
func (__ OfComplex64NUint64) Range(f func(k complex64, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NUint64 = OfComplex64NUint64
type OfComplex64NUint64St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NUint64
}

func NewOfComplex64NUint64St(somes OfComplex64NUint64) *OfComplex64NUint64St {
	return &OfComplex64NUint64St{
		_OfComplex64NUint64: somes,
	}
}

type OfComplex64NUint8If interface {
	Load(complex64) (uint8, error)
}

type OfComplex64NUint8MutIf interface {
	Store(complex64, uint8)
	Delete(complex64)
}

type OfComplex64NUint8IterIf interface {
	Range(func(complex64, uint8) bool)
}

type OfComplex64NUint8 map[complex64]uint8

func (__ OfComplex64NUint8) Load(k complex64) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NUint8) Store(k complex64, v uint8) {
	__[k] = v
}
func (__ OfComplex64NUint8) Delete(k complex64, v uint8) {
	delete(__, k)
}
func (__ OfComplex64NUint8) Range(f func(k complex64, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NUint8 = OfComplex64NUint8
type OfComplex64NUint8St struct {
	// do not want to export but want to use embedding method
	_OfComplex64NUint8
}

func NewOfComplex64NUint8St(somes OfComplex64NUint8) *OfComplex64NUint8St {
	return &OfComplex64NUint8St{
		_OfComplex64NUint8: somes,
	}
}

type OfComplex64NUintptrIf interface {
	Load(complex64) (uintptr, error)
}

type OfComplex64NUintptrMutIf interface {
	Store(complex64, uintptr)
	Delete(complex64)
}

type OfComplex64NUintptrIterIf interface {
	Range(func(complex64, uintptr) bool)
}

type OfComplex64NUintptr map[complex64]uintptr

func (__ OfComplex64NUintptr) Load(k complex64) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NUintptr) Store(k complex64, v uintptr) {
	__[k] = v
}
func (__ OfComplex64NUintptr) Delete(k complex64, v uintptr) {
	delete(__, k)
}
func (__ OfComplex64NUintptr) Range(f func(k complex64, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NUintptr = OfComplex64NUintptr
type OfComplex64NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NUintptr
}

func NewOfComplex64NUintptrSt(somes OfComplex64NUintptr) *OfComplex64NUintptrSt {
	return &OfComplex64NUintptrSt{
		_OfComplex64NUintptr: somes,
	}
}

type OfComplex64NInterfaceIf interface {
	Load(complex64) (interface{}, error)
}

type OfComplex64NInterfaceMutIf interface {
	Store(complex64, interface{})
	Delete(complex64)
}

type OfComplex64NInterfaceIterIf interface {
	Range(func(complex64, interface{}) bool)
}

type OfComplex64NInterface map[complex64]interface{}

func (__ OfComplex64NInterface) Load(k complex64) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfComplex64NInterface) Store(k complex64, v interface{}) {
	__[k] = v
}
func (__ OfComplex64NInterface) Delete(k complex64, v interface{}) {
	delete(__, k)
}
func (__ OfComplex64NInterface) Range(f func(k complex64, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfComplex64NInterface = OfComplex64NInterface
type OfComplex64NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfComplex64NInterface
}

func NewOfComplex64NInterfaceSt(somes OfComplex64NInterface) *OfComplex64NInterfaceSt {
	return &OfComplex64NInterfaceSt{
		_OfComplex64NInterface: somes,
	}
}

type OfErrorNBoolIf interface {
	Load(error) (bool, error)
}

type OfErrorNBoolMutIf interface {
	Store(error, bool)
	Delete(error)
}

type OfErrorNBoolIterIf interface {
	Range(func(error, bool) bool)
}

type OfErrorNBool map[error]bool

func (__ OfErrorNBool) Load(k error) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNBool) Store(k error, v bool) {
	__[k] = v
}
func (__ OfErrorNBool) Delete(k error, v bool) {
	delete(__, k)
}
func (__ OfErrorNBool) Range(f func(k error, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNBool = OfErrorNBool
type OfErrorNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNBool
}

func NewOfErrorNBoolSt(somes OfErrorNBool) *OfErrorNBoolSt {
	return &OfErrorNBoolSt{
		_OfErrorNBool: somes,
	}
}

type OfErrorNByteIf interface {
	Load(error) (byte, error)
}

type OfErrorNByteMutIf interface {
	Store(error, byte)
	Delete(error)
}

type OfErrorNByteIterIf interface {
	Range(func(error, byte) bool)
}

type OfErrorNByte map[error]byte

func (__ OfErrorNByte) Load(k error) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNByte) Store(k error, v byte) {
	__[k] = v
}
func (__ OfErrorNByte) Delete(k error, v byte) {
	delete(__, k)
}
func (__ OfErrorNByte) Range(f func(k error, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNByte = OfErrorNByte
type OfErrorNByteSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNByte
}

func NewOfErrorNByteSt(somes OfErrorNByte) *OfErrorNByteSt {
	return &OfErrorNByteSt{
		_OfErrorNByte: somes,
	}
}

type OfErrorNComplex128If interface {
	Load(error) (complex128, error)
}

type OfErrorNComplex128MutIf interface {
	Store(error, complex128)
	Delete(error)
}

type OfErrorNComplex128IterIf interface {
	Range(func(error, complex128) bool)
}

type OfErrorNComplex128 map[error]complex128

func (__ OfErrorNComplex128) Load(k error) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNComplex128) Store(k error, v complex128) {
	__[k] = v
}
func (__ OfErrorNComplex128) Delete(k error, v complex128) {
	delete(__, k)
}
func (__ OfErrorNComplex128) Range(f func(k error, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNComplex128 = OfErrorNComplex128
type OfErrorNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfErrorNComplex128
}

func NewOfErrorNComplex128St(somes OfErrorNComplex128) *OfErrorNComplex128St {
	return &OfErrorNComplex128St{
		_OfErrorNComplex128: somes,
	}
}

type OfErrorNComplex64If interface {
	Load(error) (complex64, error)
}

type OfErrorNComplex64MutIf interface {
	Store(error, complex64)
	Delete(error)
}

type OfErrorNComplex64IterIf interface {
	Range(func(error, complex64) bool)
}

type OfErrorNComplex64 map[error]complex64

func (__ OfErrorNComplex64) Load(k error) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNComplex64) Store(k error, v complex64) {
	__[k] = v
}
func (__ OfErrorNComplex64) Delete(k error, v complex64) {
	delete(__, k)
}
func (__ OfErrorNComplex64) Range(f func(k error, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNComplex64 = OfErrorNComplex64
type OfErrorNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfErrorNComplex64
}

func NewOfErrorNComplex64St(somes OfErrorNComplex64) *OfErrorNComplex64St {
	return &OfErrorNComplex64St{
		_OfErrorNComplex64: somes,
	}
}

type OfErrorNErrorIf interface {
	Load(error) (error, error)
}

type OfErrorNErrorMutIf interface {
	Store(error, error)
	Delete(error)
}

type OfErrorNErrorIterIf interface {
	Range(func(error, error) bool)
}

type OfErrorNError map[error]error

func (__ OfErrorNError) Load(k error) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNError) Store(k error, v error) {
	__[k] = v
}
func (__ OfErrorNError) Delete(k error, v error) {
	delete(__, k)
}
func (__ OfErrorNError) Range(f func(k error, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNError = OfErrorNError
type OfErrorNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNError
}

func NewOfErrorNErrorSt(somes OfErrorNError) *OfErrorNErrorSt {
	return &OfErrorNErrorSt{
		_OfErrorNError: somes,
	}
}

type OfErrorNFloat32If interface {
	Load(error) (float32, error)
}

type OfErrorNFloat32MutIf interface {
	Store(error, float32)
	Delete(error)
}

type OfErrorNFloat32IterIf interface {
	Range(func(error, float32) bool)
}

type OfErrorNFloat32 map[error]float32

func (__ OfErrorNFloat32) Load(k error) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNFloat32) Store(k error, v float32) {
	__[k] = v
}
func (__ OfErrorNFloat32) Delete(k error, v float32) {
	delete(__, k)
}
func (__ OfErrorNFloat32) Range(f func(k error, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNFloat32 = OfErrorNFloat32
type OfErrorNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfErrorNFloat32
}

func NewOfErrorNFloat32St(somes OfErrorNFloat32) *OfErrorNFloat32St {
	return &OfErrorNFloat32St{
		_OfErrorNFloat32: somes,
	}
}

type OfErrorNFloat64If interface {
	Load(error) (float64, error)
}

type OfErrorNFloat64MutIf interface {
	Store(error, float64)
	Delete(error)
}

type OfErrorNFloat64IterIf interface {
	Range(func(error, float64) bool)
}

type OfErrorNFloat64 map[error]float64

func (__ OfErrorNFloat64) Load(k error) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNFloat64) Store(k error, v float64) {
	__[k] = v
}
func (__ OfErrorNFloat64) Delete(k error, v float64) {
	delete(__, k)
}
func (__ OfErrorNFloat64) Range(f func(k error, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNFloat64 = OfErrorNFloat64
type OfErrorNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfErrorNFloat64
}

func NewOfErrorNFloat64St(somes OfErrorNFloat64) *OfErrorNFloat64St {
	return &OfErrorNFloat64St{
		_OfErrorNFloat64: somes,
	}
}

type OfErrorNIntIf interface {
	Load(error) (int, error)
}

type OfErrorNIntMutIf interface {
	Store(error, int)
	Delete(error)
}

type OfErrorNIntIterIf interface {
	Range(func(error, int) bool)
}

type OfErrorNInt map[error]int

func (__ OfErrorNInt) Load(k error) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNInt) Store(k error, v int) {
	__[k] = v
}
func (__ OfErrorNInt) Delete(k error, v int) {
	delete(__, k)
}
func (__ OfErrorNInt) Range(f func(k error, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNInt = OfErrorNInt
type OfErrorNIntSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNInt
}

func NewOfErrorNIntSt(somes OfErrorNInt) *OfErrorNIntSt {
	return &OfErrorNIntSt{
		_OfErrorNInt: somes,
	}
}

type OfErrorNInt16If interface {
	Load(error) (int16, error)
}

type OfErrorNInt16MutIf interface {
	Store(error, int16)
	Delete(error)
}

type OfErrorNInt16IterIf interface {
	Range(func(error, int16) bool)
}

type OfErrorNInt16 map[error]int16

func (__ OfErrorNInt16) Load(k error) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNInt16) Store(k error, v int16) {
	__[k] = v
}
func (__ OfErrorNInt16) Delete(k error, v int16) {
	delete(__, k)
}
func (__ OfErrorNInt16) Range(f func(k error, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNInt16 = OfErrorNInt16
type OfErrorNInt16St struct {
	// do not want to export but want to use embedding method
	_OfErrorNInt16
}

func NewOfErrorNInt16St(somes OfErrorNInt16) *OfErrorNInt16St {
	return &OfErrorNInt16St{
		_OfErrorNInt16: somes,
	}
}

type OfErrorNInt32If interface {
	Load(error) (int32, error)
}

type OfErrorNInt32MutIf interface {
	Store(error, int32)
	Delete(error)
}

type OfErrorNInt32IterIf interface {
	Range(func(error, int32) bool)
}

type OfErrorNInt32 map[error]int32

func (__ OfErrorNInt32) Load(k error) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNInt32) Store(k error, v int32) {
	__[k] = v
}
func (__ OfErrorNInt32) Delete(k error, v int32) {
	delete(__, k)
}
func (__ OfErrorNInt32) Range(f func(k error, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNInt32 = OfErrorNInt32
type OfErrorNInt32St struct {
	// do not want to export but want to use embedding method
	_OfErrorNInt32
}

func NewOfErrorNInt32St(somes OfErrorNInt32) *OfErrorNInt32St {
	return &OfErrorNInt32St{
		_OfErrorNInt32: somes,
	}
}

type OfErrorNInt64If interface {
	Load(error) (int64, error)
}

type OfErrorNInt64MutIf interface {
	Store(error, int64)
	Delete(error)
}

type OfErrorNInt64IterIf interface {
	Range(func(error, int64) bool)
}

type OfErrorNInt64 map[error]int64

func (__ OfErrorNInt64) Load(k error) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNInt64) Store(k error, v int64) {
	__[k] = v
}
func (__ OfErrorNInt64) Delete(k error, v int64) {
	delete(__, k)
}
func (__ OfErrorNInt64) Range(f func(k error, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNInt64 = OfErrorNInt64
type OfErrorNInt64St struct {
	// do not want to export but want to use embedding method
	_OfErrorNInt64
}

func NewOfErrorNInt64St(somes OfErrorNInt64) *OfErrorNInt64St {
	return &OfErrorNInt64St{
		_OfErrorNInt64: somes,
	}
}

type OfErrorNInt8If interface {
	Load(error) (int8, error)
}

type OfErrorNInt8MutIf interface {
	Store(error, int8)
	Delete(error)
}

type OfErrorNInt8IterIf interface {
	Range(func(error, int8) bool)
}

type OfErrorNInt8 map[error]int8

func (__ OfErrorNInt8) Load(k error) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNInt8) Store(k error, v int8) {
	__[k] = v
}
func (__ OfErrorNInt8) Delete(k error, v int8) {
	delete(__, k)
}
func (__ OfErrorNInt8) Range(f func(k error, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNInt8 = OfErrorNInt8
type OfErrorNInt8St struct {
	// do not want to export but want to use embedding method
	_OfErrorNInt8
}

func NewOfErrorNInt8St(somes OfErrorNInt8) *OfErrorNInt8St {
	return &OfErrorNInt8St{
		_OfErrorNInt8: somes,
	}
}

type OfErrorNRuneIf interface {
	Load(error) (rune, error)
}

type OfErrorNRuneMutIf interface {
	Store(error, rune)
	Delete(error)
}

type OfErrorNRuneIterIf interface {
	Range(func(error, rune) bool)
}

type OfErrorNRune map[error]rune

func (__ OfErrorNRune) Load(k error) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNRune) Store(k error, v rune) {
	__[k] = v
}
func (__ OfErrorNRune) Delete(k error, v rune) {
	delete(__, k)
}
func (__ OfErrorNRune) Range(f func(k error, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNRune = OfErrorNRune
type OfErrorNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNRune
}

func NewOfErrorNRuneSt(somes OfErrorNRune) *OfErrorNRuneSt {
	return &OfErrorNRuneSt{
		_OfErrorNRune: somes,
	}
}

type OfErrorNStringIf interface {
	Load(error) (string, error)
}

type OfErrorNStringMutIf interface {
	Store(error, string)
	Delete(error)
}

type OfErrorNStringIterIf interface {
	Range(func(error, string) bool)
}

type OfErrorNString map[error]string

func (__ OfErrorNString) Load(k error) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNString) Store(k error, v string) {
	__[k] = v
}
func (__ OfErrorNString) Delete(k error, v string) {
	delete(__, k)
}
func (__ OfErrorNString) Range(f func(k error, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNString = OfErrorNString
type OfErrorNStringSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNString
}

func NewOfErrorNStringSt(somes OfErrorNString) *OfErrorNStringSt {
	return &OfErrorNStringSt{
		_OfErrorNString: somes,
	}
}

type OfErrorNUintIf interface {
	Load(error) (uint, error)
}

type OfErrorNUintMutIf interface {
	Store(error, uint)
	Delete(error)
}

type OfErrorNUintIterIf interface {
	Range(func(error, uint) bool)
}

type OfErrorNUint map[error]uint

func (__ OfErrorNUint) Load(k error) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNUint) Store(k error, v uint) {
	__[k] = v
}
func (__ OfErrorNUint) Delete(k error, v uint) {
	delete(__, k)
}
func (__ OfErrorNUint) Range(f func(k error, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNUint = OfErrorNUint
type OfErrorNUintSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNUint
}

func NewOfErrorNUintSt(somes OfErrorNUint) *OfErrorNUintSt {
	return &OfErrorNUintSt{
		_OfErrorNUint: somes,
	}
}

type OfErrorNUint16If interface {
	Load(error) (uint16, error)
}

type OfErrorNUint16MutIf interface {
	Store(error, uint16)
	Delete(error)
}

type OfErrorNUint16IterIf interface {
	Range(func(error, uint16) bool)
}

type OfErrorNUint16 map[error]uint16

func (__ OfErrorNUint16) Load(k error) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNUint16) Store(k error, v uint16) {
	__[k] = v
}
func (__ OfErrorNUint16) Delete(k error, v uint16) {
	delete(__, k)
}
func (__ OfErrorNUint16) Range(f func(k error, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNUint16 = OfErrorNUint16
type OfErrorNUint16St struct {
	// do not want to export but want to use embedding method
	_OfErrorNUint16
}

func NewOfErrorNUint16St(somes OfErrorNUint16) *OfErrorNUint16St {
	return &OfErrorNUint16St{
		_OfErrorNUint16: somes,
	}
}

type OfErrorNUint32If interface {
	Load(error) (uint32, error)
}

type OfErrorNUint32MutIf interface {
	Store(error, uint32)
	Delete(error)
}

type OfErrorNUint32IterIf interface {
	Range(func(error, uint32) bool)
}

type OfErrorNUint32 map[error]uint32

func (__ OfErrorNUint32) Load(k error) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNUint32) Store(k error, v uint32) {
	__[k] = v
}
func (__ OfErrorNUint32) Delete(k error, v uint32) {
	delete(__, k)
}
func (__ OfErrorNUint32) Range(f func(k error, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNUint32 = OfErrorNUint32
type OfErrorNUint32St struct {
	// do not want to export but want to use embedding method
	_OfErrorNUint32
}

func NewOfErrorNUint32St(somes OfErrorNUint32) *OfErrorNUint32St {
	return &OfErrorNUint32St{
		_OfErrorNUint32: somes,
	}
}

type OfErrorNUint64If interface {
	Load(error) (uint64, error)
}

type OfErrorNUint64MutIf interface {
	Store(error, uint64)
	Delete(error)
}

type OfErrorNUint64IterIf interface {
	Range(func(error, uint64) bool)
}

type OfErrorNUint64 map[error]uint64

func (__ OfErrorNUint64) Load(k error) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNUint64) Store(k error, v uint64) {
	__[k] = v
}
func (__ OfErrorNUint64) Delete(k error, v uint64) {
	delete(__, k)
}
func (__ OfErrorNUint64) Range(f func(k error, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNUint64 = OfErrorNUint64
type OfErrorNUint64St struct {
	// do not want to export but want to use embedding method
	_OfErrorNUint64
}

func NewOfErrorNUint64St(somes OfErrorNUint64) *OfErrorNUint64St {
	return &OfErrorNUint64St{
		_OfErrorNUint64: somes,
	}
}

type OfErrorNUint8If interface {
	Load(error) (uint8, error)
}

type OfErrorNUint8MutIf interface {
	Store(error, uint8)
	Delete(error)
}

type OfErrorNUint8IterIf interface {
	Range(func(error, uint8) bool)
}

type OfErrorNUint8 map[error]uint8

func (__ OfErrorNUint8) Load(k error) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNUint8) Store(k error, v uint8) {
	__[k] = v
}
func (__ OfErrorNUint8) Delete(k error, v uint8) {
	delete(__, k)
}
func (__ OfErrorNUint8) Range(f func(k error, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNUint8 = OfErrorNUint8
type OfErrorNUint8St struct {
	// do not want to export but want to use embedding method
	_OfErrorNUint8
}

func NewOfErrorNUint8St(somes OfErrorNUint8) *OfErrorNUint8St {
	return &OfErrorNUint8St{
		_OfErrorNUint8: somes,
	}
}

type OfErrorNUintptrIf interface {
	Load(error) (uintptr, error)
}

type OfErrorNUintptrMutIf interface {
	Store(error, uintptr)
	Delete(error)
}

type OfErrorNUintptrIterIf interface {
	Range(func(error, uintptr) bool)
}

type OfErrorNUintptr map[error]uintptr

func (__ OfErrorNUintptr) Load(k error) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNUintptr) Store(k error, v uintptr) {
	__[k] = v
}
func (__ OfErrorNUintptr) Delete(k error, v uintptr) {
	delete(__, k)
}
func (__ OfErrorNUintptr) Range(f func(k error, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNUintptr = OfErrorNUintptr
type OfErrorNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNUintptr
}

func NewOfErrorNUintptrSt(somes OfErrorNUintptr) *OfErrorNUintptrSt {
	return &OfErrorNUintptrSt{
		_OfErrorNUintptr: somes,
	}
}

type OfErrorNInterfaceIf interface {
	Load(error) (interface{}, error)
}

type OfErrorNInterfaceMutIf interface {
	Store(error, interface{})
	Delete(error)
}

type OfErrorNInterfaceIterIf interface {
	Range(func(error, interface{}) bool)
}

type OfErrorNInterface map[error]interface{}

func (__ OfErrorNInterface) Load(k error) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfErrorNInterface) Store(k error, v interface{}) {
	__[k] = v
}
func (__ OfErrorNInterface) Delete(k error, v interface{}) {
	delete(__, k)
}
func (__ OfErrorNInterface) Range(f func(k error, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfErrorNInterface = OfErrorNInterface
type OfErrorNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfErrorNInterface
}

func NewOfErrorNInterfaceSt(somes OfErrorNInterface) *OfErrorNInterfaceSt {
	return &OfErrorNInterfaceSt{
		_OfErrorNInterface: somes,
	}
}

type OfFloat32NBoolIf interface {
	Load(float32) (bool, error)
}

type OfFloat32NBoolMutIf interface {
	Store(float32, bool)
	Delete(float32)
}

type OfFloat32NBoolIterIf interface {
	Range(func(float32, bool) bool)
}

type OfFloat32NBool map[float32]bool

func (__ OfFloat32NBool) Load(k float32) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NBool) Store(k float32, v bool) {
	__[k] = v
}
func (__ OfFloat32NBool) Delete(k float32, v bool) {
	delete(__, k)
}
func (__ OfFloat32NBool) Range(f func(k float32, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NBool = OfFloat32NBool
type OfFloat32NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NBool
}

func NewOfFloat32NBoolSt(somes OfFloat32NBool) *OfFloat32NBoolSt {
	return &OfFloat32NBoolSt{
		_OfFloat32NBool: somes,
	}
}

type OfFloat32NByteIf interface {
	Load(float32) (byte, error)
}

type OfFloat32NByteMutIf interface {
	Store(float32, byte)
	Delete(float32)
}

type OfFloat32NByteIterIf interface {
	Range(func(float32, byte) bool)
}

type OfFloat32NByte map[float32]byte

func (__ OfFloat32NByte) Load(k float32) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NByte) Store(k float32, v byte) {
	__[k] = v
}
func (__ OfFloat32NByte) Delete(k float32, v byte) {
	delete(__, k)
}
func (__ OfFloat32NByte) Range(f func(k float32, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NByte = OfFloat32NByte
type OfFloat32NByteSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NByte
}

func NewOfFloat32NByteSt(somes OfFloat32NByte) *OfFloat32NByteSt {
	return &OfFloat32NByteSt{
		_OfFloat32NByte: somes,
	}
}

type OfFloat32NComplex128If interface {
	Load(float32) (complex128, error)
}

type OfFloat32NComplex128MutIf interface {
	Store(float32, complex128)
	Delete(float32)
}

type OfFloat32NComplex128IterIf interface {
	Range(func(float32, complex128) bool)
}

type OfFloat32NComplex128 map[float32]complex128

func (__ OfFloat32NComplex128) Load(k float32) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NComplex128) Store(k float32, v complex128) {
	__[k] = v
}
func (__ OfFloat32NComplex128) Delete(k float32, v complex128) {
	delete(__, k)
}
func (__ OfFloat32NComplex128) Range(f func(k float32, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NComplex128 = OfFloat32NComplex128
type OfFloat32NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NComplex128
}

func NewOfFloat32NComplex128St(somes OfFloat32NComplex128) *OfFloat32NComplex128St {
	return &OfFloat32NComplex128St{
		_OfFloat32NComplex128: somes,
	}
}

type OfFloat32NComplex64If interface {
	Load(float32) (complex64, error)
}

type OfFloat32NComplex64MutIf interface {
	Store(float32, complex64)
	Delete(float32)
}

type OfFloat32NComplex64IterIf interface {
	Range(func(float32, complex64) bool)
}

type OfFloat32NComplex64 map[float32]complex64

func (__ OfFloat32NComplex64) Load(k float32) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NComplex64) Store(k float32, v complex64) {
	__[k] = v
}
func (__ OfFloat32NComplex64) Delete(k float32, v complex64) {
	delete(__, k)
}
func (__ OfFloat32NComplex64) Range(f func(k float32, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NComplex64 = OfFloat32NComplex64
type OfFloat32NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NComplex64
}

func NewOfFloat32NComplex64St(somes OfFloat32NComplex64) *OfFloat32NComplex64St {
	return &OfFloat32NComplex64St{
		_OfFloat32NComplex64: somes,
	}
}

type OfFloat32NErrorIf interface {
	Load(float32) (error, error)
}

type OfFloat32NErrorMutIf interface {
	Store(float32, error)
	Delete(float32)
}

type OfFloat32NErrorIterIf interface {
	Range(func(float32, error) bool)
}

type OfFloat32NError map[float32]error

func (__ OfFloat32NError) Load(k float32) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NError) Store(k float32, v error) {
	__[k] = v
}
func (__ OfFloat32NError) Delete(k float32, v error) {
	delete(__, k)
}
func (__ OfFloat32NError) Range(f func(k float32, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NError = OfFloat32NError
type OfFloat32NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NError
}

func NewOfFloat32NErrorSt(somes OfFloat32NError) *OfFloat32NErrorSt {
	return &OfFloat32NErrorSt{
		_OfFloat32NError: somes,
	}
}

type OfFloat32NFloat32If interface {
	Load(float32) (float32, error)
}

type OfFloat32NFloat32MutIf interface {
	Store(float32, float32)
	Delete(float32)
}

type OfFloat32NFloat32IterIf interface {
	Range(func(float32, float32) bool)
}

type OfFloat32NFloat32 map[float32]float32

func (__ OfFloat32NFloat32) Load(k float32) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NFloat32) Store(k float32, v float32) {
	__[k] = v
}
func (__ OfFloat32NFloat32) Delete(k float32, v float32) {
	delete(__, k)
}
func (__ OfFloat32NFloat32) Range(f func(k float32, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NFloat32 = OfFloat32NFloat32
type OfFloat32NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NFloat32
}

func NewOfFloat32NFloat32St(somes OfFloat32NFloat32) *OfFloat32NFloat32St {
	return &OfFloat32NFloat32St{
		_OfFloat32NFloat32: somes,
	}
}

type OfFloat32NFloat64If interface {
	Load(float32) (float64, error)
}

type OfFloat32NFloat64MutIf interface {
	Store(float32, float64)
	Delete(float32)
}

type OfFloat32NFloat64IterIf interface {
	Range(func(float32, float64) bool)
}

type OfFloat32NFloat64 map[float32]float64

func (__ OfFloat32NFloat64) Load(k float32) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NFloat64) Store(k float32, v float64) {
	__[k] = v
}
func (__ OfFloat32NFloat64) Delete(k float32, v float64) {
	delete(__, k)
}
func (__ OfFloat32NFloat64) Range(f func(k float32, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NFloat64 = OfFloat32NFloat64
type OfFloat32NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NFloat64
}

func NewOfFloat32NFloat64St(somes OfFloat32NFloat64) *OfFloat32NFloat64St {
	return &OfFloat32NFloat64St{
		_OfFloat32NFloat64: somes,
	}
}

type OfFloat32NIntIf interface {
	Load(float32) (int, error)
}

type OfFloat32NIntMutIf interface {
	Store(float32, int)
	Delete(float32)
}

type OfFloat32NIntIterIf interface {
	Range(func(float32, int) bool)
}

type OfFloat32NInt map[float32]int

func (__ OfFloat32NInt) Load(k float32) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NInt) Store(k float32, v int) {
	__[k] = v
}
func (__ OfFloat32NInt) Delete(k float32, v int) {
	delete(__, k)
}
func (__ OfFloat32NInt) Range(f func(k float32, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NInt = OfFloat32NInt
type OfFloat32NIntSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NInt
}

func NewOfFloat32NIntSt(somes OfFloat32NInt) *OfFloat32NIntSt {
	return &OfFloat32NIntSt{
		_OfFloat32NInt: somes,
	}
}

type OfFloat32NInt16If interface {
	Load(float32) (int16, error)
}

type OfFloat32NInt16MutIf interface {
	Store(float32, int16)
	Delete(float32)
}

type OfFloat32NInt16IterIf interface {
	Range(func(float32, int16) bool)
}

type OfFloat32NInt16 map[float32]int16

func (__ OfFloat32NInt16) Load(k float32) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NInt16) Store(k float32, v int16) {
	__[k] = v
}
func (__ OfFloat32NInt16) Delete(k float32, v int16) {
	delete(__, k)
}
func (__ OfFloat32NInt16) Range(f func(k float32, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NInt16 = OfFloat32NInt16
type OfFloat32NInt16St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NInt16
}

func NewOfFloat32NInt16St(somes OfFloat32NInt16) *OfFloat32NInt16St {
	return &OfFloat32NInt16St{
		_OfFloat32NInt16: somes,
	}
}

type OfFloat32NInt32If interface {
	Load(float32) (int32, error)
}

type OfFloat32NInt32MutIf interface {
	Store(float32, int32)
	Delete(float32)
}

type OfFloat32NInt32IterIf interface {
	Range(func(float32, int32) bool)
}

type OfFloat32NInt32 map[float32]int32

func (__ OfFloat32NInt32) Load(k float32) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NInt32) Store(k float32, v int32) {
	__[k] = v
}
func (__ OfFloat32NInt32) Delete(k float32, v int32) {
	delete(__, k)
}
func (__ OfFloat32NInt32) Range(f func(k float32, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NInt32 = OfFloat32NInt32
type OfFloat32NInt32St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NInt32
}

func NewOfFloat32NInt32St(somes OfFloat32NInt32) *OfFloat32NInt32St {
	return &OfFloat32NInt32St{
		_OfFloat32NInt32: somes,
	}
}

type OfFloat32NInt64If interface {
	Load(float32) (int64, error)
}

type OfFloat32NInt64MutIf interface {
	Store(float32, int64)
	Delete(float32)
}

type OfFloat32NInt64IterIf interface {
	Range(func(float32, int64) bool)
}

type OfFloat32NInt64 map[float32]int64

func (__ OfFloat32NInt64) Load(k float32) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NInt64) Store(k float32, v int64) {
	__[k] = v
}
func (__ OfFloat32NInt64) Delete(k float32, v int64) {
	delete(__, k)
}
func (__ OfFloat32NInt64) Range(f func(k float32, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NInt64 = OfFloat32NInt64
type OfFloat32NInt64St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NInt64
}

func NewOfFloat32NInt64St(somes OfFloat32NInt64) *OfFloat32NInt64St {
	return &OfFloat32NInt64St{
		_OfFloat32NInt64: somes,
	}
}

type OfFloat32NInt8If interface {
	Load(float32) (int8, error)
}

type OfFloat32NInt8MutIf interface {
	Store(float32, int8)
	Delete(float32)
}

type OfFloat32NInt8IterIf interface {
	Range(func(float32, int8) bool)
}

type OfFloat32NInt8 map[float32]int8

func (__ OfFloat32NInt8) Load(k float32) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NInt8) Store(k float32, v int8) {
	__[k] = v
}
func (__ OfFloat32NInt8) Delete(k float32, v int8) {
	delete(__, k)
}
func (__ OfFloat32NInt8) Range(f func(k float32, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NInt8 = OfFloat32NInt8
type OfFloat32NInt8St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NInt8
}

func NewOfFloat32NInt8St(somes OfFloat32NInt8) *OfFloat32NInt8St {
	return &OfFloat32NInt8St{
		_OfFloat32NInt8: somes,
	}
}

type OfFloat32NRuneIf interface {
	Load(float32) (rune, error)
}

type OfFloat32NRuneMutIf interface {
	Store(float32, rune)
	Delete(float32)
}

type OfFloat32NRuneIterIf interface {
	Range(func(float32, rune) bool)
}

type OfFloat32NRune map[float32]rune

func (__ OfFloat32NRune) Load(k float32) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NRune) Store(k float32, v rune) {
	__[k] = v
}
func (__ OfFloat32NRune) Delete(k float32, v rune) {
	delete(__, k)
}
func (__ OfFloat32NRune) Range(f func(k float32, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NRune = OfFloat32NRune
type OfFloat32NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NRune
}

func NewOfFloat32NRuneSt(somes OfFloat32NRune) *OfFloat32NRuneSt {
	return &OfFloat32NRuneSt{
		_OfFloat32NRune: somes,
	}
}

type OfFloat32NStringIf interface {
	Load(float32) (string, error)
}

type OfFloat32NStringMutIf interface {
	Store(float32, string)
	Delete(float32)
}

type OfFloat32NStringIterIf interface {
	Range(func(float32, string) bool)
}

type OfFloat32NString map[float32]string

func (__ OfFloat32NString) Load(k float32) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NString) Store(k float32, v string) {
	__[k] = v
}
func (__ OfFloat32NString) Delete(k float32, v string) {
	delete(__, k)
}
func (__ OfFloat32NString) Range(f func(k float32, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NString = OfFloat32NString
type OfFloat32NStringSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NString
}

func NewOfFloat32NStringSt(somes OfFloat32NString) *OfFloat32NStringSt {
	return &OfFloat32NStringSt{
		_OfFloat32NString: somes,
	}
}

type OfFloat32NUintIf interface {
	Load(float32) (uint, error)
}

type OfFloat32NUintMutIf interface {
	Store(float32, uint)
	Delete(float32)
}

type OfFloat32NUintIterIf interface {
	Range(func(float32, uint) bool)
}

type OfFloat32NUint map[float32]uint

func (__ OfFloat32NUint) Load(k float32) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NUint) Store(k float32, v uint) {
	__[k] = v
}
func (__ OfFloat32NUint) Delete(k float32, v uint) {
	delete(__, k)
}
func (__ OfFloat32NUint) Range(f func(k float32, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NUint = OfFloat32NUint
type OfFloat32NUintSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NUint
}

func NewOfFloat32NUintSt(somes OfFloat32NUint) *OfFloat32NUintSt {
	return &OfFloat32NUintSt{
		_OfFloat32NUint: somes,
	}
}

type OfFloat32NUint16If interface {
	Load(float32) (uint16, error)
}

type OfFloat32NUint16MutIf interface {
	Store(float32, uint16)
	Delete(float32)
}

type OfFloat32NUint16IterIf interface {
	Range(func(float32, uint16) bool)
}

type OfFloat32NUint16 map[float32]uint16

func (__ OfFloat32NUint16) Load(k float32) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NUint16) Store(k float32, v uint16) {
	__[k] = v
}
func (__ OfFloat32NUint16) Delete(k float32, v uint16) {
	delete(__, k)
}
func (__ OfFloat32NUint16) Range(f func(k float32, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NUint16 = OfFloat32NUint16
type OfFloat32NUint16St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NUint16
}

func NewOfFloat32NUint16St(somes OfFloat32NUint16) *OfFloat32NUint16St {
	return &OfFloat32NUint16St{
		_OfFloat32NUint16: somes,
	}
}

type OfFloat32NUint32If interface {
	Load(float32) (uint32, error)
}

type OfFloat32NUint32MutIf interface {
	Store(float32, uint32)
	Delete(float32)
}

type OfFloat32NUint32IterIf interface {
	Range(func(float32, uint32) bool)
}

type OfFloat32NUint32 map[float32]uint32

func (__ OfFloat32NUint32) Load(k float32) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NUint32) Store(k float32, v uint32) {
	__[k] = v
}
func (__ OfFloat32NUint32) Delete(k float32, v uint32) {
	delete(__, k)
}
func (__ OfFloat32NUint32) Range(f func(k float32, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NUint32 = OfFloat32NUint32
type OfFloat32NUint32St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NUint32
}

func NewOfFloat32NUint32St(somes OfFloat32NUint32) *OfFloat32NUint32St {
	return &OfFloat32NUint32St{
		_OfFloat32NUint32: somes,
	}
}

type OfFloat32NUint64If interface {
	Load(float32) (uint64, error)
}

type OfFloat32NUint64MutIf interface {
	Store(float32, uint64)
	Delete(float32)
}

type OfFloat32NUint64IterIf interface {
	Range(func(float32, uint64) bool)
}

type OfFloat32NUint64 map[float32]uint64

func (__ OfFloat32NUint64) Load(k float32) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NUint64) Store(k float32, v uint64) {
	__[k] = v
}
func (__ OfFloat32NUint64) Delete(k float32, v uint64) {
	delete(__, k)
}
func (__ OfFloat32NUint64) Range(f func(k float32, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NUint64 = OfFloat32NUint64
type OfFloat32NUint64St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NUint64
}

func NewOfFloat32NUint64St(somes OfFloat32NUint64) *OfFloat32NUint64St {
	return &OfFloat32NUint64St{
		_OfFloat32NUint64: somes,
	}
}

type OfFloat32NUint8If interface {
	Load(float32) (uint8, error)
}

type OfFloat32NUint8MutIf interface {
	Store(float32, uint8)
	Delete(float32)
}

type OfFloat32NUint8IterIf interface {
	Range(func(float32, uint8) bool)
}

type OfFloat32NUint8 map[float32]uint8

func (__ OfFloat32NUint8) Load(k float32) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NUint8) Store(k float32, v uint8) {
	__[k] = v
}
func (__ OfFloat32NUint8) Delete(k float32, v uint8) {
	delete(__, k)
}
func (__ OfFloat32NUint8) Range(f func(k float32, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NUint8 = OfFloat32NUint8
type OfFloat32NUint8St struct {
	// do not want to export but want to use embedding method
	_OfFloat32NUint8
}

func NewOfFloat32NUint8St(somes OfFloat32NUint8) *OfFloat32NUint8St {
	return &OfFloat32NUint8St{
		_OfFloat32NUint8: somes,
	}
}

type OfFloat32NUintptrIf interface {
	Load(float32) (uintptr, error)
}

type OfFloat32NUintptrMutIf interface {
	Store(float32, uintptr)
	Delete(float32)
}

type OfFloat32NUintptrIterIf interface {
	Range(func(float32, uintptr) bool)
}

type OfFloat32NUintptr map[float32]uintptr

func (__ OfFloat32NUintptr) Load(k float32) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NUintptr) Store(k float32, v uintptr) {
	__[k] = v
}
func (__ OfFloat32NUintptr) Delete(k float32, v uintptr) {
	delete(__, k)
}
func (__ OfFloat32NUintptr) Range(f func(k float32, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NUintptr = OfFloat32NUintptr
type OfFloat32NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NUintptr
}

func NewOfFloat32NUintptrSt(somes OfFloat32NUintptr) *OfFloat32NUintptrSt {
	return &OfFloat32NUintptrSt{
		_OfFloat32NUintptr: somes,
	}
}

type OfFloat32NInterfaceIf interface {
	Load(float32) (interface{}, error)
}

type OfFloat32NInterfaceMutIf interface {
	Store(float32, interface{})
	Delete(float32)
}

type OfFloat32NInterfaceIterIf interface {
	Range(func(float32, interface{}) bool)
}

type OfFloat32NInterface map[float32]interface{}

func (__ OfFloat32NInterface) Load(k float32) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat32NInterface) Store(k float32, v interface{}) {
	__[k] = v
}
func (__ OfFloat32NInterface) Delete(k float32, v interface{}) {
	delete(__, k)
}
func (__ OfFloat32NInterface) Range(f func(k float32, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat32NInterface = OfFloat32NInterface
type OfFloat32NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfFloat32NInterface
}

func NewOfFloat32NInterfaceSt(somes OfFloat32NInterface) *OfFloat32NInterfaceSt {
	return &OfFloat32NInterfaceSt{
		_OfFloat32NInterface: somes,
	}
}

type OfFloat64NBoolIf interface {
	Load(float64) (bool, error)
}

type OfFloat64NBoolMutIf interface {
	Store(float64, bool)
	Delete(float64)
}

type OfFloat64NBoolIterIf interface {
	Range(func(float64, bool) bool)
}

type OfFloat64NBool map[float64]bool

func (__ OfFloat64NBool) Load(k float64) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NBool) Store(k float64, v bool) {
	__[k] = v
}
func (__ OfFloat64NBool) Delete(k float64, v bool) {
	delete(__, k)
}
func (__ OfFloat64NBool) Range(f func(k float64, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NBool = OfFloat64NBool
type OfFloat64NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NBool
}

func NewOfFloat64NBoolSt(somes OfFloat64NBool) *OfFloat64NBoolSt {
	return &OfFloat64NBoolSt{
		_OfFloat64NBool: somes,
	}
}

type OfFloat64NByteIf interface {
	Load(float64) (byte, error)
}

type OfFloat64NByteMutIf interface {
	Store(float64, byte)
	Delete(float64)
}

type OfFloat64NByteIterIf interface {
	Range(func(float64, byte) bool)
}

type OfFloat64NByte map[float64]byte

func (__ OfFloat64NByte) Load(k float64) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NByte) Store(k float64, v byte) {
	__[k] = v
}
func (__ OfFloat64NByte) Delete(k float64, v byte) {
	delete(__, k)
}
func (__ OfFloat64NByte) Range(f func(k float64, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NByte = OfFloat64NByte
type OfFloat64NByteSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NByte
}

func NewOfFloat64NByteSt(somes OfFloat64NByte) *OfFloat64NByteSt {
	return &OfFloat64NByteSt{
		_OfFloat64NByte: somes,
	}
}

type OfFloat64NComplex128If interface {
	Load(float64) (complex128, error)
}

type OfFloat64NComplex128MutIf interface {
	Store(float64, complex128)
	Delete(float64)
}

type OfFloat64NComplex128IterIf interface {
	Range(func(float64, complex128) bool)
}

type OfFloat64NComplex128 map[float64]complex128

func (__ OfFloat64NComplex128) Load(k float64) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NComplex128) Store(k float64, v complex128) {
	__[k] = v
}
func (__ OfFloat64NComplex128) Delete(k float64, v complex128) {
	delete(__, k)
}
func (__ OfFloat64NComplex128) Range(f func(k float64, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NComplex128 = OfFloat64NComplex128
type OfFloat64NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NComplex128
}

func NewOfFloat64NComplex128St(somes OfFloat64NComplex128) *OfFloat64NComplex128St {
	return &OfFloat64NComplex128St{
		_OfFloat64NComplex128: somes,
	}
}

type OfFloat64NComplex64If interface {
	Load(float64) (complex64, error)
}

type OfFloat64NComplex64MutIf interface {
	Store(float64, complex64)
	Delete(float64)
}

type OfFloat64NComplex64IterIf interface {
	Range(func(float64, complex64) bool)
}

type OfFloat64NComplex64 map[float64]complex64

func (__ OfFloat64NComplex64) Load(k float64) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NComplex64) Store(k float64, v complex64) {
	__[k] = v
}
func (__ OfFloat64NComplex64) Delete(k float64, v complex64) {
	delete(__, k)
}
func (__ OfFloat64NComplex64) Range(f func(k float64, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NComplex64 = OfFloat64NComplex64
type OfFloat64NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NComplex64
}

func NewOfFloat64NComplex64St(somes OfFloat64NComplex64) *OfFloat64NComplex64St {
	return &OfFloat64NComplex64St{
		_OfFloat64NComplex64: somes,
	}
}

type OfFloat64NErrorIf interface {
	Load(float64) (error, error)
}

type OfFloat64NErrorMutIf interface {
	Store(float64, error)
	Delete(float64)
}

type OfFloat64NErrorIterIf interface {
	Range(func(float64, error) bool)
}

type OfFloat64NError map[float64]error

func (__ OfFloat64NError) Load(k float64) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NError) Store(k float64, v error) {
	__[k] = v
}
func (__ OfFloat64NError) Delete(k float64, v error) {
	delete(__, k)
}
func (__ OfFloat64NError) Range(f func(k float64, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NError = OfFloat64NError
type OfFloat64NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NError
}

func NewOfFloat64NErrorSt(somes OfFloat64NError) *OfFloat64NErrorSt {
	return &OfFloat64NErrorSt{
		_OfFloat64NError: somes,
	}
}

type OfFloat64NFloat32If interface {
	Load(float64) (float32, error)
}

type OfFloat64NFloat32MutIf interface {
	Store(float64, float32)
	Delete(float64)
}

type OfFloat64NFloat32IterIf interface {
	Range(func(float64, float32) bool)
}

type OfFloat64NFloat32 map[float64]float32

func (__ OfFloat64NFloat32) Load(k float64) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NFloat32) Store(k float64, v float32) {
	__[k] = v
}
func (__ OfFloat64NFloat32) Delete(k float64, v float32) {
	delete(__, k)
}
func (__ OfFloat64NFloat32) Range(f func(k float64, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NFloat32 = OfFloat64NFloat32
type OfFloat64NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NFloat32
}

func NewOfFloat64NFloat32St(somes OfFloat64NFloat32) *OfFloat64NFloat32St {
	return &OfFloat64NFloat32St{
		_OfFloat64NFloat32: somes,
	}
}

type OfFloat64NFloat64If interface {
	Load(float64) (float64, error)
}

type OfFloat64NFloat64MutIf interface {
	Store(float64, float64)
	Delete(float64)
}

type OfFloat64NFloat64IterIf interface {
	Range(func(float64, float64) bool)
}

type OfFloat64NFloat64 map[float64]float64

func (__ OfFloat64NFloat64) Load(k float64) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NFloat64) Store(k float64, v float64) {
	__[k] = v
}
func (__ OfFloat64NFloat64) Delete(k float64, v float64) {
	delete(__, k)
}
func (__ OfFloat64NFloat64) Range(f func(k float64, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NFloat64 = OfFloat64NFloat64
type OfFloat64NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NFloat64
}

func NewOfFloat64NFloat64St(somes OfFloat64NFloat64) *OfFloat64NFloat64St {
	return &OfFloat64NFloat64St{
		_OfFloat64NFloat64: somes,
	}
}

type OfFloat64NIntIf interface {
	Load(float64) (int, error)
}

type OfFloat64NIntMutIf interface {
	Store(float64, int)
	Delete(float64)
}

type OfFloat64NIntIterIf interface {
	Range(func(float64, int) bool)
}

type OfFloat64NInt map[float64]int

func (__ OfFloat64NInt) Load(k float64) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NInt) Store(k float64, v int) {
	__[k] = v
}
func (__ OfFloat64NInt) Delete(k float64, v int) {
	delete(__, k)
}
func (__ OfFloat64NInt) Range(f func(k float64, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NInt = OfFloat64NInt
type OfFloat64NIntSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NInt
}

func NewOfFloat64NIntSt(somes OfFloat64NInt) *OfFloat64NIntSt {
	return &OfFloat64NIntSt{
		_OfFloat64NInt: somes,
	}
}

type OfFloat64NInt16If interface {
	Load(float64) (int16, error)
}

type OfFloat64NInt16MutIf interface {
	Store(float64, int16)
	Delete(float64)
}

type OfFloat64NInt16IterIf interface {
	Range(func(float64, int16) bool)
}

type OfFloat64NInt16 map[float64]int16

func (__ OfFloat64NInt16) Load(k float64) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NInt16) Store(k float64, v int16) {
	__[k] = v
}
func (__ OfFloat64NInt16) Delete(k float64, v int16) {
	delete(__, k)
}
func (__ OfFloat64NInt16) Range(f func(k float64, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NInt16 = OfFloat64NInt16
type OfFloat64NInt16St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NInt16
}

func NewOfFloat64NInt16St(somes OfFloat64NInt16) *OfFloat64NInt16St {
	return &OfFloat64NInt16St{
		_OfFloat64NInt16: somes,
	}
}

type OfFloat64NInt32If interface {
	Load(float64) (int32, error)
}

type OfFloat64NInt32MutIf interface {
	Store(float64, int32)
	Delete(float64)
}

type OfFloat64NInt32IterIf interface {
	Range(func(float64, int32) bool)
}

type OfFloat64NInt32 map[float64]int32

func (__ OfFloat64NInt32) Load(k float64) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NInt32) Store(k float64, v int32) {
	__[k] = v
}
func (__ OfFloat64NInt32) Delete(k float64, v int32) {
	delete(__, k)
}
func (__ OfFloat64NInt32) Range(f func(k float64, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NInt32 = OfFloat64NInt32
type OfFloat64NInt32St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NInt32
}

func NewOfFloat64NInt32St(somes OfFloat64NInt32) *OfFloat64NInt32St {
	return &OfFloat64NInt32St{
		_OfFloat64NInt32: somes,
	}
}

type OfFloat64NInt64If interface {
	Load(float64) (int64, error)
}

type OfFloat64NInt64MutIf interface {
	Store(float64, int64)
	Delete(float64)
}

type OfFloat64NInt64IterIf interface {
	Range(func(float64, int64) bool)
}

type OfFloat64NInt64 map[float64]int64

func (__ OfFloat64NInt64) Load(k float64) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NInt64) Store(k float64, v int64) {
	__[k] = v
}
func (__ OfFloat64NInt64) Delete(k float64, v int64) {
	delete(__, k)
}
func (__ OfFloat64NInt64) Range(f func(k float64, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NInt64 = OfFloat64NInt64
type OfFloat64NInt64St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NInt64
}

func NewOfFloat64NInt64St(somes OfFloat64NInt64) *OfFloat64NInt64St {
	return &OfFloat64NInt64St{
		_OfFloat64NInt64: somes,
	}
}

type OfFloat64NInt8If interface {
	Load(float64) (int8, error)
}

type OfFloat64NInt8MutIf interface {
	Store(float64, int8)
	Delete(float64)
}

type OfFloat64NInt8IterIf interface {
	Range(func(float64, int8) bool)
}

type OfFloat64NInt8 map[float64]int8

func (__ OfFloat64NInt8) Load(k float64) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NInt8) Store(k float64, v int8) {
	__[k] = v
}
func (__ OfFloat64NInt8) Delete(k float64, v int8) {
	delete(__, k)
}
func (__ OfFloat64NInt8) Range(f func(k float64, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NInt8 = OfFloat64NInt8
type OfFloat64NInt8St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NInt8
}

func NewOfFloat64NInt8St(somes OfFloat64NInt8) *OfFloat64NInt8St {
	return &OfFloat64NInt8St{
		_OfFloat64NInt8: somes,
	}
}

type OfFloat64NRuneIf interface {
	Load(float64) (rune, error)
}

type OfFloat64NRuneMutIf interface {
	Store(float64, rune)
	Delete(float64)
}

type OfFloat64NRuneIterIf interface {
	Range(func(float64, rune) bool)
}

type OfFloat64NRune map[float64]rune

func (__ OfFloat64NRune) Load(k float64) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NRune) Store(k float64, v rune) {
	__[k] = v
}
func (__ OfFloat64NRune) Delete(k float64, v rune) {
	delete(__, k)
}
func (__ OfFloat64NRune) Range(f func(k float64, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NRune = OfFloat64NRune
type OfFloat64NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NRune
}

func NewOfFloat64NRuneSt(somes OfFloat64NRune) *OfFloat64NRuneSt {
	return &OfFloat64NRuneSt{
		_OfFloat64NRune: somes,
	}
}

type OfFloat64NStringIf interface {
	Load(float64) (string, error)
}

type OfFloat64NStringMutIf interface {
	Store(float64, string)
	Delete(float64)
}

type OfFloat64NStringIterIf interface {
	Range(func(float64, string) bool)
}

type OfFloat64NString map[float64]string

func (__ OfFloat64NString) Load(k float64) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NString) Store(k float64, v string) {
	__[k] = v
}
func (__ OfFloat64NString) Delete(k float64, v string) {
	delete(__, k)
}
func (__ OfFloat64NString) Range(f func(k float64, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NString = OfFloat64NString
type OfFloat64NStringSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NString
}

func NewOfFloat64NStringSt(somes OfFloat64NString) *OfFloat64NStringSt {
	return &OfFloat64NStringSt{
		_OfFloat64NString: somes,
	}
}

type OfFloat64NUintIf interface {
	Load(float64) (uint, error)
}

type OfFloat64NUintMutIf interface {
	Store(float64, uint)
	Delete(float64)
}

type OfFloat64NUintIterIf interface {
	Range(func(float64, uint) bool)
}

type OfFloat64NUint map[float64]uint

func (__ OfFloat64NUint) Load(k float64) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NUint) Store(k float64, v uint) {
	__[k] = v
}
func (__ OfFloat64NUint) Delete(k float64, v uint) {
	delete(__, k)
}
func (__ OfFloat64NUint) Range(f func(k float64, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NUint = OfFloat64NUint
type OfFloat64NUintSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NUint
}

func NewOfFloat64NUintSt(somes OfFloat64NUint) *OfFloat64NUintSt {
	return &OfFloat64NUintSt{
		_OfFloat64NUint: somes,
	}
}

type OfFloat64NUint16If interface {
	Load(float64) (uint16, error)
}

type OfFloat64NUint16MutIf interface {
	Store(float64, uint16)
	Delete(float64)
}

type OfFloat64NUint16IterIf interface {
	Range(func(float64, uint16) bool)
}

type OfFloat64NUint16 map[float64]uint16

func (__ OfFloat64NUint16) Load(k float64) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NUint16) Store(k float64, v uint16) {
	__[k] = v
}
func (__ OfFloat64NUint16) Delete(k float64, v uint16) {
	delete(__, k)
}
func (__ OfFloat64NUint16) Range(f func(k float64, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NUint16 = OfFloat64NUint16
type OfFloat64NUint16St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NUint16
}

func NewOfFloat64NUint16St(somes OfFloat64NUint16) *OfFloat64NUint16St {
	return &OfFloat64NUint16St{
		_OfFloat64NUint16: somes,
	}
}

type OfFloat64NUint32If interface {
	Load(float64) (uint32, error)
}

type OfFloat64NUint32MutIf interface {
	Store(float64, uint32)
	Delete(float64)
}

type OfFloat64NUint32IterIf interface {
	Range(func(float64, uint32) bool)
}

type OfFloat64NUint32 map[float64]uint32

func (__ OfFloat64NUint32) Load(k float64) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NUint32) Store(k float64, v uint32) {
	__[k] = v
}
func (__ OfFloat64NUint32) Delete(k float64, v uint32) {
	delete(__, k)
}
func (__ OfFloat64NUint32) Range(f func(k float64, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NUint32 = OfFloat64NUint32
type OfFloat64NUint32St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NUint32
}

func NewOfFloat64NUint32St(somes OfFloat64NUint32) *OfFloat64NUint32St {
	return &OfFloat64NUint32St{
		_OfFloat64NUint32: somes,
	}
}

type OfFloat64NUint64If interface {
	Load(float64) (uint64, error)
}

type OfFloat64NUint64MutIf interface {
	Store(float64, uint64)
	Delete(float64)
}

type OfFloat64NUint64IterIf interface {
	Range(func(float64, uint64) bool)
}

type OfFloat64NUint64 map[float64]uint64

func (__ OfFloat64NUint64) Load(k float64) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NUint64) Store(k float64, v uint64) {
	__[k] = v
}
func (__ OfFloat64NUint64) Delete(k float64, v uint64) {
	delete(__, k)
}
func (__ OfFloat64NUint64) Range(f func(k float64, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NUint64 = OfFloat64NUint64
type OfFloat64NUint64St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NUint64
}

func NewOfFloat64NUint64St(somes OfFloat64NUint64) *OfFloat64NUint64St {
	return &OfFloat64NUint64St{
		_OfFloat64NUint64: somes,
	}
}

type OfFloat64NUint8If interface {
	Load(float64) (uint8, error)
}

type OfFloat64NUint8MutIf interface {
	Store(float64, uint8)
	Delete(float64)
}

type OfFloat64NUint8IterIf interface {
	Range(func(float64, uint8) bool)
}

type OfFloat64NUint8 map[float64]uint8

func (__ OfFloat64NUint8) Load(k float64) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NUint8) Store(k float64, v uint8) {
	__[k] = v
}
func (__ OfFloat64NUint8) Delete(k float64, v uint8) {
	delete(__, k)
}
func (__ OfFloat64NUint8) Range(f func(k float64, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NUint8 = OfFloat64NUint8
type OfFloat64NUint8St struct {
	// do not want to export but want to use embedding method
	_OfFloat64NUint8
}

func NewOfFloat64NUint8St(somes OfFloat64NUint8) *OfFloat64NUint8St {
	return &OfFloat64NUint8St{
		_OfFloat64NUint8: somes,
	}
}

type OfFloat64NUintptrIf interface {
	Load(float64) (uintptr, error)
}

type OfFloat64NUintptrMutIf interface {
	Store(float64, uintptr)
	Delete(float64)
}

type OfFloat64NUintptrIterIf interface {
	Range(func(float64, uintptr) bool)
}

type OfFloat64NUintptr map[float64]uintptr

func (__ OfFloat64NUintptr) Load(k float64) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NUintptr) Store(k float64, v uintptr) {
	__[k] = v
}
func (__ OfFloat64NUintptr) Delete(k float64, v uintptr) {
	delete(__, k)
}
func (__ OfFloat64NUintptr) Range(f func(k float64, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NUintptr = OfFloat64NUintptr
type OfFloat64NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NUintptr
}

func NewOfFloat64NUintptrSt(somes OfFloat64NUintptr) *OfFloat64NUintptrSt {
	return &OfFloat64NUintptrSt{
		_OfFloat64NUintptr: somes,
	}
}

type OfFloat64NInterfaceIf interface {
	Load(float64) (interface{}, error)
}

type OfFloat64NInterfaceMutIf interface {
	Store(float64, interface{})
	Delete(float64)
}

type OfFloat64NInterfaceIterIf interface {
	Range(func(float64, interface{}) bool)
}

type OfFloat64NInterface map[float64]interface{}

func (__ OfFloat64NInterface) Load(k float64) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfFloat64NInterface) Store(k float64, v interface{}) {
	__[k] = v
}
func (__ OfFloat64NInterface) Delete(k float64, v interface{}) {
	delete(__, k)
}
func (__ OfFloat64NInterface) Range(f func(k float64, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfFloat64NInterface = OfFloat64NInterface
type OfFloat64NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfFloat64NInterface
}

func NewOfFloat64NInterfaceSt(somes OfFloat64NInterface) *OfFloat64NInterfaceSt {
	return &OfFloat64NInterfaceSt{
		_OfFloat64NInterface: somes,
	}
}

type OfIntNBoolIf interface {
	Load(int) (bool, error)
}

type OfIntNBoolMutIf interface {
	Store(int, bool)
	Delete(int)
}

type OfIntNBoolIterIf interface {
	Range(func(int, bool) bool)
}

type OfIntNBool map[int]bool

func (__ OfIntNBool) Load(k int) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNBool) Store(k int, v bool) {
	__[k] = v
}
func (__ OfIntNBool) Delete(k int, v bool) {
	delete(__, k)
}
func (__ OfIntNBool) Range(f func(k int, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNBool = OfIntNBool
type OfIntNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfIntNBool
}

func NewOfIntNBoolSt(somes OfIntNBool) *OfIntNBoolSt {
	return &OfIntNBoolSt{
		_OfIntNBool: somes,
	}
}

type OfIntNByteIf interface {
	Load(int) (byte, error)
}

type OfIntNByteMutIf interface {
	Store(int, byte)
	Delete(int)
}

type OfIntNByteIterIf interface {
	Range(func(int, byte) bool)
}

type OfIntNByte map[int]byte

func (__ OfIntNByte) Load(k int) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNByte) Store(k int, v byte) {
	__[k] = v
}
func (__ OfIntNByte) Delete(k int, v byte) {
	delete(__, k)
}
func (__ OfIntNByte) Range(f func(k int, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNByte = OfIntNByte
type OfIntNByteSt struct {
	// do not want to export but want to use embedding method
	_OfIntNByte
}

func NewOfIntNByteSt(somes OfIntNByte) *OfIntNByteSt {
	return &OfIntNByteSt{
		_OfIntNByte: somes,
	}
}

type OfIntNComplex128If interface {
	Load(int) (complex128, error)
}

type OfIntNComplex128MutIf interface {
	Store(int, complex128)
	Delete(int)
}

type OfIntNComplex128IterIf interface {
	Range(func(int, complex128) bool)
}

type OfIntNComplex128 map[int]complex128

func (__ OfIntNComplex128) Load(k int) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNComplex128) Store(k int, v complex128) {
	__[k] = v
}
func (__ OfIntNComplex128) Delete(k int, v complex128) {
	delete(__, k)
}
func (__ OfIntNComplex128) Range(f func(k int, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNComplex128 = OfIntNComplex128
type OfIntNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfIntNComplex128
}

func NewOfIntNComplex128St(somes OfIntNComplex128) *OfIntNComplex128St {
	return &OfIntNComplex128St{
		_OfIntNComplex128: somes,
	}
}

type OfIntNComplex64If interface {
	Load(int) (complex64, error)
}

type OfIntNComplex64MutIf interface {
	Store(int, complex64)
	Delete(int)
}

type OfIntNComplex64IterIf interface {
	Range(func(int, complex64) bool)
}

type OfIntNComplex64 map[int]complex64

func (__ OfIntNComplex64) Load(k int) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNComplex64) Store(k int, v complex64) {
	__[k] = v
}
func (__ OfIntNComplex64) Delete(k int, v complex64) {
	delete(__, k)
}
func (__ OfIntNComplex64) Range(f func(k int, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNComplex64 = OfIntNComplex64
type OfIntNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfIntNComplex64
}

func NewOfIntNComplex64St(somes OfIntNComplex64) *OfIntNComplex64St {
	return &OfIntNComplex64St{
		_OfIntNComplex64: somes,
	}
}

type OfIntNErrorIf interface {
	Load(int) (error, error)
}

type OfIntNErrorMutIf interface {
	Store(int, error)
	Delete(int)
}

type OfIntNErrorIterIf interface {
	Range(func(int, error) bool)
}

type OfIntNError map[int]error

func (__ OfIntNError) Load(k int) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNError) Store(k int, v error) {
	__[k] = v
}
func (__ OfIntNError) Delete(k int, v error) {
	delete(__, k)
}
func (__ OfIntNError) Range(f func(k int, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNError = OfIntNError
type OfIntNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfIntNError
}

func NewOfIntNErrorSt(somes OfIntNError) *OfIntNErrorSt {
	return &OfIntNErrorSt{
		_OfIntNError: somes,
	}
}

type OfIntNFloat32If interface {
	Load(int) (float32, error)
}

type OfIntNFloat32MutIf interface {
	Store(int, float32)
	Delete(int)
}

type OfIntNFloat32IterIf interface {
	Range(func(int, float32) bool)
}

type OfIntNFloat32 map[int]float32

func (__ OfIntNFloat32) Load(k int) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNFloat32) Store(k int, v float32) {
	__[k] = v
}
func (__ OfIntNFloat32) Delete(k int, v float32) {
	delete(__, k)
}
func (__ OfIntNFloat32) Range(f func(k int, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNFloat32 = OfIntNFloat32
type OfIntNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfIntNFloat32
}

func NewOfIntNFloat32St(somes OfIntNFloat32) *OfIntNFloat32St {
	return &OfIntNFloat32St{
		_OfIntNFloat32: somes,
	}
}

type OfIntNFloat64If interface {
	Load(int) (float64, error)
}

type OfIntNFloat64MutIf interface {
	Store(int, float64)
	Delete(int)
}

type OfIntNFloat64IterIf interface {
	Range(func(int, float64) bool)
}

type OfIntNFloat64 map[int]float64

func (__ OfIntNFloat64) Load(k int) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNFloat64) Store(k int, v float64) {
	__[k] = v
}
func (__ OfIntNFloat64) Delete(k int, v float64) {
	delete(__, k)
}
func (__ OfIntNFloat64) Range(f func(k int, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNFloat64 = OfIntNFloat64
type OfIntNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfIntNFloat64
}

func NewOfIntNFloat64St(somes OfIntNFloat64) *OfIntNFloat64St {
	return &OfIntNFloat64St{
		_OfIntNFloat64: somes,
	}
}

type OfIntNIntIf interface {
	Load(int) (int, error)
}

type OfIntNIntMutIf interface {
	Store(int, int)
	Delete(int)
}

type OfIntNIntIterIf interface {
	Range(func(int, int) bool)
}

type OfIntNInt map[int]int

func (__ OfIntNInt) Load(k int) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNInt) Store(k int, v int) {
	__[k] = v
}
func (__ OfIntNInt) Delete(k int, v int) {
	delete(__, k)
}
func (__ OfIntNInt) Range(f func(k int, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNInt = OfIntNInt
type OfIntNIntSt struct {
	// do not want to export but want to use embedding method
	_OfIntNInt
}

func NewOfIntNIntSt(somes OfIntNInt) *OfIntNIntSt {
	return &OfIntNIntSt{
		_OfIntNInt: somes,
	}
}

type OfIntNInt16If interface {
	Load(int) (int16, error)
}

type OfIntNInt16MutIf interface {
	Store(int, int16)
	Delete(int)
}

type OfIntNInt16IterIf interface {
	Range(func(int, int16) bool)
}

type OfIntNInt16 map[int]int16

func (__ OfIntNInt16) Load(k int) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNInt16) Store(k int, v int16) {
	__[k] = v
}
func (__ OfIntNInt16) Delete(k int, v int16) {
	delete(__, k)
}
func (__ OfIntNInt16) Range(f func(k int, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNInt16 = OfIntNInt16
type OfIntNInt16St struct {
	// do not want to export but want to use embedding method
	_OfIntNInt16
}

func NewOfIntNInt16St(somes OfIntNInt16) *OfIntNInt16St {
	return &OfIntNInt16St{
		_OfIntNInt16: somes,
	}
}

type OfIntNInt32If interface {
	Load(int) (int32, error)
}

type OfIntNInt32MutIf interface {
	Store(int, int32)
	Delete(int)
}

type OfIntNInt32IterIf interface {
	Range(func(int, int32) bool)
}

type OfIntNInt32 map[int]int32

func (__ OfIntNInt32) Load(k int) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNInt32) Store(k int, v int32) {
	__[k] = v
}
func (__ OfIntNInt32) Delete(k int, v int32) {
	delete(__, k)
}
func (__ OfIntNInt32) Range(f func(k int, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNInt32 = OfIntNInt32
type OfIntNInt32St struct {
	// do not want to export but want to use embedding method
	_OfIntNInt32
}

func NewOfIntNInt32St(somes OfIntNInt32) *OfIntNInt32St {
	return &OfIntNInt32St{
		_OfIntNInt32: somes,
	}
}

type OfIntNInt64If interface {
	Load(int) (int64, error)
}

type OfIntNInt64MutIf interface {
	Store(int, int64)
	Delete(int)
}

type OfIntNInt64IterIf interface {
	Range(func(int, int64) bool)
}

type OfIntNInt64 map[int]int64

func (__ OfIntNInt64) Load(k int) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNInt64) Store(k int, v int64) {
	__[k] = v
}
func (__ OfIntNInt64) Delete(k int, v int64) {
	delete(__, k)
}
func (__ OfIntNInt64) Range(f func(k int, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNInt64 = OfIntNInt64
type OfIntNInt64St struct {
	// do not want to export but want to use embedding method
	_OfIntNInt64
}

func NewOfIntNInt64St(somes OfIntNInt64) *OfIntNInt64St {
	return &OfIntNInt64St{
		_OfIntNInt64: somes,
	}
}

type OfIntNInt8If interface {
	Load(int) (int8, error)
}

type OfIntNInt8MutIf interface {
	Store(int, int8)
	Delete(int)
}

type OfIntNInt8IterIf interface {
	Range(func(int, int8) bool)
}

type OfIntNInt8 map[int]int8

func (__ OfIntNInt8) Load(k int) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNInt8) Store(k int, v int8) {
	__[k] = v
}
func (__ OfIntNInt8) Delete(k int, v int8) {
	delete(__, k)
}
func (__ OfIntNInt8) Range(f func(k int, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNInt8 = OfIntNInt8
type OfIntNInt8St struct {
	// do not want to export but want to use embedding method
	_OfIntNInt8
}

func NewOfIntNInt8St(somes OfIntNInt8) *OfIntNInt8St {
	return &OfIntNInt8St{
		_OfIntNInt8: somes,
	}
}

type OfIntNRuneIf interface {
	Load(int) (rune, error)
}

type OfIntNRuneMutIf interface {
	Store(int, rune)
	Delete(int)
}

type OfIntNRuneIterIf interface {
	Range(func(int, rune) bool)
}

type OfIntNRune map[int]rune

func (__ OfIntNRune) Load(k int) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNRune) Store(k int, v rune) {
	__[k] = v
}
func (__ OfIntNRune) Delete(k int, v rune) {
	delete(__, k)
}
func (__ OfIntNRune) Range(f func(k int, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNRune = OfIntNRune
type OfIntNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfIntNRune
}

func NewOfIntNRuneSt(somes OfIntNRune) *OfIntNRuneSt {
	return &OfIntNRuneSt{
		_OfIntNRune: somes,
	}
}

type OfIntNStringIf interface {
	Load(int) (string, error)
}

type OfIntNStringMutIf interface {
	Store(int, string)
	Delete(int)
}

type OfIntNStringIterIf interface {
	Range(func(int, string) bool)
}

type OfIntNString map[int]string

func (__ OfIntNString) Load(k int) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNString) Store(k int, v string) {
	__[k] = v
}
func (__ OfIntNString) Delete(k int, v string) {
	delete(__, k)
}
func (__ OfIntNString) Range(f func(k int, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNString = OfIntNString
type OfIntNStringSt struct {
	// do not want to export but want to use embedding method
	_OfIntNString
}

func NewOfIntNStringSt(somes OfIntNString) *OfIntNStringSt {
	return &OfIntNStringSt{
		_OfIntNString: somes,
	}
}

type OfIntNUintIf interface {
	Load(int) (uint, error)
}

type OfIntNUintMutIf interface {
	Store(int, uint)
	Delete(int)
}

type OfIntNUintIterIf interface {
	Range(func(int, uint) bool)
}

type OfIntNUint map[int]uint

func (__ OfIntNUint) Load(k int) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNUint) Store(k int, v uint) {
	__[k] = v
}
func (__ OfIntNUint) Delete(k int, v uint) {
	delete(__, k)
}
func (__ OfIntNUint) Range(f func(k int, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNUint = OfIntNUint
type OfIntNUintSt struct {
	// do not want to export but want to use embedding method
	_OfIntNUint
}

func NewOfIntNUintSt(somes OfIntNUint) *OfIntNUintSt {
	return &OfIntNUintSt{
		_OfIntNUint: somes,
	}
}

type OfIntNUint16If interface {
	Load(int) (uint16, error)
}

type OfIntNUint16MutIf interface {
	Store(int, uint16)
	Delete(int)
}

type OfIntNUint16IterIf interface {
	Range(func(int, uint16) bool)
}

type OfIntNUint16 map[int]uint16

func (__ OfIntNUint16) Load(k int) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNUint16) Store(k int, v uint16) {
	__[k] = v
}
func (__ OfIntNUint16) Delete(k int, v uint16) {
	delete(__, k)
}
func (__ OfIntNUint16) Range(f func(k int, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNUint16 = OfIntNUint16
type OfIntNUint16St struct {
	// do not want to export but want to use embedding method
	_OfIntNUint16
}

func NewOfIntNUint16St(somes OfIntNUint16) *OfIntNUint16St {
	return &OfIntNUint16St{
		_OfIntNUint16: somes,
	}
}

type OfIntNUint32If interface {
	Load(int) (uint32, error)
}

type OfIntNUint32MutIf interface {
	Store(int, uint32)
	Delete(int)
}

type OfIntNUint32IterIf interface {
	Range(func(int, uint32) bool)
}

type OfIntNUint32 map[int]uint32

func (__ OfIntNUint32) Load(k int) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNUint32) Store(k int, v uint32) {
	__[k] = v
}
func (__ OfIntNUint32) Delete(k int, v uint32) {
	delete(__, k)
}
func (__ OfIntNUint32) Range(f func(k int, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNUint32 = OfIntNUint32
type OfIntNUint32St struct {
	// do not want to export but want to use embedding method
	_OfIntNUint32
}

func NewOfIntNUint32St(somes OfIntNUint32) *OfIntNUint32St {
	return &OfIntNUint32St{
		_OfIntNUint32: somes,
	}
}

type OfIntNUint64If interface {
	Load(int) (uint64, error)
}

type OfIntNUint64MutIf interface {
	Store(int, uint64)
	Delete(int)
}

type OfIntNUint64IterIf interface {
	Range(func(int, uint64) bool)
}

type OfIntNUint64 map[int]uint64

func (__ OfIntNUint64) Load(k int) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNUint64) Store(k int, v uint64) {
	__[k] = v
}
func (__ OfIntNUint64) Delete(k int, v uint64) {
	delete(__, k)
}
func (__ OfIntNUint64) Range(f func(k int, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNUint64 = OfIntNUint64
type OfIntNUint64St struct {
	// do not want to export but want to use embedding method
	_OfIntNUint64
}

func NewOfIntNUint64St(somes OfIntNUint64) *OfIntNUint64St {
	return &OfIntNUint64St{
		_OfIntNUint64: somes,
	}
}

type OfIntNUint8If interface {
	Load(int) (uint8, error)
}

type OfIntNUint8MutIf interface {
	Store(int, uint8)
	Delete(int)
}

type OfIntNUint8IterIf interface {
	Range(func(int, uint8) bool)
}

type OfIntNUint8 map[int]uint8

func (__ OfIntNUint8) Load(k int) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNUint8) Store(k int, v uint8) {
	__[k] = v
}
func (__ OfIntNUint8) Delete(k int, v uint8) {
	delete(__, k)
}
func (__ OfIntNUint8) Range(f func(k int, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNUint8 = OfIntNUint8
type OfIntNUint8St struct {
	// do not want to export but want to use embedding method
	_OfIntNUint8
}

func NewOfIntNUint8St(somes OfIntNUint8) *OfIntNUint8St {
	return &OfIntNUint8St{
		_OfIntNUint8: somes,
	}
}

type OfIntNUintptrIf interface {
	Load(int) (uintptr, error)
}

type OfIntNUintptrMutIf interface {
	Store(int, uintptr)
	Delete(int)
}

type OfIntNUintptrIterIf interface {
	Range(func(int, uintptr) bool)
}

type OfIntNUintptr map[int]uintptr

func (__ OfIntNUintptr) Load(k int) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNUintptr) Store(k int, v uintptr) {
	__[k] = v
}
func (__ OfIntNUintptr) Delete(k int, v uintptr) {
	delete(__, k)
}
func (__ OfIntNUintptr) Range(f func(k int, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNUintptr = OfIntNUintptr
type OfIntNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfIntNUintptr
}

func NewOfIntNUintptrSt(somes OfIntNUintptr) *OfIntNUintptrSt {
	return &OfIntNUintptrSt{
		_OfIntNUintptr: somes,
	}
}

type OfIntNInterfaceIf interface {
	Load(int) (interface{}, error)
}

type OfIntNInterfaceMutIf interface {
	Store(int, interface{})
	Delete(int)
}

type OfIntNInterfaceIterIf interface {
	Range(func(int, interface{}) bool)
}

type OfIntNInterface map[int]interface{}

func (__ OfIntNInterface) Load(k int) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfIntNInterface) Store(k int, v interface{}) {
	__[k] = v
}
func (__ OfIntNInterface) Delete(k int, v interface{}) {
	delete(__, k)
}
func (__ OfIntNInterface) Range(f func(k int, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfIntNInterface = OfIntNInterface
type OfIntNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfIntNInterface
}

func NewOfIntNInterfaceSt(somes OfIntNInterface) *OfIntNInterfaceSt {
	return &OfIntNInterfaceSt{
		_OfIntNInterface: somes,
	}
}

type OfInt16NBoolIf interface {
	Load(int16) (bool, error)
}

type OfInt16NBoolMutIf interface {
	Store(int16, bool)
	Delete(int16)
}

type OfInt16NBoolIterIf interface {
	Range(func(int16, bool) bool)
}

type OfInt16NBool map[int16]bool

func (__ OfInt16NBool) Load(k int16) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NBool) Store(k int16, v bool) {
	__[k] = v
}
func (__ OfInt16NBool) Delete(k int16, v bool) {
	delete(__, k)
}
func (__ OfInt16NBool) Range(f func(k int16, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NBool = OfInt16NBool
type OfInt16NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NBool
}

func NewOfInt16NBoolSt(somes OfInt16NBool) *OfInt16NBoolSt {
	return &OfInt16NBoolSt{
		_OfInt16NBool: somes,
	}
}

type OfInt16NByteIf interface {
	Load(int16) (byte, error)
}

type OfInt16NByteMutIf interface {
	Store(int16, byte)
	Delete(int16)
}

type OfInt16NByteIterIf interface {
	Range(func(int16, byte) bool)
}

type OfInt16NByte map[int16]byte

func (__ OfInt16NByte) Load(k int16) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NByte) Store(k int16, v byte) {
	__[k] = v
}
func (__ OfInt16NByte) Delete(k int16, v byte) {
	delete(__, k)
}
func (__ OfInt16NByte) Range(f func(k int16, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NByte = OfInt16NByte
type OfInt16NByteSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NByte
}

func NewOfInt16NByteSt(somes OfInt16NByte) *OfInt16NByteSt {
	return &OfInt16NByteSt{
		_OfInt16NByte: somes,
	}
}

type OfInt16NComplex128If interface {
	Load(int16) (complex128, error)
}

type OfInt16NComplex128MutIf interface {
	Store(int16, complex128)
	Delete(int16)
}

type OfInt16NComplex128IterIf interface {
	Range(func(int16, complex128) bool)
}

type OfInt16NComplex128 map[int16]complex128

func (__ OfInt16NComplex128) Load(k int16) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NComplex128) Store(k int16, v complex128) {
	__[k] = v
}
func (__ OfInt16NComplex128) Delete(k int16, v complex128) {
	delete(__, k)
}
func (__ OfInt16NComplex128) Range(f func(k int16, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NComplex128 = OfInt16NComplex128
type OfInt16NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfInt16NComplex128
}

func NewOfInt16NComplex128St(somes OfInt16NComplex128) *OfInt16NComplex128St {
	return &OfInt16NComplex128St{
		_OfInt16NComplex128: somes,
	}
}

type OfInt16NComplex64If interface {
	Load(int16) (complex64, error)
}

type OfInt16NComplex64MutIf interface {
	Store(int16, complex64)
	Delete(int16)
}

type OfInt16NComplex64IterIf interface {
	Range(func(int16, complex64) bool)
}

type OfInt16NComplex64 map[int16]complex64

func (__ OfInt16NComplex64) Load(k int16) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NComplex64) Store(k int16, v complex64) {
	__[k] = v
}
func (__ OfInt16NComplex64) Delete(k int16, v complex64) {
	delete(__, k)
}
func (__ OfInt16NComplex64) Range(f func(k int16, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NComplex64 = OfInt16NComplex64
type OfInt16NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfInt16NComplex64
}

func NewOfInt16NComplex64St(somes OfInt16NComplex64) *OfInt16NComplex64St {
	return &OfInt16NComplex64St{
		_OfInt16NComplex64: somes,
	}
}

type OfInt16NErrorIf interface {
	Load(int16) (error, error)
}

type OfInt16NErrorMutIf interface {
	Store(int16, error)
	Delete(int16)
}

type OfInt16NErrorIterIf interface {
	Range(func(int16, error) bool)
}

type OfInt16NError map[int16]error

func (__ OfInt16NError) Load(k int16) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NError) Store(k int16, v error) {
	__[k] = v
}
func (__ OfInt16NError) Delete(k int16, v error) {
	delete(__, k)
}
func (__ OfInt16NError) Range(f func(k int16, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NError = OfInt16NError
type OfInt16NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NError
}

func NewOfInt16NErrorSt(somes OfInt16NError) *OfInt16NErrorSt {
	return &OfInt16NErrorSt{
		_OfInt16NError: somes,
	}
}

type OfInt16NFloat32If interface {
	Load(int16) (float32, error)
}

type OfInt16NFloat32MutIf interface {
	Store(int16, float32)
	Delete(int16)
}

type OfInt16NFloat32IterIf interface {
	Range(func(int16, float32) bool)
}

type OfInt16NFloat32 map[int16]float32

func (__ OfInt16NFloat32) Load(k int16) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NFloat32) Store(k int16, v float32) {
	__[k] = v
}
func (__ OfInt16NFloat32) Delete(k int16, v float32) {
	delete(__, k)
}
func (__ OfInt16NFloat32) Range(f func(k int16, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NFloat32 = OfInt16NFloat32
type OfInt16NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfInt16NFloat32
}

func NewOfInt16NFloat32St(somes OfInt16NFloat32) *OfInt16NFloat32St {
	return &OfInt16NFloat32St{
		_OfInt16NFloat32: somes,
	}
}

type OfInt16NFloat64If interface {
	Load(int16) (float64, error)
}

type OfInt16NFloat64MutIf interface {
	Store(int16, float64)
	Delete(int16)
}

type OfInt16NFloat64IterIf interface {
	Range(func(int16, float64) bool)
}

type OfInt16NFloat64 map[int16]float64

func (__ OfInt16NFloat64) Load(k int16) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NFloat64) Store(k int16, v float64) {
	__[k] = v
}
func (__ OfInt16NFloat64) Delete(k int16, v float64) {
	delete(__, k)
}
func (__ OfInt16NFloat64) Range(f func(k int16, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NFloat64 = OfInt16NFloat64
type OfInt16NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfInt16NFloat64
}

func NewOfInt16NFloat64St(somes OfInt16NFloat64) *OfInt16NFloat64St {
	return &OfInt16NFloat64St{
		_OfInt16NFloat64: somes,
	}
}

type OfInt16NIntIf interface {
	Load(int16) (int, error)
}

type OfInt16NIntMutIf interface {
	Store(int16, int)
	Delete(int16)
}

type OfInt16NIntIterIf interface {
	Range(func(int16, int) bool)
}

type OfInt16NInt map[int16]int

func (__ OfInt16NInt) Load(k int16) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NInt) Store(k int16, v int) {
	__[k] = v
}
func (__ OfInt16NInt) Delete(k int16, v int) {
	delete(__, k)
}
func (__ OfInt16NInt) Range(f func(k int16, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NInt = OfInt16NInt
type OfInt16NIntSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NInt
}

func NewOfInt16NIntSt(somes OfInt16NInt) *OfInt16NIntSt {
	return &OfInt16NIntSt{
		_OfInt16NInt: somes,
	}
}

type OfInt16NInt16If interface {
	Load(int16) (int16, error)
}

type OfInt16NInt16MutIf interface {
	Store(int16, int16)
	Delete(int16)
}

type OfInt16NInt16IterIf interface {
	Range(func(int16, int16) bool)
}

type OfInt16NInt16 map[int16]int16

func (__ OfInt16NInt16) Load(k int16) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NInt16) Store(k int16, v int16) {
	__[k] = v
}
func (__ OfInt16NInt16) Delete(k int16, v int16) {
	delete(__, k)
}
func (__ OfInt16NInt16) Range(f func(k int16, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NInt16 = OfInt16NInt16
type OfInt16NInt16St struct {
	// do not want to export but want to use embedding method
	_OfInt16NInt16
}

func NewOfInt16NInt16St(somes OfInt16NInt16) *OfInt16NInt16St {
	return &OfInt16NInt16St{
		_OfInt16NInt16: somes,
	}
}

type OfInt16NInt32If interface {
	Load(int16) (int32, error)
}

type OfInt16NInt32MutIf interface {
	Store(int16, int32)
	Delete(int16)
}

type OfInt16NInt32IterIf interface {
	Range(func(int16, int32) bool)
}

type OfInt16NInt32 map[int16]int32

func (__ OfInt16NInt32) Load(k int16) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NInt32) Store(k int16, v int32) {
	__[k] = v
}
func (__ OfInt16NInt32) Delete(k int16, v int32) {
	delete(__, k)
}
func (__ OfInt16NInt32) Range(f func(k int16, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NInt32 = OfInt16NInt32
type OfInt16NInt32St struct {
	// do not want to export but want to use embedding method
	_OfInt16NInt32
}

func NewOfInt16NInt32St(somes OfInt16NInt32) *OfInt16NInt32St {
	return &OfInt16NInt32St{
		_OfInt16NInt32: somes,
	}
}

type OfInt16NInt64If interface {
	Load(int16) (int64, error)
}

type OfInt16NInt64MutIf interface {
	Store(int16, int64)
	Delete(int16)
}

type OfInt16NInt64IterIf interface {
	Range(func(int16, int64) bool)
}

type OfInt16NInt64 map[int16]int64

func (__ OfInt16NInt64) Load(k int16) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NInt64) Store(k int16, v int64) {
	__[k] = v
}
func (__ OfInt16NInt64) Delete(k int16, v int64) {
	delete(__, k)
}
func (__ OfInt16NInt64) Range(f func(k int16, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NInt64 = OfInt16NInt64
type OfInt16NInt64St struct {
	// do not want to export but want to use embedding method
	_OfInt16NInt64
}

func NewOfInt16NInt64St(somes OfInt16NInt64) *OfInt16NInt64St {
	return &OfInt16NInt64St{
		_OfInt16NInt64: somes,
	}
}

type OfInt16NInt8If interface {
	Load(int16) (int8, error)
}

type OfInt16NInt8MutIf interface {
	Store(int16, int8)
	Delete(int16)
}

type OfInt16NInt8IterIf interface {
	Range(func(int16, int8) bool)
}

type OfInt16NInt8 map[int16]int8

func (__ OfInt16NInt8) Load(k int16) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NInt8) Store(k int16, v int8) {
	__[k] = v
}
func (__ OfInt16NInt8) Delete(k int16, v int8) {
	delete(__, k)
}
func (__ OfInt16NInt8) Range(f func(k int16, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NInt8 = OfInt16NInt8
type OfInt16NInt8St struct {
	// do not want to export but want to use embedding method
	_OfInt16NInt8
}

func NewOfInt16NInt8St(somes OfInt16NInt8) *OfInt16NInt8St {
	return &OfInt16NInt8St{
		_OfInt16NInt8: somes,
	}
}

type OfInt16NRuneIf interface {
	Load(int16) (rune, error)
}

type OfInt16NRuneMutIf interface {
	Store(int16, rune)
	Delete(int16)
}

type OfInt16NRuneIterIf interface {
	Range(func(int16, rune) bool)
}

type OfInt16NRune map[int16]rune

func (__ OfInt16NRune) Load(k int16) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NRune) Store(k int16, v rune) {
	__[k] = v
}
func (__ OfInt16NRune) Delete(k int16, v rune) {
	delete(__, k)
}
func (__ OfInt16NRune) Range(f func(k int16, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NRune = OfInt16NRune
type OfInt16NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NRune
}

func NewOfInt16NRuneSt(somes OfInt16NRune) *OfInt16NRuneSt {
	return &OfInt16NRuneSt{
		_OfInt16NRune: somes,
	}
}

type OfInt16NStringIf interface {
	Load(int16) (string, error)
}

type OfInt16NStringMutIf interface {
	Store(int16, string)
	Delete(int16)
}

type OfInt16NStringIterIf interface {
	Range(func(int16, string) bool)
}

type OfInt16NString map[int16]string

func (__ OfInt16NString) Load(k int16) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NString) Store(k int16, v string) {
	__[k] = v
}
func (__ OfInt16NString) Delete(k int16, v string) {
	delete(__, k)
}
func (__ OfInt16NString) Range(f func(k int16, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NString = OfInt16NString
type OfInt16NStringSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NString
}

func NewOfInt16NStringSt(somes OfInt16NString) *OfInt16NStringSt {
	return &OfInt16NStringSt{
		_OfInt16NString: somes,
	}
}

type OfInt16NUintIf interface {
	Load(int16) (uint, error)
}

type OfInt16NUintMutIf interface {
	Store(int16, uint)
	Delete(int16)
}

type OfInt16NUintIterIf interface {
	Range(func(int16, uint) bool)
}

type OfInt16NUint map[int16]uint

func (__ OfInt16NUint) Load(k int16) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NUint) Store(k int16, v uint) {
	__[k] = v
}
func (__ OfInt16NUint) Delete(k int16, v uint) {
	delete(__, k)
}
func (__ OfInt16NUint) Range(f func(k int16, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NUint = OfInt16NUint
type OfInt16NUintSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NUint
}

func NewOfInt16NUintSt(somes OfInt16NUint) *OfInt16NUintSt {
	return &OfInt16NUintSt{
		_OfInt16NUint: somes,
	}
}

type OfInt16NUint16If interface {
	Load(int16) (uint16, error)
}

type OfInt16NUint16MutIf interface {
	Store(int16, uint16)
	Delete(int16)
}

type OfInt16NUint16IterIf interface {
	Range(func(int16, uint16) bool)
}

type OfInt16NUint16 map[int16]uint16

func (__ OfInt16NUint16) Load(k int16) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NUint16) Store(k int16, v uint16) {
	__[k] = v
}
func (__ OfInt16NUint16) Delete(k int16, v uint16) {
	delete(__, k)
}
func (__ OfInt16NUint16) Range(f func(k int16, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NUint16 = OfInt16NUint16
type OfInt16NUint16St struct {
	// do not want to export but want to use embedding method
	_OfInt16NUint16
}

func NewOfInt16NUint16St(somes OfInt16NUint16) *OfInt16NUint16St {
	return &OfInt16NUint16St{
		_OfInt16NUint16: somes,
	}
}

type OfInt16NUint32If interface {
	Load(int16) (uint32, error)
}

type OfInt16NUint32MutIf interface {
	Store(int16, uint32)
	Delete(int16)
}

type OfInt16NUint32IterIf interface {
	Range(func(int16, uint32) bool)
}

type OfInt16NUint32 map[int16]uint32

func (__ OfInt16NUint32) Load(k int16) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NUint32) Store(k int16, v uint32) {
	__[k] = v
}
func (__ OfInt16NUint32) Delete(k int16, v uint32) {
	delete(__, k)
}
func (__ OfInt16NUint32) Range(f func(k int16, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NUint32 = OfInt16NUint32
type OfInt16NUint32St struct {
	// do not want to export but want to use embedding method
	_OfInt16NUint32
}

func NewOfInt16NUint32St(somes OfInt16NUint32) *OfInt16NUint32St {
	return &OfInt16NUint32St{
		_OfInt16NUint32: somes,
	}
}

type OfInt16NUint64If interface {
	Load(int16) (uint64, error)
}

type OfInt16NUint64MutIf interface {
	Store(int16, uint64)
	Delete(int16)
}

type OfInt16NUint64IterIf interface {
	Range(func(int16, uint64) bool)
}

type OfInt16NUint64 map[int16]uint64

func (__ OfInt16NUint64) Load(k int16) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NUint64) Store(k int16, v uint64) {
	__[k] = v
}
func (__ OfInt16NUint64) Delete(k int16, v uint64) {
	delete(__, k)
}
func (__ OfInt16NUint64) Range(f func(k int16, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NUint64 = OfInt16NUint64
type OfInt16NUint64St struct {
	// do not want to export but want to use embedding method
	_OfInt16NUint64
}

func NewOfInt16NUint64St(somes OfInt16NUint64) *OfInt16NUint64St {
	return &OfInt16NUint64St{
		_OfInt16NUint64: somes,
	}
}

type OfInt16NUint8If interface {
	Load(int16) (uint8, error)
}

type OfInt16NUint8MutIf interface {
	Store(int16, uint8)
	Delete(int16)
}

type OfInt16NUint8IterIf interface {
	Range(func(int16, uint8) bool)
}

type OfInt16NUint8 map[int16]uint8

func (__ OfInt16NUint8) Load(k int16) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NUint8) Store(k int16, v uint8) {
	__[k] = v
}
func (__ OfInt16NUint8) Delete(k int16, v uint8) {
	delete(__, k)
}
func (__ OfInt16NUint8) Range(f func(k int16, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NUint8 = OfInt16NUint8
type OfInt16NUint8St struct {
	// do not want to export but want to use embedding method
	_OfInt16NUint8
}

func NewOfInt16NUint8St(somes OfInt16NUint8) *OfInt16NUint8St {
	return &OfInt16NUint8St{
		_OfInt16NUint8: somes,
	}
}

type OfInt16NUintptrIf interface {
	Load(int16) (uintptr, error)
}

type OfInt16NUintptrMutIf interface {
	Store(int16, uintptr)
	Delete(int16)
}

type OfInt16NUintptrIterIf interface {
	Range(func(int16, uintptr) bool)
}

type OfInt16NUintptr map[int16]uintptr

func (__ OfInt16NUintptr) Load(k int16) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NUintptr) Store(k int16, v uintptr) {
	__[k] = v
}
func (__ OfInt16NUintptr) Delete(k int16, v uintptr) {
	delete(__, k)
}
func (__ OfInt16NUintptr) Range(f func(k int16, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NUintptr = OfInt16NUintptr
type OfInt16NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NUintptr
}

func NewOfInt16NUintptrSt(somes OfInt16NUintptr) *OfInt16NUintptrSt {
	return &OfInt16NUintptrSt{
		_OfInt16NUintptr: somes,
	}
}

type OfInt16NInterfaceIf interface {
	Load(int16) (interface{}, error)
}

type OfInt16NInterfaceMutIf interface {
	Store(int16, interface{})
	Delete(int16)
}

type OfInt16NInterfaceIterIf interface {
	Range(func(int16, interface{}) bool)
}

type OfInt16NInterface map[int16]interface{}

func (__ OfInt16NInterface) Load(k int16) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt16NInterface) Store(k int16, v interface{}) {
	__[k] = v
}
func (__ OfInt16NInterface) Delete(k int16, v interface{}) {
	delete(__, k)
}
func (__ OfInt16NInterface) Range(f func(k int16, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt16NInterface = OfInt16NInterface
type OfInt16NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfInt16NInterface
}

func NewOfInt16NInterfaceSt(somes OfInt16NInterface) *OfInt16NInterfaceSt {
	return &OfInt16NInterfaceSt{
		_OfInt16NInterface: somes,
	}
}

type OfInt32NBoolIf interface {
	Load(int32) (bool, error)
}

type OfInt32NBoolMutIf interface {
	Store(int32, bool)
	Delete(int32)
}

type OfInt32NBoolIterIf interface {
	Range(func(int32, bool) bool)
}

type OfInt32NBool map[int32]bool

func (__ OfInt32NBool) Load(k int32) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NBool) Store(k int32, v bool) {
	__[k] = v
}
func (__ OfInt32NBool) Delete(k int32, v bool) {
	delete(__, k)
}
func (__ OfInt32NBool) Range(f func(k int32, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NBool = OfInt32NBool
type OfInt32NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NBool
}

func NewOfInt32NBoolSt(somes OfInt32NBool) *OfInt32NBoolSt {
	return &OfInt32NBoolSt{
		_OfInt32NBool: somes,
	}
}

type OfInt32NByteIf interface {
	Load(int32) (byte, error)
}

type OfInt32NByteMutIf interface {
	Store(int32, byte)
	Delete(int32)
}

type OfInt32NByteIterIf interface {
	Range(func(int32, byte) bool)
}

type OfInt32NByte map[int32]byte

func (__ OfInt32NByte) Load(k int32) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NByte) Store(k int32, v byte) {
	__[k] = v
}
func (__ OfInt32NByte) Delete(k int32, v byte) {
	delete(__, k)
}
func (__ OfInt32NByte) Range(f func(k int32, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NByte = OfInt32NByte
type OfInt32NByteSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NByte
}

func NewOfInt32NByteSt(somes OfInt32NByte) *OfInt32NByteSt {
	return &OfInt32NByteSt{
		_OfInt32NByte: somes,
	}
}

type OfInt32NComplex128If interface {
	Load(int32) (complex128, error)
}

type OfInt32NComplex128MutIf interface {
	Store(int32, complex128)
	Delete(int32)
}

type OfInt32NComplex128IterIf interface {
	Range(func(int32, complex128) bool)
}

type OfInt32NComplex128 map[int32]complex128

func (__ OfInt32NComplex128) Load(k int32) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NComplex128) Store(k int32, v complex128) {
	__[k] = v
}
func (__ OfInt32NComplex128) Delete(k int32, v complex128) {
	delete(__, k)
}
func (__ OfInt32NComplex128) Range(f func(k int32, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NComplex128 = OfInt32NComplex128
type OfInt32NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfInt32NComplex128
}

func NewOfInt32NComplex128St(somes OfInt32NComplex128) *OfInt32NComplex128St {
	return &OfInt32NComplex128St{
		_OfInt32NComplex128: somes,
	}
}

type OfInt32NComplex64If interface {
	Load(int32) (complex64, error)
}

type OfInt32NComplex64MutIf interface {
	Store(int32, complex64)
	Delete(int32)
}

type OfInt32NComplex64IterIf interface {
	Range(func(int32, complex64) bool)
}

type OfInt32NComplex64 map[int32]complex64

func (__ OfInt32NComplex64) Load(k int32) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NComplex64) Store(k int32, v complex64) {
	__[k] = v
}
func (__ OfInt32NComplex64) Delete(k int32, v complex64) {
	delete(__, k)
}
func (__ OfInt32NComplex64) Range(f func(k int32, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NComplex64 = OfInt32NComplex64
type OfInt32NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfInt32NComplex64
}

func NewOfInt32NComplex64St(somes OfInt32NComplex64) *OfInt32NComplex64St {
	return &OfInt32NComplex64St{
		_OfInt32NComplex64: somes,
	}
}

type OfInt32NErrorIf interface {
	Load(int32) (error, error)
}

type OfInt32NErrorMutIf interface {
	Store(int32, error)
	Delete(int32)
}

type OfInt32NErrorIterIf interface {
	Range(func(int32, error) bool)
}

type OfInt32NError map[int32]error

func (__ OfInt32NError) Load(k int32) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NError) Store(k int32, v error) {
	__[k] = v
}
func (__ OfInt32NError) Delete(k int32, v error) {
	delete(__, k)
}
func (__ OfInt32NError) Range(f func(k int32, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NError = OfInt32NError
type OfInt32NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NError
}

func NewOfInt32NErrorSt(somes OfInt32NError) *OfInt32NErrorSt {
	return &OfInt32NErrorSt{
		_OfInt32NError: somes,
	}
}

type OfInt32NFloat32If interface {
	Load(int32) (float32, error)
}

type OfInt32NFloat32MutIf interface {
	Store(int32, float32)
	Delete(int32)
}

type OfInt32NFloat32IterIf interface {
	Range(func(int32, float32) bool)
}

type OfInt32NFloat32 map[int32]float32

func (__ OfInt32NFloat32) Load(k int32) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NFloat32) Store(k int32, v float32) {
	__[k] = v
}
func (__ OfInt32NFloat32) Delete(k int32, v float32) {
	delete(__, k)
}
func (__ OfInt32NFloat32) Range(f func(k int32, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NFloat32 = OfInt32NFloat32
type OfInt32NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfInt32NFloat32
}

func NewOfInt32NFloat32St(somes OfInt32NFloat32) *OfInt32NFloat32St {
	return &OfInt32NFloat32St{
		_OfInt32NFloat32: somes,
	}
}

type OfInt32NFloat64If interface {
	Load(int32) (float64, error)
}

type OfInt32NFloat64MutIf interface {
	Store(int32, float64)
	Delete(int32)
}

type OfInt32NFloat64IterIf interface {
	Range(func(int32, float64) bool)
}

type OfInt32NFloat64 map[int32]float64

func (__ OfInt32NFloat64) Load(k int32) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NFloat64) Store(k int32, v float64) {
	__[k] = v
}
func (__ OfInt32NFloat64) Delete(k int32, v float64) {
	delete(__, k)
}
func (__ OfInt32NFloat64) Range(f func(k int32, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NFloat64 = OfInt32NFloat64
type OfInt32NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfInt32NFloat64
}

func NewOfInt32NFloat64St(somes OfInt32NFloat64) *OfInt32NFloat64St {
	return &OfInt32NFloat64St{
		_OfInt32NFloat64: somes,
	}
}

type OfInt32NIntIf interface {
	Load(int32) (int, error)
}

type OfInt32NIntMutIf interface {
	Store(int32, int)
	Delete(int32)
}

type OfInt32NIntIterIf interface {
	Range(func(int32, int) bool)
}

type OfInt32NInt map[int32]int

func (__ OfInt32NInt) Load(k int32) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NInt) Store(k int32, v int) {
	__[k] = v
}
func (__ OfInt32NInt) Delete(k int32, v int) {
	delete(__, k)
}
func (__ OfInt32NInt) Range(f func(k int32, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NInt = OfInt32NInt
type OfInt32NIntSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NInt
}

func NewOfInt32NIntSt(somes OfInt32NInt) *OfInt32NIntSt {
	return &OfInt32NIntSt{
		_OfInt32NInt: somes,
	}
}

type OfInt32NInt16If interface {
	Load(int32) (int16, error)
}

type OfInt32NInt16MutIf interface {
	Store(int32, int16)
	Delete(int32)
}

type OfInt32NInt16IterIf interface {
	Range(func(int32, int16) bool)
}

type OfInt32NInt16 map[int32]int16

func (__ OfInt32NInt16) Load(k int32) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NInt16) Store(k int32, v int16) {
	__[k] = v
}
func (__ OfInt32NInt16) Delete(k int32, v int16) {
	delete(__, k)
}
func (__ OfInt32NInt16) Range(f func(k int32, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NInt16 = OfInt32NInt16
type OfInt32NInt16St struct {
	// do not want to export but want to use embedding method
	_OfInt32NInt16
}

func NewOfInt32NInt16St(somes OfInt32NInt16) *OfInt32NInt16St {
	return &OfInt32NInt16St{
		_OfInt32NInt16: somes,
	}
}

type OfInt32NInt32If interface {
	Load(int32) (int32, error)
}

type OfInt32NInt32MutIf interface {
	Store(int32, int32)
	Delete(int32)
}

type OfInt32NInt32IterIf interface {
	Range(func(int32, int32) bool)
}

type OfInt32NInt32 map[int32]int32

func (__ OfInt32NInt32) Load(k int32) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NInt32) Store(k int32, v int32) {
	__[k] = v
}
func (__ OfInt32NInt32) Delete(k int32, v int32) {
	delete(__, k)
}
func (__ OfInt32NInt32) Range(f func(k int32, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NInt32 = OfInt32NInt32
type OfInt32NInt32St struct {
	// do not want to export but want to use embedding method
	_OfInt32NInt32
}

func NewOfInt32NInt32St(somes OfInt32NInt32) *OfInt32NInt32St {
	return &OfInt32NInt32St{
		_OfInt32NInt32: somes,
	}
}

type OfInt32NInt64If interface {
	Load(int32) (int64, error)
}

type OfInt32NInt64MutIf interface {
	Store(int32, int64)
	Delete(int32)
}

type OfInt32NInt64IterIf interface {
	Range(func(int32, int64) bool)
}

type OfInt32NInt64 map[int32]int64

func (__ OfInt32NInt64) Load(k int32) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NInt64) Store(k int32, v int64) {
	__[k] = v
}
func (__ OfInt32NInt64) Delete(k int32, v int64) {
	delete(__, k)
}
func (__ OfInt32NInt64) Range(f func(k int32, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NInt64 = OfInt32NInt64
type OfInt32NInt64St struct {
	// do not want to export but want to use embedding method
	_OfInt32NInt64
}

func NewOfInt32NInt64St(somes OfInt32NInt64) *OfInt32NInt64St {
	return &OfInt32NInt64St{
		_OfInt32NInt64: somes,
	}
}

type OfInt32NInt8If interface {
	Load(int32) (int8, error)
}

type OfInt32NInt8MutIf interface {
	Store(int32, int8)
	Delete(int32)
}

type OfInt32NInt8IterIf interface {
	Range(func(int32, int8) bool)
}

type OfInt32NInt8 map[int32]int8

func (__ OfInt32NInt8) Load(k int32) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NInt8) Store(k int32, v int8) {
	__[k] = v
}
func (__ OfInt32NInt8) Delete(k int32, v int8) {
	delete(__, k)
}
func (__ OfInt32NInt8) Range(f func(k int32, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NInt8 = OfInt32NInt8
type OfInt32NInt8St struct {
	// do not want to export but want to use embedding method
	_OfInt32NInt8
}

func NewOfInt32NInt8St(somes OfInt32NInt8) *OfInt32NInt8St {
	return &OfInt32NInt8St{
		_OfInt32NInt8: somes,
	}
}

type OfInt32NRuneIf interface {
	Load(int32) (rune, error)
}

type OfInt32NRuneMutIf interface {
	Store(int32, rune)
	Delete(int32)
}

type OfInt32NRuneIterIf interface {
	Range(func(int32, rune) bool)
}

type OfInt32NRune map[int32]rune

func (__ OfInt32NRune) Load(k int32) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NRune) Store(k int32, v rune) {
	__[k] = v
}
func (__ OfInt32NRune) Delete(k int32, v rune) {
	delete(__, k)
}
func (__ OfInt32NRune) Range(f func(k int32, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NRune = OfInt32NRune
type OfInt32NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NRune
}

func NewOfInt32NRuneSt(somes OfInt32NRune) *OfInt32NRuneSt {
	return &OfInt32NRuneSt{
		_OfInt32NRune: somes,
	}
}

type OfInt32NStringIf interface {
	Load(int32) (string, error)
}

type OfInt32NStringMutIf interface {
	Store(int32, string)
	Delete(int32)
}

type OfInt32NStringIterIf interface {
	Range(func(int32, string) bool)
}

type OfInt32NString map[int32]string

func (__ OfInt32NString) Load(k int32) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NString) Store(k int32, v string) {
	__[k] = v
}
func (__ OfInt32NString) Delete(k int32, v string) {
	delete(__, k)
}
func (__ OfInt32NString) Range(f func(k int32, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NString = OfInt32NString
type OfInt32NStringSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NString
}

func NewOfInt32NStringSt(somes OfInt32NString) *OfInt32NStringSt {
	return &OfInt32NStringSt{
		_OfInt32NString: somes,
	}
}

type OfInt32NUintIf interface {
	Load(int32) (uint, error)
}

type OfInt32NUintMutIf interface {
	Store(int32, uint)
	Delete(int32)
}

type OfInt32NUintIterIf interface {
	Range(func(int32, uint) bool)
}

type OfInt32NUint map[int32]uint

func (__ OfInt32NUint) Load(k int32) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NUint) Store(k int32, v uint) {
	__[k] = v
}
func (__ OfInt32NUint) Delete(k int32, v uint) {
	delete(__, k)
}
func (__ OfInt32NUint) Range(f func(k int32, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NUint = OfInt32NUint
type OfInt32NUintSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NUint
}

func NewOfInt32NUintSt(somes OfInt32NUint) *OfInt32NUintSt {
	return &OfInt32NUintSt{
		_OfInt32NUint: somes,
	}
}

type OfInt32NUint16If interface {
	Load(int32) (uint16, error)
}

type OfInt32NUint16MutIf interface {
	Store(int32, uint16)
	Delete(int32)
}

type OfInt32NUint16IterIf interface {
	Range(func(int32, uint16) bool)
}

type OfInt32NUint16 map[int32]uint16

func (__ OfInt32NUint16) Load(k int32) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NUint16) Store(k int32, v uint16) {
	__[k] = v
}
func (__ OfInt32NUint16) Delete(k int32, v uint16) {
	delete(__, k)
}
func (__ OfInt32NUint16) Range(f func(k int32, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NUint16 = OfInt32NUint16
type OfInt32NUint16St struct {
	// do not want to export but want to use embedding method
	_OfInt32NUint16
}

func NewOfInt32NUint16St(somes OfInt32NUint16) *OfInt32NUint16St {
	return &OfInt32NUint16St{
		_OfInt32NUint16: somes,
	}
}

type OfInt32NUint32If interface {
	Load(int32) (uint32, error)
}

type OfInt32NUint32MutIf interface {
	Store(int32, uint32)
	Delete(int32)
}

type OfInt32NUint32IterIf interface {
	Range(func(int32, uint32) bool)
}

type OfInt32NUint32 map[int32]uint32

func (__ OfInt32NUint32) Load(k int32) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NUint32) Store(k int32, v uint32) {
	__[k] = v
}
func (__ OfInt32NUint32) Delete(k int32, v uint32) {
	delete(__, k)
}
func (__ OfInt32NUint32) Range(f func(k int32, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NUint32 = OfInt32NUint32
type OfInt32NUint32St struct {
	// do not want to export but want to use embedding method
	_OfInt32NUint32
}

func NewOfInt32NUint32St(somes OfInt32NUint32) *OfInt32NUint32St {
	return &OfInt32NUint32St{
		_OfInt32NUint32: somes,
	}
}

type OfInt32NUint64If interface {
	Load(int32) (uint64, error)
}

type OfInt32NUint64MutIf interface {
	Store(int32, uint64)
	Delete(int32)
}

type OfInt32NUint64IterIf interface {
	Range(func(int32, uint64) bool)
}

type OfInt32NUint64 map[int32]uint64

func (__ OfInt32NUint64) Load(k int32) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NUint64) Store(k int32, v uint64) {
	__[k] = v
}
func (__ OfInt32NUint64) Delete(k int32, v uint64) {
	delete(__, k)
}
func (__ OfInt32NUint64) Range(f func(k int32, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NUint64 = OfInt32NUint64
type OfInt32NUint64St struct {
	// do not want to export but want to use embedding method
	_OfInt32NUint64
}

func NewOfInt32NUint64St(somes OfInt32NUint64) *OfInt32NUint64St {
	return &OfInt32NUint64St{
		_OfInt32NUint64: somes,
	}
}

type OfInt32NUint8If interface {
	Load(int32) (uint8, error)
}

type OfInt32NUint8MutIf interface {
	Store(int32, uint8)
	Delete(int32)
}

type OfInt32NUint8IterIf interface {
	Range(func(int32, uint8) bool)
}

type OfInt32NUint8 map[int32]uint8

func (__ OfInt32NUint8) Load(k int32) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NUint8) Store(k int32, v uint8) {
	__[k] = v
}
func (__ OfInt32NUint8) Delete(k int32, v uint8) {
	delete(__, k)
}
func (__ OfInt32NUint8) Range(f func(k int32, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NUint8 = OfInt32NUint8
type OfInt32NUint8St struct {
	// do not want to export but want to use embedding method
	_OfInt32NUint8
}

func NewOfInt32NUint8St(somes OfInt32NUint8) *OfInt32NUint8St {
	return &OfInt32NUint8St{
		_OfInt32NUint8: somes,
	}
}

type OfInt32NUintptrIf interface {
	Load(int32) (uintptr, error)
}

type OfInt32NUintptrMutIf interface {
	Store(int32, uintptr)
	Delete(int32)
}

type OfInt32NUintptrIterIf interface {
	Range(func(int32, uintptr) bool)
}

type OfInt32NUintptr map[int32]uintptr

func (__ OfInt32NUintptr) Load(k int32) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NUintptr) Store(k int32, v uintptr) {
	__[k] = v
}
func (__ OfInt32NUintptr) Delete(k int32, v uintptr) {
	delete(__, k)
}
func (__ OfInt32NUintptr) Range(f func(k int32, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NUintptr = OfInt32NUintptr
type OfInt32NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NUintptr
}

func NewOfInt32NUintptrSt(somes OfInt32NUintptr) *OfInt32NUintptrSt {
	return &OfInt32NUintptrSt{
		_OfInt32NUintptr: somes,
	}
}

type OfInt32NInterfaceIf interface {
	Load(int32) (interface{}, error)
}

type OfInt32NInterfaceMutIf interface {
	Store(int32, interface{})
	Delete(int32)
}

type OfInt32NInterfaceIterIf interface {
	Range(func(int32, interface{}) bool)
}

type OfInt32NInterface map[int32]interface{}

func (__ OfInt32NInterface) Load(k int32) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt32NInterface) Store(k int32, v interface{}) {
	__[k] = v
}
func (__ OfInt32NInterface) Delete(k int32, v interface{}) {
	delete(__, k)
}
func (__ OfInt32NInterface) Range(f func(k int32, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt32NInterface = OfInt32NInterface
type OfInt32NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfInt32NInterface
}

func NewOfInt32NInterfaceSt(somes OfInt32NInterface) *OfInt32NInterfaceSt {
	return &OfInt32NInterfaceSt{
		_OfInt32NInterface: somes,
	}
}

type OfInt64NBoolIf interface {
	Load(int64) (bool, error)
}

type OfInt64NBoolMutIf interface {
	Store(int64, bool)
	Delete(int64)
}

type OfInt64NBoolIterIf interface {
	Range(func(int64, bool) bool)
}

type OfInt64NBool map[int64]bool

func (__ OfInt64NBool) Load(k int64) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NBool) Store(k int64, v bool) {
	__[k] = v
}
func (__ OfInt64NBool) Delete(k int64, v bool) {
	delete(__, k)
}
func (__ OfInt64NBool) Range(f func(k int64, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NBool = OfInt64NBool
type OfInt64NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NBool
}

func NewOfInt64NBoolSt(somes OfInt64NBool) *OfInt64NBoolSt {
	return &OfInt64NBoolSt{
		_OfInt64NBool: somes,
	}
}

type OfInt64NByteIf interface {
	Load(int64) (byte, error)
}

type OfInt64NByteMutIf interface {
	Store(int64, byte)
	Delete(int64)
}

type OfInt64NByteIterIf interface {
	Range(func(int64, byte) bool)
}

type OfInt64NByte map[int64]byte

func (__ OfInt64NByte) Load(k int64) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NByte) Store(k int64, v byte) {
	__[k] = v
}
func (__ OfInt64NByte) Delete(k int64, v byte) {
	delete(__, k)
}
func (__ OfInt64NByte) Range(f func(k int64, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NByte = OfInt64NByte
type OfInt64NByteSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NByte
}

func NewOfInt64NByteSt(somes OfInt64NByte) *OfInt64NByteSt {
	return &OfInt64NByteSt{
		_OfInt64NByte: somes,
	}
}

type OfInt64NComplex128If interface {
	Load(int64) (complex128, error)
}

type OfInt64NComplex128MutIf interface {
	Store(int64, complex128)
	Delete(int64)
}

type OfInt64NComplex128IterIf interface {
	Range(func(int64, complex128) bool)
}

type OfInt64NComplex128 map[int64]complex128

func (__ OfInt64NComplex128) Load(k int64) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NComplex128) Store(k int64, v complex128) {
	__[k] = v
}
func (__ OfInt64NComplex128) Delete(k int64, v complex128) {
	delete(__, k)
}
func (__ OfInt64NComplex128) Range(f func(k int64, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NComplex128 = OfInt64NComplex128
type OfInt64NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfInt64NComplex128
}

func NewOfInt64NComplex128St(somes OfInt64NComplex128) *OfInt64NComplex128St {
	return &OfInt64NComplex128St{
		_OfInt64NComplex128: somes,
	}
}

type OfInt64NComplex64If interface {
	Load(int64) (complex64, error)
}

type OfInt64NComplex64MutIf interface {
	Store(int64, complex64)
	Delete(int64)
}

type OfInt64NComplex64IterIf interface {
	Range(func(int64, complex64) bool)
}

type OfInt64NComplex64 map[int64]complex64

func (__ OfInt64NComplex64) Load(k int64) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NComplex64) Store(k int64, v complex64) {
	__[k] = v
}
func (__ OfInt64NComplex64) Delete(k int64, v complex64) {
	delete(__, k)
}
func (__ OfInt64NComplex64) Range(f func(k int64, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NComplex64 = OfInt64NComplex64
type OfInt64NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfInt64NComplex64
}

func NewOfInt64NComplex64St(somes OfInt64NComplex64) *OfInt64NComplex64St {
	return &OfInt64NComplex64St{
		_OfInt64NComplex64: somes,
	}
}

type OfInt64NErrorIf interface {
	Load(int64) (error, error)
}

type OfInt64NErrorMutIf interface {
	Store(int64, error)
	Delete(int64)
}

type OfInt64NErrorIterIf interface {
	Range(func(int64, error) bool)
}

type OfInt64NError map[int64]error

func (__ OfInt64NError) Load(k int64) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NError) Store(k int64, v error) {
	__[k] = v
}
func (__ OfInt64NError) Delete(k int64, v error) {
	delete(__, k)
}
func (__ OfInt64NError) Range(f func(k int64, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NError = OfInt64NError
type OfInt64NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NError
}

func NewOfInt64NErrorSt(somes OfInt64NError) *OfInt64NErrorSt {
	return &OfInt64NErrorSt{
		_OfInt64NError: somes,
	}
}

type OfInt64NFloat32If interface {
	Load(int64) (float32, error)
}

type OfInt64NFloat32MutIf interface {
	Store(int64, float32)
	Delete(int64)
}

type OfInt64NFloat32IterIf interface {
	Range(func(int64, float32) bool)
}

type OfInt64NFloat32 map[int64]float32

func (__ OfInt64NFloat32) Load(k int64) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NFloat32) Store(k int64, v float32) {
	__[k] = v
}
func (__ OfInt64NFloat32) Delete(k int64, v float32) {
	delete(__, k)
}
func (__ OfInt64NFloat32) Range(f func(k int64, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NFloat32 = OfInt64NFloat32
type OfInt64NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfInt64NFloat32
}

func NewOfInt64NFloat32St(somes OfInt64NFloat32) *OfInt64NFloat32St {
	return &OfInt64NFloat32St{
		_OfInt64NFloat32: somes,
	}
}

type OfInt64NFloat64If interface {
	Load(int64) (float64, error)
}

type OfInt64NFloat64MutIf interface {
	Store(int64, float64)
	Delete(int64)
}

type OfInt64NFloat64IterIf interface {
	Range(func(int64, float64) bool)
}

type OfInt64NFloat64 map[int64]float64

func (__ OfInt64NFloat64) Load(k int64) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NFloat64) Store(k int64, v float64) {
	__[k] = v
}
func (__ OfInt64NFloat64) Delete(k int64, v float64) {
	delete(__, k)
}
func (__ OfInt64NFloat64) Range(f func(k int64, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NFloat64 = OfInt64NFloat64
type OfInt64NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfInt64NFloat64
}

func NewOfInt64NFloat64St(somes OfInt64NFloat64) *OfInt64NFloat64St {
	return &OfInt64NFloat64St{
		_OfInt64NFloat64: somes,
	}
}

type OfInt64NIntIf interface {
	Load(int64) (int, error)
}

type OfInt64NIntMutIf interface {
	Store(int64, int)
	Delete(int64)
}

type OfInt64NIntIterIf interface {
	Range(func(int64, int) bool)
}

type OfInt64NInt map[int64]int

func (__ OfInt64NInt) Load(k int64) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NInt) Store(k int64, v int) {
	__[k] = v
}
func (__ OfInt64NInt) Delete(k int64, v int) {
	delete(__, k)
}
func (__ OfInt64NInt) Range(f func(k int64, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NInt = OfInt64NInt
type OfInt64NIntSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NInt
}

func NewOfInt64NIntSt(somes OfInt64NInt) *OfInt64NIntSt {
	return &OfInt64NIntSt{
		_OfInt64NInt: somes,
	}
}

type OfInt64NInt16If interface {
	Load(int64) (int16, error)
}

type OfInt64NInt16MutIf interface {
	Store(int64, int16)
	Delete(int64)
}

type OfInt64NInt16IterIf interface {
	Range(func(int64, int16) bool)
}

type OfInt64NInt16 map[int64]int16

func (__ OfInt64NInt16) Load(k int64) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NInt16) Store(k int64, v int16) {
	__[k] = v
}
func (__ OfInt64NInt16) Delete(k int64, v int16) {
	delete(__, k)
}
func (__ OfInt64NInt16) Range(f func(k int64, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NInt16 = OfInt64NInt16
type OfInt64NInt16St struct {
	// do not want to export but want to use embedding method
	_OfInt64NInt16
}

func NewOfInt64NInt16St(somes OfInt64NInt16) *OfInt64NInt16St {
	return &OfInt64NInt16St{
		_OfInt64NInt16: somes,
	}
}

type OfInt64NInt32If interface {
	Load(int64) (int32, error)
}

type OfInt64NInt32MutIf interface {
	Store(int64, int32)
	Delete(int64)
}

type OfInt64NInt32IterIf interface {
	Range(func(int64, int32) bool)
}

type OfInt64NInt32 map[int64]int32

func (__ OfInt64NInt32) Load(k int64) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NInt32) Store(k int64, v int32) {
	__[k] = v
}
func (__ OfInt64NInt32) Delete(k int64, v int32) {
	delete(__, k)
}
func (__ OfInt64NInt32) Range(f func(k int64, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NInt32 = OfInt64NInt32
type OfInt64NInt32St struct {
	// do not want to export but want to use embedding method
	_OfInt64NInt32
}

func NewOfInt64NInt32St(somes OfInt64NInt32) *OfInt64NInt32St {
	return &OfInt64NInt32St{
		_OfInt64NInt32: somes,
	}
}

type OfInt64NInt64If interface {
	Load(int64) (int64, error)
}

type OfInt64NInt64MutIf interface {
	Store(int64, int64)
	Delete(int64)
}

type OfInt64NInt64IterIf interface {
	Range(func(int64, int64) bool)
}

type OfInt64NInt64 map[int64]int64

func (__ OfInt64NInt64) Load(k int64) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NInt64) Store(k int64, v int64) {
	__[k] = v
}
func (__ OfInt64NInt64) Delete(k int64, v int64) {
	delete(__, k)
}
func (__ OfInt64NInt64) Range(f func(k int64, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NInt64 = OfInt64NInt64
type OfInt64NInt64St struct {
	// do not want to export but want to use embedding method
	_OfInt64NInt64
}

func NewOfInt64NInt64St(somes OfInt64NInt64) *OfInt64NInt64St {
	return &OfInt64NInt64St{
		_OfInt64NInt64: somes,
	}
}

type OfInt64NInt8If interface {
	Load(int64) (int8, error)
}

type OfInt64NInt8MutIf interface {
	Store(int64, int8)
	Delete(int64)
}

type OfInt64NInt8IterIf interface {
	Range(func(int64, int8) bool)
}

type OfInt64NInt8 map[int64]int8

func (__ OfInt64NInt8) Load(k int64) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NInt8) Store(k int64, v int8) {
	__[k] = v
}
func (__ OfInt64NInt8) Delete(k int64, v int8) {
	delete(__, k)
}
func (__ OfInt64NInt8) Range(f func(k int64, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NInt8 = OfInt64NInt8
type OfInt64NInt8St struct {
	// do not want to export but want to use embedding method
	_OfInt64NInt8
}

func NewOfInt64NInt8St(somes OfInt64NInt8) *OfInt64NInt8St {
	return &OfInt64NInt8St{
		_OfInt64NInt8: somes,
	}
}

type OfInt64NRuneIf interface {
	Load(int64) (rune, error)
}

type OfInt64NRuneMutIf interface {
	Store(int64, rune)
	Delete(int64)
}

type OfInt64NRuneIterIf interface {
	Range(func(int64, rune) bool)
}

type OfInt64NRune map[int64]rune

func (__ OfInt64NRune) Load(k int64) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NRune) Store(k int64, v rune) {
	__[k] = v
}
func (__ OfInt64NRune) Delete(k int64, v rune) {
	delete(__, k)
}
func (__ OfInt64NRune) Range(f func(k int64, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NRune = OfInt64NRune
type OfInt64NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NRune
}

func NewOfInt64NRuneSt(somes OfInt64NRune) *OfInt64NRuneSt {
	return &OfInt64NRuneSt{
		_OfInt64NRune: somes,
	}
}

type OfInt64NStringIf interface {
	Load(int64) (string, error)
}

type OfInt64NStringMutIf interface {
	Store(int64, string)
	Delete(int64)
}

type OfInt64NStringIterIf interface {
	Range(func(int64, string) bool)
}

type OfInt64NString map[int64]string

func (__ OfInt64NString) Load(k int64) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NString) Store(k int64, v string) {
	__[k] = v
}
func (__ OfInt64NString) Delete(k int64, v string) {
	delete(__, k)
}
func (__ OfInt64NString) Range(f func(k int64, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NString = OfInt64NString
type OfInt64NStringSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NString
}

func NewOfInt64NStringSt(somes OfInt64NString) *OfInt64NStringSt {
	return &OfInt64NStringSt{
		_OfInt64NString: somes,
	}
}

type OfInt64NUintIf interface {
	Load(int64) (uint, error)
}

type OfInt64NUintMutIf interface {
	Store(int64, uint)
	Delete(int64)
}

type OfInt64NUintIterIf interface {
	Range(func(int64, uint) bool)
}

type OfInt64NUint map[int64]uint

func (__ OfInt64NUint) Load(k int64) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NUint) Store(k int64, v uint) {
	__[k] = v
}
func (__ OfInt64NUint) Delete(k int64, v uint) {
	delete(__, k)
}
func (__ OfInt64NUint) Range(f func(k int64, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NUint = OfInt64NUint
type OfInt64NUintSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NUint
}

func NewOfInt64NUintSt(somes OfInt64NUint) *OfInt64NUintSt {
	return &OfInt64NUintSt{
		_OfInt64NUint: somes,
	}
}

type OfInt64NUint16If interface {
	Load(int64) (uint16, error)
}

type OfInt64NUint16MutIf interface {
	Store(int64, uint16)
	Delete(int64)
}

type OfInt64NUint16IterIf interface {
	Range(func(int64, uint16) bool)
}

type OfInt64NUint16 map[int64]uint16

func (__ OfInt64NUint16) Load(k int64) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NUint16) Store(k int64, v uint16) {
	__[k] = v
}
func (__ OfInt64NUint16) Delete(k int64, v uint16) {
	delete(__, k)
}
func (__ OfInt64NUint16) Range(f func(k int64, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NUint16 = OfInt64NUint16
type OfInt64NUint16St struct {
	// do not want to export but want to use embedding method
	_OfInt64NUint16
}

func NewOfInt64NUint16St(somes OfInt64NUint16) *OfInt64NUint16St {
	return &OfInt64NUint16St{
		_OfInt64NUint16: somes,
	}
}

type OfInt64NUint32If interface {
	Load(int64) (uint32, error)
}

type OfInt64NUint32MutIf interface {
	Store(int64, uint32)
	Delete(int64)
}

type OfInt64NUint32IterIf interface {
	Range(func(int64, uint32) bool)
}

type OfInt64NUint32 map[int64]uint32

func (__ OfInt64NUint32) Load(k int64) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NUint32) Store(k int64, v uint32) {
	__[k] = v
}
func (__ OfInt64NUint32) Delete(k int64, v uint32) {
	delete(__, k)
}
func (__ OfInt64NUint32) Range(f func(k int64, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NUint32 = OfInt64NUint32
type OfInt64NUint32St struct {
	// do not want to export but want to use embedding method
	_OfInt64NUint32
}

func NewOfInt64NUint32St(somes OfInt64NUint32) *OfInt64NUint32St {
	return &OfInt64NUint32St{
		_OfInt64NUint32: somes,
	}
}

type OfInt64NUint64If interface {
	Load(int64) (uint64, error)
}

type OfInt64NUint64MutIf interface {
	Store(int64, uint64)
	Delete(int64)
}

type OfInt64NUint64IterIf interface {
	Range(func(int64, uint64) bool)
}

type OfInt64NUint64 map[int64]uint64

func (__ OfInt64NUint64) Load(k int64) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NUint64) Store(k int64, v uint64) {
	__[k] = v
}
func (__ OfInt64NUint64) Delete(k int64, v uint64) {
	delete(__, k)
}
func (__ OfInt64NUint64) Range(f func(k int64, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NUint64 = OfInt64NUint64
type OfInt64NUint64St struct {
	// do not want to export but want to use embedding method
	_OfInt64NUint64
}

func NewOfInt64NUint64St(somes OfInt64NUint64) *OfInt64NUint64St {
	return &OfInt64NUint64St{
		_OfInt64NUint64: somes,
	}
}

type OfInt64NUint8If interface {
	Load(int64) (uint8, error)
}

type OfInt64NUint8MutIf interface {
	Store(int64, uint8)
	Delete(int64)
}

type OfInt64NUint8IterIf interface {
	Range(func(int64, uint8) bool)
}

type OfInt64NUint8 map[int64]uint8

func (__ OfInt64NUint8) Load(k int64) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NUint8) Store(k int64, v uint8) {
	__[k] = v
}
func (__ OfInt64NUint8) Delete(k int64, v uint8) {
	delete(__, k)
}
func (__ OfInt64NUint8) Range(f func(k int64, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NUint8 = OfInt64NUint8
type OfInt64NUint8St struct {
	// do not want to export but want to use embedding method
	_OfInt64NUint8
}

func NewOfInt64NUint8St(somes OfInt64NUint8) *OfInt64NUint8St {
	return &OfInt64NUint8St{
		_OfInt64NUint8: somes,
	}
}

type OfInt64NUintptrIf interface {
	Load(int64) (uintptr, error)
}

type OfInt64NUintptrMutIf interface {
	Store(int64, uintptr)
	Delete(int64)
}

type OfInt64NUintptrIterIf interface {
	Range(func(int64, uintptr) bool)
}

type OfInt64NUintptr map[int64]uintptr

func (__ OfInt64NUintptr) Load(k int64) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NUintptr) Store(k int64, v uintptr) {
	__[k] = v
}
func (__ OfInt64NUintptr) Delete(k int64, v uintptr) {
	delete(__, k)
}
func (__ OfInt64NUintptr) Range(f func(k int64, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NUintptr = OfInt64NUintptr
type OfInt64NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NUintptr
}

func NewOfInt64NUintptrSt(somes OfInt64NUintptr) *OfInt64NUintptrSt {
	return &OfInt64NUintptrSt{
		_OfInt64NUintptr: somes,
	}
}

type OfInt64NInterfaceIf interface {
	Load(int64) (interface{}, error)
}

type OfInt64NInterfaceMutIf interface {
	Store(int64, interface{})
	Delete(int64)
}

type OfInt64NInterfaceIterIf interface {
	Range(func(int64, interface{}) bool)
}

type OfInt64NInterface map[int64]interface{}

func (__ OfInt64NInterface) Load(k int64) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt64NInterface) Store(k int64, v interface{}) {
	__[k] = v
}
func (__ OfInt64NInterface) Delete(k int64, v interface{}) {
	delete(__, k)
}
func (__ OfInt64NInterface) Range(f func(k int64, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt64NInterface = OfInt64NInterface
type OfInt64NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfInt64NInterface
}

func NewOfInt64NInterfaceSt(somes OfInt64NInterface) *OfInt64NInterfaceSt {
	return &OfInt64NInterfaceSt{
		_OfInt64NInterface: somes,
	}
}

type OfInt8NBoolIf interface {
	Load(int8) (bool, error)
}

type OfInt8NBoolMutIf interface {
	Store(int8, bool)
	Delete(int8)
}

type OfInt8NBoolIterIf interface {
	Range(func(int8, bool) bool)
}

type OfInt8NBool map[int8]bool

func (__ OfInt8NBool) Load(k int8) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NBool) Store(k int8, v bool) {
	__[k] = v
}
func (__ OfInt8NBool) Delete(k int8, v bool) {
	delete(__, k)
}
func (__ OfInt8NBool) Range(f func(k int8, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NBool = OfInt8NBool
type OfInt8NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NBool
}

func NewOfInt8NBoolSt(somes OfInt8NBool) *OfInt8NBoolSt {
	return &OfInt8NBoolSt{
		_OfInt8NBool: somes,
	}
}

type OfInt8NByteIf interface {
	Load(int8) (byte, error)
}

type OfInt8NByteMutIf interface {
	Store(int8, byte)
	Delete(int8)
}

type OfInt8NByteIterIf interface {
	Range(func(int8, byte) bool)
}

type OfInt8NByte map[int8]byte

func (__ OfInt8NByte) Load(k int8) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NByte) Store(k int8, v byte) {
	__[k] = v
}
func (__ OfInt8NByte) Delete(k int8, v byte) {
	delete(__, k)
}
func (__ OfInt8NByte) Range(f func(k int8, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NByte = OfInt8NByte
type OfInt8NByteSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NByte
}

func NewOfInt8NByteSt(somes OfInt8NByte) *OfInt8NByteSt {
	return &OfInt8NByteSt{
		_OfInt8NByte: somes,
	}
}

type OfInt8NComplex128If interface {
	Load(int8) (complex128, error)
}

type OfInt8NComplex128MutIf interface {
	Store(int8, complex128)
	Delete(int8)
}

type OfInt8NComplex128IterIf interface {
	Range(func(int8, complex128) bool)
}

type OfInt8NComplex128 map[int8]complex128

func (__ OfInt8NComplex128) Load(k int8) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NComplex128) Store(k int8, v complex128) {
	__[k] = v
}
func (__ OfInt8NComplex128) Delete(k int8, v complex128) {
	delete(__, k)
}
func (__ OfInt8NComplex128) Range(f func(k int8, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NComplex128 = OfInt8NComplex128
type OfInt8NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfInt8NComplex128
}

func NewOfInt8NComplex128St(somes OfInt8NComplex128) *OfInt8NComplex128St {
	return &OfInt8NComplex128St{
		_OfInt8NComplex128: somes,
	}
}

type OfInt8NComplex64If interface {
	Load(int8) (complex64, error)
}

type OfInt8NComplex64MutIf interface {
	Store(int8, complex64)
	Delete(int8)
}

type OfInt8NComplex64IterIf interface {
	Range(func(int8, complex64) bool)
}

type OfInt8NComplex64 map[int8]complex64

func (__ OfInt8NComplex64) Load(k int8) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NComplex64) Store(k int8, v complex64) {
	__[k] = v
}
func (__ OfInt8NComplex64) Delete(k int8, v complex64) {
	delete(__, k)
}
func (__ OfInt8NComplex64) Range(f func(k int8, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NComplex64 = OfInt8NComplex64
type OfInt8NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfInt8NComplex64
}

func NewOfInt8NComplex64St(somes OfInt8NComplex64) *OfInt8NComplex64St {
	return &OfInt8NComplex64St{
		_OfInt8NComplex64: somes,
	}
}

type OfInt8NErrorIf interface {
	Load(int8) (error, error)
}

type OfInt8NErrorMutIf interface {
	Store(int8, error)
	Delete(int8)
}

type OfInt8NErrorIterIf interface {
	Range(func(int8, error) bool)
}

type OfInt8NError map[int8]error

func (__ OfInt8NError) Load(k int8) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NError) Store(k int8, v error) {
	__[k] = v
}
func (__ OfInt8NError) Delete(k int8, v error) {
	delete(__, k)
}
func (__ OfInt8NError) Range(f func(k int8, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NError = OfInt8NError
type OfInt8NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NError
}

func NewOfInt8NErrorSt(somes OfInt8NError) *OfInt8NErrorSt {
	return &OfInt8NErrorSt{
		_OfInt8NError: somes,
	}
}

type OfInt8NFloat32If interface {
	Load(int8) (float32, error)
}

type OfInt8NFloat32MutIf interface {
	Store(int8, float32)
	Delete(int8)
}

type OfInt8NFloat32IterIf interface {
	Range(func(int8, float32) bool)
}

type OfInt8NFloat32 map[int8]float32

func (__ OfInt8NFloat32) Load(k int8) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NFloat32) Store(k int8, v float32) {
	__[k] = v
}
func (__ OfInt8NFloat32) Delete(k int8, v float32) {
	delete(__, k)
}
func (__ OfInt8NFloat32) Range(f func(k int8, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NFloat32 = OfInt8NFloat32
type OfInt8NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfInt8NFloat32
}

func NewOfInt8NFloat32St(somes OfInt8NFloat32) *OfInt8NFloat32St {
	return &OfInt8NFloat32St{
		_OfInt8NFloat32: somes,
	}
}

type OfInt8NFloat64If interface {
	Load(int8) (float64, error)
}

type OfInt8NFloat64MutIf interface {
	Store(int8, float64)
	Delete(int8)
}

type OfInt8NFloat64IterIf interface {
	Range(func(int8, float64) bool)
}

type OfInt8NFloat64 map[int8]float64

func (__ OfInt8NFloat64) Load(k int8) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NFloat64) Store(k int8, v float64) {
	__[k] = v
}
func (__ OfInt8NFloat64) Delete(k int8, v float64) {
	delete(__, k)
}
func (__ OfInt8NFloat64) Range(f func(k int8, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NFloat64 = OfInt8NFloat64
type OfInt8NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfInt8NFloat64
}

func NewOfInt8NFloat64St(somes OfInt8NFloat64) *OfInt8NFloat64St {
	return &OfInt8NFloat64St{
		_OfInt8NFloat64: somes,
	}
}

type OfInt8NIntIf interface {
	Load(int8) (int, error)
}

type OfInt8NIntMutIf interface {
	Store(int8, int)
	Delete(int8)
}

type OfInt8NIntIterIf interface {
	Range(func(int8, int) bool)
}

type OfInt8NInt map[int8]int

func (__ OfInt8NInt) Load(k int8) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NInt) Store(k int8, v int) {
	__[k] = v
}
func (__ OfInt8NInt) Delete(k int8, v int) {
	delete(__, k)
}
func (__ OfInt8NInt) Range(f func(k int8, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NInt = OfInt8NInt
type OfInt8NIntSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NInt
}

func NewOfInt8NIntSt(somes OfInt8NInt) *OfInt8NIntSt {
	return &OfInt8NIntSt{
		_OfInt8NInt: somes,
	}
}

type OfInt8NInt16If interface {
	Load(int8) (int16, error)
}

type OfInt8NInt16MutIf interface {
	Store(int8, int16)
	Delete(int8)
}

type OfInt8NInt16IterIf interface {
	Range(func(int8, int16) bool)
}

type OfInt8NInt16 map[int8]int16

func (__ OfInt8NInt16) Load(k int8) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NInt16) Store(k int8, v int16) {
	__[k] = v
}
func (__ OfInt8NInt16) Delete(k int8, v int16) {
	delete(__, k)
}
func (__ OfInt8NInt16) Range(f func(k int8, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NInt16 = OfInt8NInt16
type OfInt8NInt16St struct {
	// do not want to export but want to use embedding method
	_OfInt8NInt16
}

func NewOfInt8NInt16St(somes OfInt8NInt16) *OfInt8NInt16St {
	return &OfInt8NInt16St{
		_OfInt8NInt16: somes,
	}
}

type OfInt8NInt32If interface {
	Load(int8) (int32, error)
}

type OfInt8NInt32MutIf interface {
	Store(int8, int32)
	Delete(int8)
}

type OfInt8NInt32IterIf interface {
	Range(func(int8, int32) bool)
}

type OfInt8NInt32 map[int8]int32

func (__ OfInt8NInt32) Load(k int8) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NInt32) Store(k int8, v int32) {
	__[k] = v
}
func (__ OfInt8NInt32) Delete(k int8, v int32) {
	delete(__, k)
}
func (__ OfInt8NInt32) Range(f func(k int8, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NInt32 = OfInt8NInt32
type OfInt8NInt32St struct {
	// do not want to export but want to use embedding method
	_OfInt8NInt32
}

func NewOfInt8NInt32St(somes OfInt8NInt32) *OfInt8NInt32St {
	return &OfInt8NInt32St{
		_OfInt8NInt32: somes,
	}
}

type OfInt8NInt64If interface {
	Load(int8) (int64, error)
}

type OfInt8NInt64MutIf interface {
	Store(int8, int64)
	Delete(int8)
}

type OfInt8NInt64IterIf interface {
	Range(func(int8, int64) bool)
}

type OfInt8NInt64 map[int8]int64

func (__ OfInt8NInt64) Load(k int8) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NInt64) Store(k int8, v int64) {
	__[k] = v
}
func (__ OfInt8NInt64) Delete(k int8, v int64) {
	delete(__, k)
}
func (__ OfInt8NInt64) Range(f func(k int8, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NInt64 = OfInt8NInt64
type OfInt8NInt64St struct {
	// do not want to export but want to use embedding method
	_OfInt8NInt64
}

func NewOfInt8NInt64St(somes OfInt8NInt64) *OfInt8NInt64St {
	return &OfInt8NInt64St{
		_OfInt8NInt64: somes,
	}
}

type OfInt8NInt8If interface {
	Load(int8) (int8, error)
}

type OfInt8NInt8MutIf interface {
	Store(int8, int8)
	Delete(int8)
}

type OfInt8NInt8IterIf interface {
	Range(func(int8, int8) bool)
}

type OfInt8NInt8 map[int8]int8

func (__ OfInt8NInt8) Load(k int8) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NInt8) Store(k int8, v int8) {
	__[k] = v
}
func (__ OfInt8NInt8) Delete(k int8, v int8) {
	delete(__, k)
}
func (__ OfInt8NInt8) Range(f func(k int8, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NInt8 = OfInt8NInt8
type OfInt8NInt8St struct {
	// do not want to export but want to use embedding method
	_OfInt8NInt8
}

func NewOfInt8NInt8St(somes OfInt8NInt8) *OfInt8NInt8St {
	return &OfInt8NInt8St{
		_OfInt8NInt8: somes,
	}
}

type OfInt8NRuneIf interface {
	Load(int8) (rune, error)
}

type OfInt8NRuneMutIf interface {
	Store(int8, rune)
	Delete(int8)
}

type OfInt8NRuneIterIf interface {
	Range(func(int8, rune) bool)
}

type OfInt8NRune map[int8]rune

func (__ OfInt8NRune) Load(k int8) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NRune) Store(k int8, v rune) {
	__[k] = v
}
func (__ OfInt8NRune) Delete(k int8, v rune) {
	delete(__, k)
}
func (__ OfInt8NRune) Range(f func(k int8, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NRune = OfInt8NRune
type OfInt8NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NRune
}

func NewOfInt8NRuneSt(somes OfInt8NRune) *OfInt8NRuneSt {
	return &OfInt8NRuneSt{
		_OfInt8NRune: somes,
	}
}

type OfInt8NStringIf interface {
	Load(int8) (string, error)
}

type OfInt8NStringMutIf interface {
	Store(int8, string)
	Delete(int8)
}

type OfInt8NStringIterIf interface {
	Range(func(int8, string) bool)
}

type OfInt8NString map[int8]string

func (__ OfInt8NString) Load(k int8) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NString) Store(k int8, v string) {
	__[k] = v
}
func (__ OfInt8NString) Delete(k int8, v string) {
	delete(__, k)
}
func (__ OfInt8NString) Range(f func(k int8, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NString = OfInt8NString
type OfInt8NStringSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NString
}

func NewOfInt8NStringSt(somes OfInt8NString) *OfInt8NStringSt {
	return &OfInt8NStringSt{
		_OfInt8NString: somes,
	}
}

type OfInt8NUintIf interface {
	Load(int8) (uint, error)
}

type OfInt8NUintMutIf interface {
	Store(int8, uint)
	Delete(int8)
}

type OfInt8NUintIterIf interface {
	Range(func(int8, uint) bool)
}

type OfInt8NUint map[int8]uint

func (__ OfInt8NUint) Load(k int8) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NUint) Store(k int8, v uint) {
	__[k] = v
}
func (__ OfInt8NUint) Delete(k int8, v uint) {
	delete(__, k)
}
func (__ OfInt8NUint) Range(f func(k int8, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NUint = OfInt8NUint
type OfInt8NUintSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NUint
}

func NewOfInt8NUintSt(somes OfInt8NUint) *OfInt8NUintSt {
	return &OfInt8NUintSt{
		_OfInt8NUint: somes,
	}
}

type OfInt8NUint16If interface {
	Load(int8) (uint16, error)
}

type OfInt8NUint16MutIf interface {
	Store(int8, uint16)
	Delete(int8)
}

type OfInt8NUint16IterIf interface {
	Range(func(int8, uint16) bool)
}

type OfInt8NUint16 map[int8]uint16

func (__ OfInt8NUint16) Load(k int8) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NUint16) Store(k int8, v uint16) {
	__[k] = v
}
func (__ OfInt8NUint16) Delete(k int8, v uint16) {
	delete(__, k)
}
func (__ OfInt8NUint16) Range(f func(k int8, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NUint16 = OfInt8NUint16
type OfInt8NUint16St struct {
	// do not want to export but want to use embedding method
	_OfInt8NUint16
}

func NewOfInt8NUint16St(somes OfInt8NUint16) *OfInt8NUint16St {
	return &OfInt8NUint16St{
		_OfInt8NUint16: somes,
	}
}

type OfInt8NUint32If interface {
	Load(int8) (uint32, error)
}

type OfInt8NUint32MutIf interface {
	Store(int8, uint32)
	Delete(int8)
}

type OfInt8NUint32IterIf interface {
	Range(func(int8, uint32) bool)
}

type OfInt8NUint32 map[int8]uint32

func (__ OfInt8NUint32) Load(k int8) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NUint32) Store(k int8, v uint32) {
	__[k] = v
}
func (__ OfInt8NUint32) Delete(k int8, v uint32) {
	delete(__, k)
}
func (__ OfInt8NUint32) Range(f func(k int8, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NUint32 = OfInt8NUint32
type OfInt8NUint32St struct {
	// do not want to export but want to use embedding method
	_OfInt8NUint32
}

func NewOfInt8NUint32St(somes OfInt8NUint32) *OfInt8NUint32St {
	return &OfInt8NUint32St{
		_OfInt8NUint32: somes,
	}
}

type OfInt8NUint64If interface {
	Load(int8) (uint64, error)
}

type OfInt8NUint64MutIf interface {
	Store(int8, uint64)
	Delete(int8)
}

type OfInt8NUint64IterIf interface {
	Range(func(int8, uint64) bool)
}

type OfInt8NUint64 map[int8]uint64

func (__ OfInt8NUint64) Load(k int8) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NUint64) Store(k int8, v uint64) {
	__[k] = v
}
func (__ OfInt8NUint64) Delete(k int8, v uint64) {
	delete(__, k)
}
func (__ OfInt8NUint64) Range(f func(k int8, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NUint64 = OfInt8NUint64
type OfInt8NUint64St struct {
	// do not want to export but want to use embedding method
	_OfInt8NUint64
}

func NewOfInt8NUint64St(somes OfInt8NUint64) *OfInt8NUint64St {
	return &OfInt8NUint64St{
		_OfInt8NUint64: somes,
	}
}

type OfInt8NUint8If interface {
	Load(int8) (uint8, error)
}

type OfInt8NUint8MutIf interface {
	Store(int8, uint8)
	Delete(int8)
}

type OfInt8NUint8IterIf interface {
	Range(func(int8, uint8) bool)
}

type OfInt8NUint8 map[int8]uint8

func (__ OfInt8NUint8) Load(k int8) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NUint8) Store(k int8, v uint8) {
	__[k] = v
}
func (__ OfInt8NUint8) Delete(k int8, v uint8) {
	delete(__, k)
}
func (__ OfInt8NUint8) Range(f func(k int8, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NUint8 = OfInt8NUint8
type OfInt8NUint8St struct {
	// do not want to export but want to use embedding method
	_OfInt8NUint8
}

func NewOfInt8NUint8St(somes OfInt8NUint8) *OfInt8NUint8St {
	return &OfInt8NUint8St{
		_OfInt8NUint8: somes,
	}
}

type OfInt8NUintptrIf interface {
	Load(int8) (uintptr, error)
}

type OfInt8NUintptrMutIf interface {
	Store(int8, uintptr)
	Delete(int8)
}

type OfInt8NUintptrIterIf interface {
	Range(func(int8, uintptr) bool)
}

type OfInt8NUintptr map[int8]uintptr

func (__ OfInt8NUintptr) Load(k int8) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NUintptr) Store(k int8, v uintptr) {
	__[k] = v
}
func (__ OfInt8NUintptr) Delete(k int8, v uintptr) {
	delete(__, k)
}
func (__ OfInt8NUintptr) Range(f func(k int8, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NUintptr = OfInt8NUintptr
type OfInt8NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NUintptr
}

func NewOfInt8NUintptrSt(somes OfInt8NUintptr) *OfInt8NUintptrSt {
	return &OfInt8NUintptrSt{
		_OfInt8NUintptr: somes,
	}
}

type OfInt8NInterfaceIf interface {
	Load(int8) (interface{}, error)
}

type OfInt8NInterfaceMutIf interface {
	Store(int8, interface{})
	Delete(int8)
}

type OfInt8NInterfaceIterIf interface {
	Range(func(int8, interface{}) bool)
}

type OfInt8NInterface map[int8]interface{}

func (__ OfInt8NInterface) Load(k int8) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInt8NInterface) Store(k int8, v interface{}) {
	__[k] = v
}
func (__ OfInt8NInterface) Delete(k int8, v interface{}) {
	delete(__, k)
}
func (__ OfInt8NInterface) Range(f func(k int8, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInt8NInterface = OfInt8NInterface
type OfInt8NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfInt8NInterface
}

func NewOfInt8NInterfaceSt(somes OfInt8NInterface) *OfInt8NInterfaceSt {
	return &OfInt8NInterfaceSt{
		_OfInt8NInterface: somes,
	}
}

type OfRuneNBoolIf interface {
	Load(rune) (bool, error)
}

type OfRuneNBoolMutIf interface {
	Store(rune, bool)
	Delete(rune)
}

type OfRuneNBoolIterIf interface {
	Range(func(rune, bool) bool)
}

type OfRuneNBool map[rune]bool

func (__ OfRuneNBool) Load(k rune) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNBool) Store(k rune, v bool) {
	__[k] = v
}
func (__ OfRuneNBool) Delete(k rune, v bool) {
	delete(__, k)
}
func (__ OfRuneNBool) Range(f func(k rune, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNBool = OfRuneNBool
type OfRuneNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNBool
}

func NewOfRuneNBoolSt(somes OfRuneNBool) *OfRuneNBoolSt {
	return &OfRuneNBoolSt{
		_OfRuneNBool: somes,
	}
}

type OfRuneNByteIf interface {
	Load(rune) (byte, error)
}

type OfRuneNByteMutIf interface {
	Store(rune, byte)
	Delete(rune)
}

type OfRuneNByteIterIf interface {
	Range(func(rune, byte) bool)
}

type OfRuneNByte map[rune]byte

func (__ OfRuneNByte) Load(k rune) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNByte) Store(k rune, v byte) {
	__[k] = v
}
func (__ OfRuneNByte) Delete(k rune, v byte) {
	delete(__, k)
}
func (__ OfRuneNByte) Range(f func(k rune, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNByte = OfRuneNByte
type OfRuneNByteSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNByte
}

func NewOfRuneNByteSt(somes OfRuneNByte) *OfRuneNByteSt {
	return &OfRuneNByteSt{
		_OfRuneNByte: somes,
	}
}

type OfRuneNComplex128If interface {
	Load(rune) (complex128, error)
}

type OfRuneNComplex128MutIf interface {
	Store(rune, complex128)
	Delete(rune)
}

type OfRuneNComplex128IterIf interface {
	Range(func(rune, complex128) bool)
}

type OfRuneNComplex128 map[rune]complex128

func (__ OfRuneNComplex128) Load(k rune) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNComplex128) Store(k rune, v complex128) {
	__[k] = v
}
func (__ OfRuneNComplex128) Delete(k rune, v complex128) {
	delete(__, k)
}
func (__ OfRuneNComplex128) Range(f func(k rune, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNComplex128 = OfRuneNComplex128
type OfRuneNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfRuneNComplex128
}

func NewOfRuneNComplex128St(somes OfRuneNComplex128) *OfRuneNComplex128St {
	return &OfRuneNComplex128St{
		_OfRuneNComplex128: somes,
	}
}

type OfRuneNComplex64If interface {
	Load(rune) (complex64, error)
}

type OfRuneNComplex64MutIf interface {
	Store(rune, complex64)
	Delete(rune)
}

type OfRuneNComplex64IterIf interface {
	Range(func(rune, complex64) bool)
}

type OfRuneNComplex64 map[rune]complex64

func (__ OfRuneNComplex64) Load(k rune) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNComplex64) Store(k rune, v complex64) {
	__[k] = v
}
func (__ OfRuneNComplex64) Delete(k rune, v complex64) {
	delete(__, k)
}
func (__ OfRuneNComplex64) Range(f func(k rune, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNComplex64 = OfRuneNComplex64
type OfRuneNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfRuneNComplex64
}

func NewOfRuneNComplex64St(somes OfRuneNComplex64) *OfRuneNComplex64St {
	return &OfRuneNComplex64St{
		_OfRuneNComplex64: somes,
	}
}

type OfRuneNErrorIf interface {
	Load(rune) (error, error)
}

type OfRuneNErrorMutIf interface {
	Store(rune, error)
	Delete(rune)
}

type OfRuneNErrorIterIf interface {
	Range(func(rune, error) bool)
}

type OfRuneNError map[rune]error

func (__ OfRuneNError) Load(k rune) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNError) Store(k rune, v error) {
	__[k] = v
}
func (__ OfRuneNError) Delete(k rune, v error) {
	delete(__, k)
}
func (__ OfRuneNError) Range(f func(k rune, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNError = OfRuneNError
type OfRuneNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNError
}

func NewOfRuneNErrorSt(somes OfRuneNError) *OfRuneNErrorSt {
	return &OfRuneNErrorSt{
		_OfRuneNError: somes,
	}
}

type OfRuneNFloat32If interface {
	Load(rune) (float32, error)
}

type OfRuneNFloat32MutIf interface {
	Store(rune, float32)
	Delete(rune)
}

type OfRuneNFloat32IterIf interface {
	Range(func(rune, float32) bool)
}

type OfRuneNFloat32 map[rune]float32

func (__ OfRuneNFloat32) Load(k rune) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNFloat32) Store(k rune, v float32) {
	__[k] = v
}
func (__ OfRuneNFloat32) Delete(k rune, v float32) {
	delete(__, k)
}
func (__ OfRuneNFloat32) Range(f func(k rune, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNFloat32 = OfRuneNFloat32
type OfRuneNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfRuneNFloat32
}

func NewOfRuneNFloat32St(somes OfRuneNFloat32) *OfRuneNFloat32St {
	return &OfRuneNFloat32St{
		_OfRuneNFloat32: somes,
	}
}

type OfRuneNFloat64If interface {
	Load(rune) (float64, error)
}

type OfRuneNFloat64MutIf interface {
	Store(rune, float64)
	Delete(rune)
}

type OfRuneNFloat64IterIf interface {
	Range(func(rune, float64) bool)
}

type OfRuneNFloat64 map[rune]float64

func (__ OfRuneNFloat64) Load(k rune) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNFloat64) Store(k rune, v float64) {
	__[k] = v
}
func (__ OfRuneNFloat64) Delete(k rune, v float64) {
	delete(__, k)
}
func (__ OfRuneNFloat64) Range(f func(k rune, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNFloat64 = OfRuneNFloat64
type OfRuneNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfRuneNFloat64
}

func NewOfRuneNFloat64St(somes OfRuneNFloat64) *OfRuneNFloat64St {
	return &OfRuneNFloat64St{
		_OfRuneNFloat64: somes,
	}
}

type OfRuneNIntIf interface {
	Load(rune) (int, error)
}

type OfRuneNIntMutIf interface {
	Store(rune, int)
	Delete(rune)
}

type OfRuneNIntIterIf interface {
	Range(func(rune, int) bool)
}

type OfRuneNInt map[rune]int

func (__ OfRuneNInt) Load(k rune) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNInt) Store(k rune, v int) {
	__[k] = v
}
func (__ OfRuneNInt) Delete(k rune, v int) {
	delete(__, k)
}
func (__ OfRuneNInt) Range(f func(k rune, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNInt = OfRuneNInt
type OfRuneNIntSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNInt
}

func NewOfRuneNIntSt(somes OfRuneNInt) *OfRuneNIntSt {
	return &OfRuneNIntSt{
		_OfRuneNInt: somes,
	}
}

type OfRuneNInt16If interface {
	Load(rune) (int16, error)
}

type OfRuneNInt16MutIf interface {
	Store(rune, int16)
	Delete(rune)
}

type OfRuneNInt16IterIf interface {
	Range(func(rune, int16) bool)
}

type OfRuneNInt16 map[rune]int16

func (__ OfRuneNInt16) Load(k rune) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNInt16) Store(k rune, v int16) {
	__[k] = v
}
func (__ OfRuneNInt16) Delete(k rune, v int16) {
	delete(__, k)
}
func (__ OfRuneNInt16) Range(f func(k rune, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNInt16 = OfRuneNInt16
type OfRuneNInt16St struct {
	// do not want to export but want to use embedding method
	_OfRuneNInt16
}

func NewOfRuneNInt16St(somes OfRuneNInt16) *OfRuneNInt16St {
	return &OfRuneNInt16St{
		_OfRuneNInt16: somes,
	}
}

type OfRuneNInt32If interface {
	Load(rune) (int32, error)
}

type OfRuneNInt32MutIf interface {
	Store(rune, int32)
	Delete(rune)
}

type OfRuneNInt32IterIf interface {
	Range(func(rune, int32) bool)
}

type OfRuneNInt32 map[rune]int32

func (__ OfRuneNInt32) Load(k rune) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNInt32) Store(k rune, v int32) {
	__[k] = v
}
func (__ OfRuneNInt32) Delete(k rune, v int32) {
	delete(__, k)
}
func (__ OfRuneNInt32) Range(f func(k rune, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNInt32 = OfRuneNInt32
type OfRuneNInt32St struct {
	// do not want to export but want to use embedding method
	_OfRuneNInt32
}

func NewOfRuneNInt32St(somes OfRuneNInt32) *OfRuneNInt32St {
	return &OfRuneNInt32St{
		_OfRuneNInt32: somes,
	}
}

type OfRuneNInt64If interface {
	Load(rune) (int64, error)
}

type OfRuneNInt64MutIf interface {
	Store(rune, int64)
	Delete(rune)
}

type OfRuneNInt64IterIf interface {
	Range(func(rune, int64) bool)
}

type OfRuneNInt64 map[rune]int64

func (__ OfRuneNInt64) Load(k rune) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNInt64) Store(k rune, v int64) {
	__[k] = v
}
func (__ OfRuneNInt64) Delete(k rune, v int64) {
	delete(__, k)
}
func (__ OfRuneNInt64) Range(f func(k rune, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNInt64 = OfRuneNInt64
type OfRuneNInt64St struct {
	// do not want to export but want to use embedding method
	_OfRuneNInt64
}

func NewOfRuneNInt64St(somes OfRuneNInt64) *OfRuneNInt64St {
	return &OfRuneNInt64St{
		_OfRuneNInt64: somes,
	}
}

type OfRuneNInt8If interface {
	Load(rune) (int8, error)
}

type OfRuneNInt8MutIf interface {
	Store(rune, int8)
	Delete(rune)
}

type OfRuneNInt8IterIf interface {
	Range(func(rune, int8) bool)
}

type OfRuneNInt8 map[rune]int8

func (__ OfRuneNInt8) Load(k rune) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNInt8) Store(k rune, v int8) {
	__[k] = v
}
func (__ OfRuneNInt8) Delete(k rune, v int8) {
	delete(__, k)
}
func (__ OfRuneNInt8) Range(f func(k rune, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNInt8 = OfRuneNInt8
type OfRuneNInt8St struct {
	// do not want to export but want to use embedding method
	_OfRuneNInt8
}

func NewOfRuneNInt8St(somes OfRuneNInt8) *OfRuneNInt8St {
	return &OfRuneNInt8St{
		_OfRuneNInt8: somes,
	}
}

type OfRuneNRuneIf interface {
	Load(rune) (rune, error)
}

type OfRuneNRuneMutIf interface {
	Store(rune, rune)
	Delete(rune)
}

type OfRuneNRuneIterIf interface {
	Range(func(rune, rune) bool)
}

type OfRuneNRune map[rune]rune

func (__ OfRuneNRune) Load(k rune) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNRune) Store(k rune, v rune) {
	__[k] = v
}
func (__ OfRuneNRune) Delete(k rune, v rune) {
	delete(__, k)
}
func (__ OfRuneNRune) Range(f func(k rune, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNRune = OfRuneNRune
type OfRuneNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNRune
}

func NewOfRuneNRuneSt(somes OfRuneNRune) *OfRuneNRuneSt {
	return &OfRuneNRuneSt{
		_OfRuneNRune: somes,
	}
}

type OfRuneNStringIf interface {
	Load(rune) (string, error)
}

type OfRuneNStringMutIf interface {
	Store(rune, string)
	Delete(rune)
}

type OfRuneNStringIterIf interface {
	Range(func(rune, string) bool)
}

type OfRuneNString map[rune]string

func (__ OfRuneNString) Load(k rune) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNString) Store(k rune, v string) {
	__[k] = v
}
func (__ OfRuneNString) Delete(k rune, v string) {
	delete(__, k)
}
func (__ OfRuneNString) Range(f func(k rune, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNString = OfRuneNString
type OfRuneNStringSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNString
}

func NewOfRuneNStringSt(somes OfRuneNString) *OfRuneNStringSt {
	return &OfRuneNStringSt{
		_OfRuneNString: somes,
	}
}

type OfRuneNUintIf interface {
	Load(rune) (uint, error)
}

type OfRuneNUintMutIf interface {
	Store(rune, uint)
	Delete(rune)
}

type OfRuneNUintIterIf interface {
	Range(func(rune, uint) bool)
}

type OfRuneNUint map[rune]uint

func (__ OfRuneNUint) Load(k rune) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNUint) Store(k rune, v uint) {
	__[k] = v
}
func (__ OfRuneNUint) Delete(k rune, v uint) {
	delete(__, k)
}
func (__ OfRuneNUint) Range(f func(k rune, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNUint = OfRuneNUint
type OfRuneNUintSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNUint
}

func NewOfRuneNUintSt(somes OfRuneNUint) *OfRuneNUintSt {
	return &OfRuneNUintSt{
		_OfRuneNUint: somes,
	}
}

type OfRuneNUint16If interface {
	Load(rune) (uint16, error)
}

type OfRuneNUint16MutIf interface {
	Store(rune, uint16)
	Delete(rune)
}

type OfRuneNUint16IterIf interface {
	Range(func(rune, uint16) bool)
}

type OfRuneNUint16 map[rune]uint16

func (__ OfRuneNUint16) Load(k rune) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNUint16) Store(k rune, v uint16) {
	__[k] = v
}
func (__ OfRuneNUint16) Delete(k rune, v uint16) {
	delete(__, k)
}
func (__ OfRuneNUint16) Range(f func(k rune, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNUint16 = OfRuneNUint16
type OfRuneNUint16St struct {
	// do not want to export but want to use embedding method
	_OfRuneNUint16
}

func NewOfRuneNUint16St(somes OfRuneNUint16) *OfRuneNUint16St {
	return &OfRuneNUint16St{
		_OfRuneNUint16: somes,
	}
}

type OfRuneNUint32If interface {
	Load(rune) (uint32, error)
}

type OfRuneNUint32MutIf interface {
	Store(rune, uint32)
	Delete(rune)
}

type OfRuneNUint32IterIf interface {
	Range(func(rune, uint32) bool)
}

type OfRuneNUint32 map[rune]uint32

func (__ OfRuneNUint32) Load(k rune) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNUint32) Store(k rune, v uint32) {
	__[k] = v
}
func (__ OfRuneNUint32) Delete(k rune, v uint32) {
	delete(__, k)
}
func (__ OfRuneNUint32) Range(f func(k rune, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNUint32 = OfRuneNUint32
type OfRuneNUint32St struct {
	// do not want to export but want to use embedding method
	_OfRuneNUint32
}

func NewOfRuneNUint32St(somes OfRuneNUint32) *OfRuneNUint32St {
	return &OfRuneNUint32St{
		_OfRuneNUint32: somes,
	}
}

type OfRuneNUint64If interface {
	Load(rune) (uint64, error)
}

type OfRuneNUint64MutIf interface {
	Store(rune, uint64)
	Delete(rune)
}

type OfRuneNUint64IterIf interface {
	Range(func(rune, uint64) bool)
}

type OfRuneNUint64 map[rune]uint64

func (__ OfRuneNUint64) Load(k rune) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNUint64) Store(k rune, v uint64) {
	__[k] = v
}
func (__ OfRuneNUint64) Delete(k rune, v uint64) {
	delete(__, k)
}
func (__ OfRuneNUint64) Range(f func(k rune, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNUint64 = OfRuneNUint64
type OfRuneNUint64St struct {
	// do not want to export but want to use embedding method
	_OfRuneNUint64
}

func NewOfRuneNUint64St(somes OfRuneNUint64) *OfRuneNUint64St {
	return &OfRuneNUint64St{
		_OfRuneNUint64: somes,
	}
}

type OfRuneNUint8If interface {
	Load(rune) (uint8, error)
}

type OfRuneNUint8MutIf interface {
	Store(rune, uint8)
	Delete(rune)
}

type OfRuneNUint8IterIf interface {
	Range(func(rune, uint8) bool)
}

type OfRuneNUint8 map[rune]uint8

func (__ OfRuneNUint8) Load(k rune) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNUint8) Store(k rune, v uint8) {
	__[k] = v
}
func (__ OfRuneNUint8) Delete(k rune, v uint8) {
	delete(__, k)
}
func (__ OfRuneNUint8) Range(f func(k rune, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNUint8 = OfRuneNUint8
type OfRuneNUint8St struct {
	// do not want to export but want to use embedding method
	_OfRuneNUint8
}

func NewOfRuneNUint8St(somes OfRuneNUint8) *OfRuneNUint8St {
	return &OfRuneNUint8St{
		_OfRuneNUint8: somes,
	}
}

type OfRuneNUintptrIf interface {
	Load(rune) (uintptr, error)
}

type OfRuneNUintptrMutIf interface {
	Store(rune, uintptr)
	Delete(rune)
}

type OfRuneNUintptrIterIf interface {
	Range(func(rune, uintptr) bool)
}

type OfRuneNUintptr map[rune]uintptr

func (__ OfRuneNUintptr) Load(k rune) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNUintptr) Store(k rune, v uintptr) {
	__[k] = v
}
func (__ OfRuneNUintptr) Delete(k rune, v uintptr) {
	delete(__, k)
}
func (__ OfRuneNUintptr) Range(f func(k rune, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNUintptr = OfRuneNUintptr
type OfRuneNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNUintptr
}

func NewOfRuneNUintptrSt(somes OfRuneNUintptr) *OfRuneNUintptrSt {
	return &OfRuneNUintptrSt{
		_OfRuneNUintptr: somes,
	}
}

type OfRuneNInterfaceIf interface {
	Load(rune) (interface{}, error)
}

type OfRuneNInterfaceMutIf interface {
	Store(rune, interface{})
	Delete(rune)
}

type OfRuneNInterfaceIterIf interface {
	Range(func(rune, interface{}) bool)
}

type OfRuneNInterface map[rune]interface{}

func (__ OfRuneNInterface) Load(k rune) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfRuneNInterface) Store(k rune, v interface{}) {
	__[k] = v
}
func (__ OfRuneNInterface) Delete(k rune, v interface{}) {
	delete(__, k)
}
func (__ OfRuneNInterface) Range(f func(k rune, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfRuneNInterface = OfRuneNInterface
type OfRuneNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfRuneNInterface
}

func NewOfRuneNInterfaceSt(somes OfRuneNInterface) *OfRuneNInterfaceSt {
	return &OfRuneNInterfaceSt{
		_OfRuneNInterface: somes,
	}
}

type OfStringNBoolIf interface {
	Load(string) (bool, error)
}

type OfStringNBoolMutIf interface {
	Store(string, bool)
	Delete(string)
}

type OfStringNBoolIterIf interface {
	Range(func(string, bool) bool)
}

type OfStringNBool map[string]bool

func (__ OfStringNBool) Load(k string) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNBool) Store(k string, v bool) {
	__[k] = v
}
func (__ OfStringNBool) Delete(k string, v bool) {
	delete(__, k)
}
func (__ OfStringNBool) Range(f func(k string, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNBool = OfStringNBool
type OfStringNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfStringNBool
}

func NewOfStringNBoolSt(somes OfStringNBool) *OfStringNBoolSt {
	return &OfStringNBoolSt{
		_OfStringNBool: somes,
	}
}

type OfStringNByteIf interface {
	Load(string) (byte, error)
}

type OfStringNByteMutIf interface {
	Store(string, byte)
	Delete(string)
}

type OfStringNByteIterIf interface {
	Range(func(string, byte) bool)
}

type OfStringNByte map[string]byte

func (__ OfStringNByte) Load(k string) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNByte) Store(k string, v byte) {
	__[k] = v
}
func (__ OfStringNByte) Delete(k string, v byte) {
	delete(__, k)
}
func (__ OfStringNByte) Range(f func(k string, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNByte = OfStringNByte
type OfStringNByteSt struct {
	// do not want to export but want to use embedding method
	_OfStringNByte
}

func NewOfStringNByteSt(somes OfStringNByte) *OfStringNByteSt {
	return &OfStringNByteSt{
		_OfStringNByte: somes,
	}
}

type OfStringNComplex128If interface {
	Load(string) (complex128, error)
}

type OfStringNComplex128MutIf interface {
	Store(string, complex128)
	Delete(string)
}

type OfStringNComplex128IterIf interface {
	Range(func(string, complex128) bool)
}

type OfStringNComplex128 map[string]complex128

func (__ OfStringNComplex128) Load(k string) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNComplex128) Store(k string, v complex128) {
	__[k] = v
}
func (__ OfStringNComplex128) Delete(k string, v complex128) {
	delete(__, k)
}
func (__ OfStringNComplex128) Range(f func(k string, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNComplex128 = OfStringNComplex128
type OfStringNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfStringNComplex128
}

func NewOfStringNComplex128St(somes OfStringNComplex128) *OfStringNComplex128St {
	return &OfStringNComplex128St{
		_OfStringNComplex128: somes,
	}
}

type OfStringNComplex64If interface {
	Load(string) (complex64, error)
}

type OfStringNComplex64MutIf interface {
	Store(string, complex64)
	Delete(string)
}

type OfStringNComplex64IterIf interface {
	Range(func(string, complex64) bool)
}

type OfStringNComplex64 map[string]complex64

func (__ OfStringNComplex64) Load(k string) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNComplex64) Store(k string, v complex64) {
	__[k] = v
}
func (__ OfStringNComplex64) Delete(k string, v complex64) {
	delete(__, k)
}
func (__ OfStringNComplex64) Range(f func(k string, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNComplex64 = OfStringNComplex64
type OfStringNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfStringNComplex64
}

func NewOfStringNComplex64St(somes OfStringNComplex64) *OfStringNComplex64St {
	return &OfStringNComplex64St{
		_OfStringNComplex64: somes,
	}
}

type OfStringNErrorIf interface {
	Load(string) (error, error)
}

type OfStringNErrorMutIf interface {
	Store(string, error)
	Delete(string)
}

type OfStringNErrorIterIf interface {
	Range(func(string, error) bool)
}

type OfStringNError map[string]error

func (__ OfStringNError) Load(k string) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNError) Store(k string, v error) {
	__[k] = v
}
func (__ OfStringNError) Delete(k string, v error) {
	delete(__, k)
}
func (__ OfStringNError) Range(f func(k string, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNError = OfStringNError
type OfStringNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfStringNError
}

func NewOfStringNErrorSt(somes OfStringNError) *OfStringNErrorSt {
	return &OfStringNErrorSt{
		_OfStringNError: somes,
	}
}

type OfStringNFloat32If interface {
	Load(string) (float32, error)
}

type OfStringNFloat32MutIf interface {
	Store(string, float32)
	Delete(string)
}

type OfStringNFloat32IterIf interface {
	Range(func(string, float32) bool)
}

type OfStringNFloat32 map[string]float32

func (__ OfStringNFloat32) Load(k string) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNFloat32) Store(k string, v float32) {
	__[k] = v
}
func (__ OfStringNFloat32) Delete(k string, v float32) {
	delete(__, k)
}
func (__ OfStringNFloat32) Range(f func(k string, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNFloat32 = OfStringNFloat32
type OfStringNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfStringNFloat32
}

func NewOfStringNFloat32St(somes OfStringNFloat32) *OfStringNFloat32St {
	return &OfStringNFloat32St{
		_OfStringNFloat32: somes,
	}
}

type OfStringNFloat64If interface {
	Load(string) (float64, error)
}

type OfStringNFloat64MutIf interface {
	Store(string, float64)
	Delete(string)
}

type OfStringNFloat64IterIf interface {
	Range(func(string, float64) bool)
}

type OfStringNFloat64 map[string]float64

func (__ OfStringNFloat64) Load(k string) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNFloat64) Store(k string, v float64) {
	__[k] = v
}
func (__ OfStringNFloat64) Delete(k string, v float64) {
	delete(__, k)
}
func (__ OfStringNFloat64) Range(f func(k string, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNFloat64 = OfStringNFloat64
type OfStringNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfStringNFloat64
}

func NewOfStringNFloat64St(somes OfStringNFloat64) *OfStringNFloat64St {
	return &OfStringNFloat64St{
		_OfStringNFloat64: somes,
	}
}

type OfStringNIntIf interface {
	Load(string) (int, error)
}

type OfStringNIntMutIf interface {
	Store(string, int)
	Delete(string)
}

type OfStringNIntIterIf interface {
	Range(func(string, int) bool)
}

type OfStringNInt map[string]int

func (__ OfStringNInt) Load(k string) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNInt) Store(k string, v int) {
	__[k] = v
}
func (__ OfStringNInt) Delete(k string, v int) {
	delete(__, k)
}
func (__ OfStringNInt) Range(f func(k string, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNInt = OfStringNInt
type OfStringNIntSt struct {
	// do not want to export but want to use embedding method
	_OfStringNInt
}

func NewOfStringNIntSt(somes OfStringNInt) *OfStringNIntSt {
	return &OfStringNIntSt{
		_OfStringNInt: somes,
	}
}

type OfStringNInt16If interface {
	Load(string) (int16, error)
}

type OfStringNInt16MutIf interface {
	Store(string, int16)
	Delete(string)
}

type OfStringNInt16IterIf interface {
	Range(func(string, int16) bool)
}

type OfStringNInt16 map[string]int16

func (__ OfStringNInt16) Load(k string) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNInt16) Store(k string, v int16) {
	__[k] = v
}
func (__ OfStringNInt16) Delete(k string, v int16) {
	delete(__, k)
}
func (__ OfStringNInt16) Range(f func(k string, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNInt16 = OfStringNInt16
type OfStringNInt16St struct {
	// do not want to export but want to use embedding method
	_OfStringNInt16
}

func NewOfStringNInt16St(somes OfStringNInt16) *OfStringNInt16St {
	return &OfStringNInt16St{
		_OfStringNInt16: somes,
	}
}

type OfStringNInt32If interface {
	Load(string) (int32, error)
}

type OfStringNInt32MutIf interface {
	Store(string, int32)
	Delete(string)
}

type OfStringNInt32IterIf interface {
	Range(func(string, int32) bool)
}

type OfStringNInt32 map[string]int32

func (__ OfStringNInt32) Load(k string) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNInt32) Store(k string, v int32) {
	__[k] = v
}
func (__ OfStringNInt32) Delete(k string, v int32) {
	delete(__, k)
}
func (__ OfStringNInt32) Range(f func(k string, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNInt32 = OfStringNInt32
type OfStringNInt32St struct {
	// do not want to export but want to use embedding method
	_OfStringNInt32
}

func NewOfStringNInt32St(somes OfStringNInt32) *OfStringNInt32St {
	return &OfStringNInt32St{
		_OfStringNInt32: somes,
	}
}

type OfStringNInt64If interface {
	Load(string) (int64, error)
}

type OfStringNInt64MutIf interface {
	Store(string, int64)
	Delete(string)
}

type OfStringNInt64IterIf interface {
	Range(func(string, int64) bool)
}

type OfStringNInt64 map[string]int64

func (__ OfStringNInt64) Load(k string) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNInt64) Store(k string, v int64) {
	__[k] = v
}
func (__ OfStringNInt64) Delete(k string, v int64) {
	delete(__, k)
}
func (__ OfStringNInt64) Range(f func(k string, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNInt64 = OfStringNInt64
type OfStringNInt64St struct {
	// do not want to export but want to use embedding method
	_OfStringNInt64
}

func NewOfStringNInt64St(somes OfStringNInt64) *OfStringNInt64St {
	return &OfStringNInt64St{
		_OfStringNInt64: somes,
	}
}

type OfStringNInt8If interface {
	Load(string) (int8, error)
}

type OfStringNInt8MutIf interface {
	Store(string, int8)
	Delete(string)
}

type OfStringNInt8IterIf interface {
	Range(func(string, int8) bool)
}

type OfStringNInt8 map[string]int8

func (__ OfStringNInt8) Load(k string) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNInt8) Store(k string, v int8) {
	__[k] = v
}
func (__ OfStringNInt8) Delete(k string, v int8) {
	delete(__, k)
}
func (__ OfStringNInt8) Range(f func(k string, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNInt8 = OfStringNInt8
type OfStringNInt8St struct {
	// do not want to export but want to use embedding method
	_OfStringNInt8
}

func NewOfStringNInt8St(somes OfStringNInt8) *OfStringNInt8St {
	return &OfStringNInt8St{
		_OfStringNInt8: somes,
	}
}

type OfStringNRuneIf interface {
	Load(string) (rune, error)
}

type OfStringNRuneMutIf interface {
	Store(string, rune)
	Delete(string)
}

type OfStringNRuneIterIf interface {
	Range(func(string, rune) bool)
}

type OfStringNRune map[string]rune

func (__ OfStringNRune) Load(k string) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNRune) Store(k string, v rune) {
	__[k] = v
}
func (__ OfStringNRune) Delete(k string, v rune) {
	delete(__, k)
}
func (__ OfStringNRune) Range(f func(k string, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNRune = OfStringNRune
type OfStringNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfStringNRune
}

func NewOfStringNRuneSt(somes OfStringNRune) *OfStringNRuneSt {
	return &OfStringNRuneSt{
		_OfStringNRune: somes,
	}
}

type OfStringNStringIf interface {
	Load(string) (string, error)
}

type OfStringNStringMutIf interface {
	Store(string, string)
	Delete(string)
}

type OfStringNStringIterIf interface {
	Range(func(string, string) bool)
}

type OfStringNString map[string]string

func (__ OfStringNString) Load(k string) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNString) Store(k string, v string) {
	__[k] = v
}
func (__ OfStringNString) Delete(k string, v string) {
	delete(__, k)
}
func (__ OfStringNString) Range(f func(k string, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNString = OfStringNString
type OfStringNStringSt struct {
	// do not want to export but want to use embedding method
	_OfStringNString
}

func NewOfStringNStringSt(somes OfStringNString) *OfStringNStringSt {
	return &OfStringNStringSt{
		_OfStringNString: somes,
	}
}

type OfStringNUintIf interface {
	Load(string) (uint, error)
}

type OfStringNUintMutIf interface {
	Store(string, uint)
	Delete(string)
}

type OfStringNUintIterIf interface {
	Range(func(string, uint) bool)
}

type OfStringNUint map[string]uint

func (__ OfStringNUint) Load(k string) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNUint) Store(k string, v uint) {
	__[k] = v
}
func (__ OfStringNUint) Delete(k string, v uint) {
	delete(__, k)
}
func (__ OfStringNUint) Range(f func(k string, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNUint = OfStringNUint
type OfStringNUintSt struct {
	// do not want to export but want to use embedding method
	_OfStringNUint
}

func NewOfStringNUintSt(somes OfStringNUint) *OfStringNUintSt {
	return &OfStringNUintSt{
		_OfStringNUint: somes,
	}
}

type OfStringNUint16If interface {
	Load(string) (uint16, error)
}

type OfStringNUint16MutIf interface {
	Store(string, uint16)
	Delete(string)
}

type OfStringNUint16IterIf interface {
	Range(func(string, uint16) bool)
}

type OfStringNUint16 map[string]uint16

func (__ OfStringNUint16) Load(k string) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNUint16) Store(k string, v uint16) {
	__[k] = v
}
func (__ OfStringNUint16) Delete(k string, v uint16) {
	delete(__, k)
}
func (__ OfStringNUint16) Range(f func(k string, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNUint16 = OfStringNUint16
type OfStringNUint16St struct {
	// do not want to export but want to use embedding method
	_OfStringNUint16
}

func NewOfStringNUint16St(somes OfStringNUint16) *OfStringNUint16St {
	return &OfStringNUint16St{
		_OfStringNUint16: somes,
	}
}

type OfStringNUint32If interface {
	Load(string) (uint32, error)
}

type OfStringNUint32MutIf interface {
	Store(string, uint32)
	Delete(string)
}

type OfStringNUint32IterIf interface {
	Range(func(string, uint32) bool)
}

type OfStringNUint32 map[string]uint32

func (__ OfStringNUint32) Load(k string) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNUint32) Store(k string, v uint32) {
	__[k] = v
}
func (__ OfStringNUint32) Delete(k string, v uint32) {
	delete(__, k)
}
func (__ OfStringNUint32) Range(f func(k string, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNUint32 = OfStringNUint32
type OfStringNUint32St struct {
	// do not want to export but want to use embedding method
	_OfStringNUint32
}

func NewOfStringNUint32St(somes OfStringNUint32) *OfStringNUint32St {
	return &OfStringNUint32St{
		_OfStringNUint32: somes,
	}
}

type OfStringNUint64If interface {
	Load(string) (uint64, error)
}

type OfStringNUint64MutIf interface {
	Store(string, uint64)
	Delete(string)
}

type OfStringNUint64IterIf interface {
	Range(func(string, uint64) bool)
}

type OfStringNUint64 map[string]uint64

func (__ OfStringNUint64) Load(k string) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNUint64) Store(k string, v uint64) {
	__[k] = v
}
func (__ OfStringNUint64) Delete(k string, v uint64) {
	delete(__, k)
}
func (__ OfStringNUint64) Range(f func(k string, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNUint64 = OfStringNUint64
type OfStringNUint64St struct {
	// do not want to export but want to use embedding method
	_OfStringNUint64
}

func NewOfStringNUint64St(somes OfStringNUint64) *OfStringNUint64St {
	return &OfStringNUint64St{
		_OfStringNUint64: somes,
	}
}

type OfStringNUint8If interface {
	Load(string) (uint8, error)
}

type OfStringNUint8MutIf interface {
	Store(string, uint8)
	Delete(string)
}

type OfStringNUint8IterIf interface {
	Range(func(string, uint8) bool)
}

type OfStringNUint8 map[string]uint8

func (__ OfStringNUint8) Load(k string) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNUint8) Store(k string, v uint8) {
	__[k] = v
}
func (__ OfStringNUint8) Delete(k string, v uint8) {
	delete(__, k)
}
func (__ OfStringNUint8) Range(f func(k string, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNUint8 = OfStringNUint8
type OfStringNUint8St struct {
	// do not want to export but want to use embedding method
	_OfStringNUint8
}

func NewOfStringNUint8St(somes OfStringNUint8) *OfStringNUint8St {
	return &OfStringNUint8St{
		_OfStringNUint8: somes,
	}
}

type OfStringNUintptrIf interface {
	Load(string) (uintptr, error)
}

type OfStringNUintptrMutIf interface {
	Store(string, uintptr)
	Delete(string)
}

type OfStringNUintptrIterIf interface {
	Range(func(string, uintptr) bool)
}

type OfStringNUintptr map[string]uintptr

func (__ OfStringNUintptr) Load(k string) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNUintptr) Store(k string, v uintptr) {
	__[k] = v
}
func (__ OfStringNUintptr) Delete(k string, v uintptr) {
	delete(__, k)
}
func (__ OfStringNUintptr) Range(f func(k string, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNUintptr = OfStringNUintptr
type OfStringNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfStringNUintptr
}

func NewOfStringNUintptrSt(somes OfStringNUintptr) *OfStringNUintptrSt {
	return &OfStringNUintptrSt{
		_OfStringNUintptr: somes,
	}
}

type OfStringNInterfaceIf interface {
	Load(string) (interface{}, error)
}

type OfStringNInterfaceMutIf interface {
	Store(string, interface{})
	Delete(string)
}

type OfStringNInterfaceIterIf interface {
	Range(func(string, interface{}) bool)
}

type OfStringNInterface map[string]interface{}

func (__ OfStringNInterface) Load(k string) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfStringNInterface) Store(k string, v interface{}) {
	__[k] = v
}
func (__ OfStringNInterface) Delete(k string, v interface{}) {
	delete(__, k)
}
func (__ OfStringNInterface) Range(f func(k string, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfStringNInterface = OfStringNInterface
type OfStringNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfStringNInterface
}

func NewOfStringNInterfaceSt(somes OfStringNInterface) *OfStringNInterfaceSt {
	return &OfStringNInterfaceSt{
		_OfStringNInterface: somes,
	}
}

type OfUintNBoolIf interface {
	Load(uint) (bool, error)
}

type OfUintNBoolMutIf interface {
	Store(uint, bool)
	Delete(uint)
}

type OfUintNBoolIterIf interface {
	Range(func(uint, bool) bool)
}

type OfUintNBool map[uint]bool

func (__ OfUintNBool) Load(k uint) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNBool) Store(k uint, v bool) {
	__[k] = v
}
func (__ OfUintNBool) Delete(k uint, v bool) {
	delete(__, k)
}
func (__ OfUintNBool) Range(f func(k uint, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNBool = OfUintNBool
type OfUintNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfUintNBool
}

func NewOfUintNBoolSt(somes OfUintNBool) *OfUintNBoolSt {
	return &OfUintNBoolSt{
		_OfUintNBool: somes,
	}
}

type OfUintNByteIf interface {
	Load(uint) (byte, error)
}

type OfUintNByteMutIf interface {
	Store(uint, byte)
	Delete(uint)
}

type OfUintNByteIterIf interface {
	Range(func(uint, byte) bool)
}

type OfUintNByte map[uint]byte

func (__ OfUintNByte) Load(k uint) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNByte) Store(k uint, v byte) {
	__[k] = v
}
func (__ OfUintNByte) Delete(k uint, v byte) {
	delete(__, k)
}
func (__ OfUintNByte) Range(f func(k uint, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNByte = OfUintNByte
type OfUintNByteSt struct {
	// do not want to export but want to use embedding method
	_OfUintNByte
}

func NewOfUintNByteSt(somes OfUintNByte) *OfUintNByteSt {
	return &OfUintNByteSt{
		_OfUintNByte: somes,
	}
}

type OfUintNComplex128If interface {
	Load(uint) (complex128, error)
}

type OfUintNComplex128MutIf interface {
	Store(uint, complex128)
	Delete(uint)
}

type OfUintNComplex128IterIf interface {
	Range(func(uint, complex128) bool)
}

type OfUintNComplex128 map[uint]complex128

func (__ OfUintNComplex128) Load(k uint) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNComplex128) Store(k uint, v complex128) {
	__[k] = v
}
func (__ OfUintNComplex128) Delete(k uint, v complex128) {
	delete(__, k)
}
func (__ OfUintNComplex128) Range(f func(k uint, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNComplex128 = OfUintNComplex128
type OfUintNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfUintNComplex128
}

func NewOfUintNComplex128St(somes OfUintNComplex128) *OfUintNComplex128St {
	return &OfUintNComplex128St{
		_OfUintNComplex128: somes,
	}
}

type OfUintNComplex64If interface {
	Load(uint) (complex64, error)
}

type OfUintNComplex64MutIf interface {
	Store(uint, complex64)
	Delete(uint)
}

type OfUintNComplex64IterIf interface {
	Range(func(uint, complex64) bool)
}

type OfUintNComplex64 map[uint]complex64

func (__ OfUintNComplex64) Load(k uint) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNComplex64) Store(k uint, v complex64) {
	__[k] = v
}
func (__ OfUintNComplex64) Delete(k uint, v complex64) {
	delete(__, k)
}
func (__ OfUintNComplex64) Range(f func(k uint, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNComplex64 = OfUintNComplex64
type OfUintNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfUintNComplex64
}

func NewOfUintNComplex64St(somes OfUintNComplex64) *OfUintNComplex64St {
	return &OfUintNComplex64St{
		_OfUintNComplex64: somes,
	}
}

type OfUintNErrorIf interface {
	Load(uint) (error, error)
}

type OfUintNErrorMutIf interface {
	Store(uint, error)
	Delete(uint)
}

type OfUintNErrorIterIf interface {
	Range(func(uint, error) bool)
}

type OfUintNError map[uint]error

func (__ OfUintNError) Load(k uint) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNError) Store(k uint, v error) {
	__[k] = v
}
func (__ OfUintNError) Delete(k uint, v error) {
	delete(__, k)
}
func (__ OfUintNError) Range(f func(k uint, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNError = OfUintNError
type OfUintNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfUintNError
}

func NewOfUintNErrorSt(somes OfUintNError) *OfUintNErrorSt {
	return &OfUintNErrorSt{
		_OfUintNError: somes,
	}
}

type OfUintNFloat32If interface {
	Load(uint) (float32, error)
}

type OfUintNFloat32MutIf interface {
	Store(uint, float32)
	Delete(uint)
}

type OfUintNFloat32IterIf interface {
	Range(func(uint, float32) bool)
}

type OfUintNFloat32 map[uint]float32

func (__ OfUintNFloat32) Load(k uint) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNFloat32) Store(k uint, v float32) {
	__[k] = v
}
func (__ OfUintNFloat32) Delete(k uint, v float32) {
	delete(__, k)
}
func (__ OfUintNFloat32) Range(f func(k uint, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNFloat32 = OfUintNFloat32
type OfUintNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfUintNFloat32
}

func NewOfUintNFloat32St(somes OfUintNFloat32) *OfUintNFloat32St {
	return &OfUintNFloat32St{
		_OfUintNFloat32: somes,
	}
}

type OfUintNFloat64If interface {
	Load(uint) (float64, error)
}

type OfUintNFloat64MutIf interface {
	Store(uint, float64)
	Delete(uint)
}

type OfUintNFloat64IterIf interface {
	Range(func(uint, float64) bool)
}

type OfUintNFloat64 map[uint]float64

func (__ OfUintNFloat64) Load(k uint) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNFloat64) Store(k uint, v float64) {
	__[k] = v
}
func (__ OfUintNFloat64) Delete(k uint, v float64) {
	delete(__, k)
}
func (__ OfUintNFloat64) Range(f func(k uint, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNFloat64 = OfUintNFloat64
type OfUintNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfUintNFloat64
}

func NewOfUintNFloat64St(somes OfUintNFloat64) *OfUintNFloat64St {
	return &OfUintNFloat64St{
		_OfUintNFloat64: somes,
	}
}

type OfUintNIntIf interface {
	Load(uint) (int, error)
}

type OfUintNIntMutIf interface {
	Store(uint, int)
	Delete(uint)
}

type OfUintNIntIterIf interface {
	Range(func(uint, int) bool)
}

type OfUintNInt map[uint]int

func (__ OfUintNInt) Load(k uint) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNInt) Store(k uint, v int) {
	__[k] = v
}
func (__ OfUintNInt) Delete(k uint, v int) {
	delete(__, k)
}
func (__ OfUintNInt) Range(f func(k uint, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNInt = OfUintNInt
type OfUintNIntSt struct {
	// do not want to export but want to use embedding method
	_OfUintNInt
}

func NewOfUintNIntSt(somes OfUintNInt) *OfUintNIntSt {
	return &OfUintNIntSt{
		_OfUintNInt: somes,
	}
}

type OfUintNInt16If interface {
	Load(uint) (int16, error)
}

type OfUintNInt16MutIf interface {
	Store(uint, int16)
	Delete(uint)
}

type OfUintNInt16IterIf interface {
	Range(func(uint, int16) bool)
}

type OfUintNInt16 map[uint]int16

func (__ OfUintNInt16) Load(k uint) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNInt16) Store(k uint, v int16) {
	__[k] = v
}
func (__ OfUintNInt16) Delete(k uint, v int16) {
	delete(__, k)
}
func (__ OfUintNInt16) Range(f func(k uint, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNInt16 = OfUintNInt16
type OfUintNInt16St struct {
	// do not want to export but want to use embedding method
	_OfUintNInt16
}

func NewOfUintNInt16St(somes OfUintNInt16) *OfUintNInt16St {
	return &OfUintNInt16St{
		_OfUintNInt16: somes,
	}
}

type OfUintNInt32If interface {
	Load(uint) (int32, error)
}

type OfUintNInt32MutIf interface {
	Store(uint, int32)
	Delete(uint)
}

type OfUintNInt32IterIf interface {
	Range(func(uint, int32) bool)
}

type OfUintNInt32 map[uint]int32

func (__ OfUintNInt32) Load(k uint) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNInt32) Store(k uint, v int32) {
	__[k] = v
}
func (__ OfUintNInt32) Delete(k uint, v int32) {
	delete(__, k)
}
func (__ OfUintNInt32) Range(f func(k uint, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNInt32 = OfUintNInt32
type OfUintNInt32St struct {
	// do not want to export but want to use embedding method
	_OfUintNInt32
}

func NewOfUintNInt32St(somes OfUintNInt32) *OfUintNInt32St {
	return &OfUintNInt32St{
		_OfUintNInt32: somes,
	}
}

type OfUintNInt64If interface {
	Load(uint) (int64, error)
}

type OfUintNInt64MutIf interface {
	Store(uint, int64)
	Delete(uint)
}

type OfUintNInt64IterIf interface {
	Range(func(uint, int64) bool)
}

type OfUintNInt64 map[uint]int64

func (__ OfUintNInt64) Load(k uint) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNInt64) Store(k uint, v int64) {
	__[k] = v
}
func (__ OfUintNInt64) Delete(k uint, v int64) {
	delete(__, k)
}
func (__ OfUintNInt64) Range(f func(k uint, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNInt64 = OfUintNInt64
type OfUintNInt64St struct {
	// do not want to export but want to use embedding method
	_OfUintNInt64
}

func NewOfUintNInt64St(somes OfUintNInt64) *OfUintNInt64St {
	return &OfUintNInt64St{
		_OfUintNInt64: somes,
	}
}

type OfUintNInt8If interface {
	Load(uint) (int8, error)
}

type OfUintNInt8MutIf interface {
	Store(uint, int8)
	Delete(uint)
}

type OfUintNInt8IterIf interface {
	Range(func(uint, int8) bool)
}

type OfUintNInt8 map[uint]int8

func (__ OfUintNInt8) Load(k uint) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNInt8) Store(k uint, v int8) {
	__[k] = v
}
func (__ OfUintNInt8) Delete(k uint, v int8) {
	delete(__, k)
}
func (__ OfUintNInt8) Range(f func(k uint, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNInt8 = OfUintNInt8
type OfUintNInt8St struct {
	// do not want to export but want to use embedding method
	_OfUintNInt8
}

func NewOfUintNInt8St(somes OfUintNInt8) *OfUintNInt8St {
	return &OfUintNInt8St{
		_OfUintNInt8: somes,
	}
}

type OfUintNRuneIf interface {
	Load(uint) (rune, error)
}

type OfUintNRuneMutIf interface {
	Store(uint, rune)
	Delete(uint)
}

type OfUintNRuneIterIf interface {
	Range(func(uint, rune) bool)
}

type OfUintNRune map[uint]rune

func (__ OfUintNRune) Load(k uint) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNRune) Store(k uint, v rune) {
	__[k] = v
}
func (__ OfUintNRune) Delete(k uint, v rune) {
	delete(__, k)
}
func (__ OfUintNRune) Range(f func(k uint, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNRune = OfUintNRune
type OfUintNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfUintNRune
}

func NewOfUintNRuneSt(somes OfUintNRune) *OfUintNRuneSt {
	return &OfUintNRuneSt{
		_OfUintNRune: somes,
	}
}

type OfUintNStringIf interface {
	Load(uint) (string, error)
}

type OfUintNStringMutIf interface {
	Store(uint, string)
	Delete(uint)
}

type OfUintNStringIterIf interface {
	Range(func(uint, string) bool)
}

type OfUintNString map[uint]string

func (__ OfUintNString) Load(k uint) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNString) Store(k uint, v string) {
	__[k] = v
}
func (__ OfUintNString) Delete(k uint, v string) {
	delete(__, k)
}
func (__ OfUintNString) Range(f func(k uint, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNString = OfUintNString
type OfUintNStringSt struct {
	// do not want to export but want to use embedding method
	_OfUintNString
}

func NewOfUintNStringSt(somes OfUintNString) *OfUintNStringSt {
	return &OfUintNStringSt{
		_OfUintNString: somes,
	}
}

type OfUintNUintIf interface {
	Load(uint) (uint, error)
}

type OfUintNUintMutIf interface {
	Store(uint, uint)
	Delete(uint)
}

type OfUintNUintIterIf interface {
	Range(func(uint, uint) bool)
}

type OfUintNUint map[uint]uint

func (__ OfUintNUint) Load(k uint) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNUint) Store(k uint, v uint) {
	__[k] = v
}
func (__ OfUintNUint) Delete(k uint, v uint) {
	delete(__, k)
}
func (__ OfUintNUint) Range(f func(k uint, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNUint = OfUintNUint
type OfUintNUintSt struct {
	// do not want to export but want to use embedding method
	_OfUintNUint
}

func NewOfUintNUintSt(somes OfUintNUint) *OfUintNUintSt {
	return &OfUintNUintSt{
		_OfUintNUint: somes,
	}
}

type OfUintNUint16If interface {
	Load(uint) (uint16, error)
}

type OfUintNUint16MutIf interface {
	Store(uint, uint16)
	Delete(uint)
}

type OfUintNUint16IterIf interface {
	Range(func(uint, uint16) bool)
}

type OfUintNUint16 map[uint]uint16

func (__ OfUintNUint16) Load(k uint) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNUint16) Store(k uint, v uint16) {
	__[k] = v
}
func (__ OfUintNUint16) Delete(k uint, v uint16) {
	delete(__, k)
}
func (__ OfUintNUint16) Range(f func(k uint, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNUint16 = OfUintNUint16
type OfUintNUint16St struct {
	// do not want to export but want to use embedding method
	_OfUintNUint16
}

func NewOfUintNUint16St(somes OfUintNUint16) *OfUintNUint16St {
	return &OfUintNUint16St{
		_OfUintNUint16: somes,
	}
}

type OfUintNUint32If interface {
	Load(uint) (uint32, error)
}

type OfUintNUint32MutIf interface {
	Store(uint, uint32)
	Delete(uint)
}

type OfUintNUint32IterIf interface {
	Range(func(uint, uint32) bool)
}

type OfUintNUint32 map[uint]uint32

func (__ OfUintNUint32) Load(k uint) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNUint32) Store(k uint, v uint32) {
	__[k] = v
}
func (__ OfUintNUint32) Delete(k uint, v uint32) {
	delete(__, k)
}
func (__ OfUintNUint32) Range(f func(k uint, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNUint32 = OfUintNUint32
type OfUintNUint32St struct {
	// do not want to export but want to use embedding method
	_OfUintNUint32
}

func NewOfUintNUint32St(somes OfUintNUint32) *OfUintNUint32St {
	return &OfUintNUint32St{
		_OfUintNUint32: somes,
	}
}

type OfUintNUint64If interface {
	Load(uint) (uint64, error)
}

type OfUintNUint64MutIf interface {
	Store(uint, uint64)
	Delete(uint)
}

type OfUintNUint64IterIf interface {
	Range(func(uint, uint64) bool)
}

type OfUintNUint64 map[uint]uint64

func (__ OfUintNUint64) Load(k uint) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNUint64) Store(k uint, v uint64) {
	__[k] = v
}
func (__ OfUintNUint64) Delete(k uint, v uint64) {
	delete(__, k)
}
func (__ OfUintNUint64) Range(f func(k uint, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNUint64 = OfUintNUint64
type OfUintNUint64St struct {
	// do not want to export but want to use embedding method
	_OfUintNUint64
}

func NewOfUintNUint64St(somes OfUintNUint64) *OfUintNUint64St {
	return &OfUintNUint64St{
		_OfUintNUint64: somes,
	}
}

type OfUintNUint8If interface {
	Load(uint) (uint8, error)
}

type OfUintNUint8MutIf interface {
	Store(uint, uint8)
	Delete(uint)
}

type OfUintNUint8IterIf interface {
	Range(func(uint, uint8) bool)
}

type OfUintNUint8 map[uint]uint8

func (__ OfUintNUint8) Load(k uint) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNUint8) Store(k uint, v uint8) {
	__[k] = v
}
func (__ OfUintNUint8) Delete(k uint, v uint8) {
	delete(__, k)
}
func (__ OfUintNUint8) Range(f func(k uint, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNUint8 = OfUintNUint8
type OfUintNUint8St struct {
	// do not want to export but want to use embedding method
	_OfUintNUint8
}

func NewOfUintNUint8St(somes OfUintNUint8) *OfUintNUint8St {
	return &OfUintNUint8St{
		_OfUintNUint8: somes,
	}
}

type OfUintNUintptrIf interface {
	Load(uint) (uintptr, error)
}

type OfUintNUintptrMutIf interface {
	Store(uint, uintptr)
	Delete(uint)
}

type OfUintNUintptrIterIf interface {
	Range(func(uint, uintptr) bool)
}

type OfUintNUintptr map[uint]uintptr

func (__ OfUintNUintptr) Load(k uint) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNUintptr) Store(k uint, v uintptr) {
	__[k] = v
}
func (__ OfUintNUintptr) Delete(k uint, v uintptr) {
	delete(__, k)
}
func (__ OfUintNUintptr) Range(f func(k uint, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNUintptr = OfUintNUintptr
type OfUintNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfUintNUintptr
}

func NewOfUintNUintptrSt(somes OfUintNUintptr) *OfUintNUintptrSt {
	return &OfUintNUintptrSt{
		_OfUintNUintptr: somes,
	}
}

type OfUintNInterfaceIf interface {
	Load(uint) (interface{}, error)
}

type OfUintNInterfaceMutIf interface {
	Store(uint, interface{})
	Delete(uint)
}

type OfUintNInterfaceIterIf interface {
	Range(func(uint, interface{}) bool)
}

type OfUintNInterface map[uint]interface{}

func (__ OfUintNInterface) Load(k uint) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintNInterface) Store(k uint, v interface{}) {
	__[k] = v
}
func (__ OfUintNInterface) Delete(k uint, v interface{}) {
	delete(__, k)
}
func (__ OfUintNInterface) Range(f func(k uint, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintNInterface = OfUintNInterface
type OfUintNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfUintNInterface
}

func NewOfUintNInterfaceSt(somes OfUintNInterface) *OfUintNInterfaceSt {
	return &OfUintNInterfaceSt{
		_OfUintNInterface: somes,
	}
}

type OfUint16NBoolIf interface {
	Load(uint16) (bool, error)
}

type OfUint16NBoolMutIf interface {
	Store(uint16, bool)
	Delete(uint16)
}

type OfUint16NBoolIterIf interface {
	Range(func(uint16, bool) bool)
}

type OfUint16NBool map[uint16]bool

func (__ OfUint16NBool) Load(k uint16) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NBool) Store(k uint16, v bool) {
	__[k] = v
}
func (__ OfUint16NBool) Delete(k uint16, v bool) {
	delete(__, k)
}
func (__ OfUint16NBool) Range(f func(k uint16, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NBool = OfUint16NBool
type OfUint16NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NBool
}

func NewOfUint16NBoolSt(somes OfUint16NBool) *OfUint16NBoolSt {
	return &OfUint16NBoolSt{
		_OfUint16NBool: somes,
	}
}

type OfUint16NByteIf interface {
	Load(uint16) (byte, error)
}

type OfUint16NByteMutIf interface {
	Store(uint16, byte)
	Delete(uint16)
}

type OfUint16NByteIterIf interface {
	Range(func(uint16, byte) bool)
}

type OfUint16NByte map[uint16]byte

func (__ OfUint16NByte) Load(k uint16) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NByte) Store(k uint16, v byte) {
	__[k] = v
}
func (__ OfUint16NByte) Delete(k uint16, v byte) {
	delete(__, k)
}
func (__ OfUint16NByte) Range(f func(k uint16, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NByte = OfUint16NByte
type OfUint16NByteSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NByte
}

func NewOfUint16NByteSt(somes OfUint16NByte) *OfUint16NByteSt {
	return &OfUint16NByteSt{
		_OfUint16NByte: somes,
	}
}

type OfUint16NComplex128If interface {
	Load(uint16) (complex128, error)
}

type OfUint16NComplex128MutIf interface {
	Store(uint16, complex128)
	Delete(uint16)
}

type OfUint16NComplex128IterIf interface {
	Range(func(uint16, complex128) bool)
}

type OfUint16NComplex128 map[uint16]complex128

func (__ OfUint16NComplex128) Load(k uint16) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NComplex128) Store(k uint16, v complex128) {
	__[k] = v
}
func (__ OfUint16NComplex128) Delete(k uint16, v complex128) {
	delete(__, k)
}
func (__ OfUint16NComplex128) Range(f func(k uint16, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NComplex128 = OfUint16NComplex128
type OfUint16NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfUint16NComplex128
}

func NewOfUint16NComplex128St(somes OfUint16NComplex128) *OfUint16NComplex128St {
	return &OfUint16NComplex128St{
		_OfUint16NComplex128: somes,
	}
}

type OfUint16NComplex64If interface {
	Load(uint16) (complex64, error)
}

type OfUint16NComplex64MutIf interface {
	Store(uint16, complex64)
	Delete(uint16)
}

type OfUint16NComplex64IterIf interface {
	Range(func(uint16, complex64) bool)
}

type OfUint16NComplex64 map[uint16]complex64

func (__ OfUint16NComplex64) Load(k uint16) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NComplex64) Store(k uint16, v complex64) {
	__[k] = v
}
func (__ OfUint16NComplex64) Delete(k uint16, v complex64) {
	delete(__, k)
}
func (__ OfUint16NComplex64) Range(f func(k uint16, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NComplex64 = OfUint16NComplex64
type OfUint16NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfUint16NComplex64
}

func NewOfUint16NComplex64St(somes OfUint16NComplex64) *OfUint16NComplex64St {
	return &OfUint16NComplex64St{
		_OfUint16NComplex64: somes,
	}
}

type OfUint16NErrorIf interface {
	Load(uint16) (error, error)
}

type OfUint16NErrorMutIf interface {
	Store(uint16, error)
	Delete(uint16)
}

type OfUint16NErrorIterIf interface {
	Range(func(uint16, error) bool)
}

type OfUint16NError map[uint16]error

func (__ OfUint16NError) Load(k uint16) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NError) Store(k uint16, v error) {
	__[k] = v
}
func (__ OfUint16NError) Delete(k uint16, v error) {
	delete(__, k)
}
func (__ OfUint16NError) Range(f func(k uint16, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NError = OfUint16NError
type OfUint16NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NError
}

func NewOfUint16NErrorSt(somes OfUint16NError) *OfUint16NErrorSt {
	return &OfUint16NErrorSt{
		_OfUint16NError: somes,
	}
}

type OfUint16NFloat32If interface {
	Load(uint16) (float32, error)
}

type OfUint16NFloat32MutIf interface {
	Store(uint16, float32)
	Delete(uint16)
}

type OfUint16NFloat32IterIf interface {
	Range(func(uint16, float32) bool)
}

type OfUint16NFloat32 map[uint16]float32

func (__ OfUint16NFloat32) Load(k uint16) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NFloat32) Store(k uint16, v float32) {
	__[k] = v
}
func (__ OfUint16NFloat32) Delete(k uint16, v float32) {
	delete(__, k)
}
func (__ OfUint16NFloat32) Range(f func(k uint16, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NFloat32 = OfUint16NFloat32
type OfUint16NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfUint16NFloat32
}

func NewOfUint16NFloat32St(somes OfUint16NFloat32) *OfUint16NFloat32St {
	return &OfUint16NFloat32St{
		_OfUint16NFloat32: somes,
	}
}

type OfUint16NFloat64If interface {
	Load(uint16) (float64, error)
}

type OfUint16NFloat64MutIf interface {
	Store(uint16, float64)
	Delete(uint16)
}

type OfUint16NFloat64IterIf interface {
	Range(func(uint16, float64) bool)
}

type OfUint16NFloat64 map[uint16]float64

func (__ OfUint16NFloat64) Load(k uint16) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NFloat64) Store(k uint16, v float64) {
	__[k] = v
}
func (__ OfUint16NFloat64) Delete(k uint16, v float64) {
	delete(__, k)
}
func (__ OfUint16NFloat64) Range(f func(k uint16, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NFloat64 = OfUint16NFloat64
type OfUint16NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfUint16NFloat64
}

func NewOfUint16NFloat64St(somes OfUint16NFloat64) *OfUint16NFloat64St {
	return &OfUint16NFloat64St{
		_OfUint16NFloat64: somes,
	}
}

type OfUint16NIntIf interface {
	Load(uint16) (int, error)
}

type OfUint16NIntMutIf interface {
	Store(uint16, int)
	Delete(uint16)
}

type OfUint16NIntIterIf interface {
	Range(func(uint16, int) bool)
}

type OfUint16NInt map[uint16]int

func (__ OfUint16NInt) Load(k uint16) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NInt) Store(k uint16, v int) {
	__[k] = v
}
func (__ OfUint16NInt) Delete(k uint16, v int) {
	delete(__, k)
}
func (__ OfUint16NInt) Range(f func(k uint16, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NInt = OfUint16NInt
type OfUint16NIntSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NInt
}

func NewOfUint16NIntSt(somes OfUint16NInt) *OfUint16NIntSt {
	return &OfUint16NIntSt{
		_OfUint16NInt: somes,
	}
}

type OfUint16NInt16If interface {
	Load(uint16) (int16, error)
}

type OfUint16NInt16MutIf interface {
	Store(uint16, int16)
	Delete(uint16)
}

type OfUint16NInt16IterIf interface {
	Range(func(uint16, int16) bool)
}

type OfUint16NInt16 map[uint16]int16

func (__ OfUint16NInt16) Load(k uint16) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NInt16) Store(k uint16, v int16) {
	__[k] = v
}
func (__ OfUint16NInt16) Delete(k uint16, v int16) {
	delete(__, k)
}
func (__ OfUint16NInt16) Range(f func(k uint16, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NInt16 = OfUint16NInt16
type OfUint16NInt16St struct {
	// do not want to export but want to use embedding method
	_OfUint16NInt16
}

func NewOfUint16NInt16St(somes OfUint16NInt16) *OfUint16NInt16St {
	return &OfUint16NInt16St{
		_OfUint16NInt16: somes,
	}
}

type OfUint16NInt32If interface {
	Load(uint16) (int32, error)
}

type OfUint16NInt32MutIf interface {
	Store(uint16, int32)
	Delete(uint16)
}

type OfUint16NInt32IterIf interface {
	Range(func(uint16, int32) bool)
}

type OfUint16NInt32 map[uint16]int32

func (__ OfUint16NInt32) Load(k uint16) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NInt32) Store(k uint16, v int32) {
	__[k] = v
}
func (__ OfUint16NInt32) Delete(k uint16, v int32) {
	delete(__, k)
}
func (__ OfUint16NInt32) Range(f func(k uint16, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NInt32 = OfUint16NInt32
type OfUint16NInt32St struct {
	// do not want to export but want to use embedding method
	_OfUint16NInt32
}

func NewOfUint16NInt32St(somes OfUint16NInt32) *OfUint16NInt32St {
	return &OfUint16NInt32St{
		_OfUint16NInt32: somes,
	}
}

type OfUint16NInt64If interface {
	Load(uint16) (int64, error)
}

type OfUint16NInt64MutIf interface {
	Store(uint16, int64)
	Delete(uint16)
}

type OfUint16NInt64IterIf interface {
	Range(func(uint16, int64) bool)
}

type OfUint16NInt64 map[uint16]int64

func (__ OfUint16NInt64) Load(k uint16) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NInt64) Store(k uint16, v int64) {
	__[k] = v
}
func (__ OfUint16NInt64) Delete(k uint16, v int64) {
	delete(__, k)
}
func (__ OfUint16NInt64) Range(f func(k uint16, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NInt64 = OfUint16NInt64
type OfUint16NInt64St struct {
	// do not want to export but want to use embedding method
	_OfUint16NInt64
}

func NewOfUint16NInt64St(somes OfUint16NInt64) *OfUint16NInt64St {
	return &OfUint16NInt64St{
		_OfUint16NInt64: somes,
	}
}

type OfUint16NInt8If interface {
	Load(uint16) (int8, error)
}

type OfUint16NInt8MutIf interface {
	Store(uint16, int8)
	Delete(uint16)
}

type OfUint16NInt8IterIf interface {
	Range(func(uint16, int8) bool)
}

type OfUint16NInt8 map[uint16]int8

func (__ OfUint16NInt8) Load(k uint16) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NInt8) Store(k uint16, v int8) {
	__[k] = v
}
func (__ OfUint16NInt8) Delete(k uint16, v int8) {
	delete(__, k)
}
func (__ OfUint16NInt8) Range(f func(k uint16, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NInt8 = OfUint16NInt8
type OfUint16NInt8St struct {
	// do not want to export but want to use embedding method
	_OfUint16NInt8
}

func NewOfUint16NInt8St(somes OfUint16NInt8) *OfUint16NInt8St {
	return &OfUint16NInt8St{
		_OfUint16NInt8: somes,
	}
}

type OfUint16NRuneIf interface {
	Load(uint16) (rune, error)
}

type OfUint16NRuneMutIf interface {
	Store(uint16, rune)
	Delete(uint16)
}

type OfUint16NRuneIterIf interface {
	Range(func(uint16, rune) bool)
}

type OfUint16NRune map[uint16]rune

func (__ OfUint16NRune) Load(k uint16) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NRune) Store(k uint16, v rune) {
	__[k] = v
}
func (__ OfUint16NRune) Delete(k uint16, v rune) {
	delete(__, k)
}
func (__ OfUint16NRune) Range(f func(k uint16, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NRune = OfUint16NRune
type OfUint16NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NRune
}

func NewOfUint16NRuneSt(somes OfUint16NRune) *OfUint16NRuneSt {
	return &OfUint16NRuneSt{
		_OfUint16NRune: somes,
	}
}

type OfUint16NStringIf interface {
	Load(uint16) (string, error)
}

type OfUint16NStringMutIf interface {
	Store(uint16, string)
	Delete(uint16)
}

type OfUint16NStringIterIf interface {
	Range(func(uint16, string) bool)
}

type OfUint16NString map[uint16]string

func (__ OfUint16NString) Load(k uint16) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NString) Store(k uint16, v string) {
	__[k] = v
}
func (__ OfUint16NString) Delete(k uint16, v string) {
	delete(__, k)
}
func (__ OfUint16NString) Range(f func(k uint16, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NString = OfUint16NString
type OfUint16NStringSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NString
}

func NewOfUint16NStringSt(somes OfUint16NString) *OfUint16NStringSt {
	return &OfUint16NStringSt{
		_OfUint16NString: somes,
	}
}

type OfUint16NUintIf interface {
	Load(uint16) (uint, error)
}

type OfUint16NUintMutIf interface {
	Store(uint16, uint)
	Delete(uint16)
}

type OfUint16NUintIterIf interface {
	Range(func(uint16, uint) bool)
}

type OfUint16NUint map[uint16]uint

func (__ OfUint16NUint) Load(k uint16) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NUint) Store(k uint16, v uint) {
	__[k] = v
}
func (__ OfUint16NUint) Delete(k uint16, v uint) {
	delete(__, k)
}
func (__ OfUint16NUint) Range(f func(k uint16, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NUint = OfUint16NUint
type OfUint16NUintSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NUint
}

func NewOfUint16NUintSt(somes OfUint16NUint) *OfUint16NUintSt {
	return &OfUint16NUintSt{
		_OfUint16NUint: somes,
	}
}

type OfUint16NUint16If interface {
	Load(uint16) (uint16, error)
}

type OfUint16NUint16MutIf interface {
	Store(uint16, uint16)
	Delete(uint16)
}

type OfUint16NUint16IterIf interface {
	Range(func(uint16, uint16) bool)
}

type OfUint16NUint16 map[uint16]uint16

func (__ OfUint16NUint16) Load(k uint16) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NUint16) Store(k uint16, v uint16) {
	__[k] = v
}
func (__ OfUint16NUint16) Delete(k uint16, v uint16) {
	delete(__, k)
}
func (__ OfUint16NUint16) Range(f func(k uint16, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NUint16 = OfUint16NUint16
type OfUint16NUint16St struct {
	// do not want to export but want to use embedding method
	_OfUint16NUint16
}

func NewOfUint16NUint16St(somes OfUint16NUint16) *OfUint16NUint16St {
	return &OfUint16NUint16St{
		_OfUint16NUint16: somes,
	}
}

type OfUint16NUint32If interface {
	Load(uint16) (uint32, error)
}

type OfUint16NUint32MutIf interface {
	Store(uint16, uint32)
	Delete(uint16)
}

type OfUint16NUint32IterIf interface {
	Range(func(uint16, uint32) bool)
}

type OfUint16NUint32 map[uint16]uint32

func (__ OfUint16NUint32) Load(k uint16) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NUint32) Store(k uint16, v uint32) {
	__[k] = v
}
func (__ OfUint16NUint32) Delete(k uint16, v uint32) {
	delete(__, k)
}
func (__ OfUint16NUint32) Range(f func(k uint16, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NUint32 = OfUint16NUint32
type OfUint16NUint32St struct {
	// do not want to export but want to use embedding method
	_OfUint16NUint32
}

func NewOfUint16NUint32St(somes OfUint16NUint32) *OfUint16NUint32St {
	return &OfUint16NUint32St{
		_OfUint16NUint32: somes,
	}
}

type OfUint16NUint64If interface {
	Load(uint16) (uint64, error)
}

type OfUint16NUint64MutIf interface {
	Store(uint16, uint64)
	Delete(uint16)
}

type OfUint16NUint64IterIf interface {
	Range(func(uint16, uint64) bool)
}

type OfUint16NUint64 map[uint16]uint64

func (__ OfUint16NUint64) Load(k uint16) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NUint64) Store(k uint16, v uint64) {
	__[k] = v
}
func (__ OfUint16NUint64) Delete(k uint16, v uint64) {
	delete(__, k)
}
func (__ OfUint16NUint64) Range(f func(k uint16, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NUint64 = OfUint16NUint64
type OfUint16NUint64St struct {
	// do not want to export but want to use embedding method
	_OfUint16NUint64
}

func NewOfUint16NUint64St(somes OfUint16NUint64) *OfUint16NUint64St {
	return &OfUint16NUint64St{
		_OfUint16NUint64: somes,
	}
}

type OfUint16NUint8If interface {
	Load(uint16) (uint8, error)
}

type OfUint16NUint8MutIf interface {
	Store(uint16, uint8)
	Delete(uint16)
}

type OfUint16NUint8IterIf interface {
	Range(func(uint16, uint8) bool)
}

type OfUint16NUint8 map[uint16]uint8

func (__ OfUint16NUint8) Load(k uint16) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NUint8) Store(k uint16, v uint8) {
	__[k] = v
}
func (__ OfUint16NUint8) Delete(k uint16, v uint8) {
	delete(__, k)
}
func (__ OfUint16NUint8) Range(f func(k uint16, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NUint8 = OfUint16NUint8
type OfUint16NUint8St struct {
	// do not want to export but want to use embedding method
	_OfUint16NUint8
}

func NewOfUint16NUint8St(somes OfUint16NUint8) *OfUint16NUint8St {
	return &OfUint16NUint8St{
		_OfUint16NUint8: somes,
	}
}

type OfUint16NUintptrIf interface {
	Load(uint16) (uintptr, error)
}

type OfUint16NUintptrMutIf interface {
	Store(uint16, uintptr)
	Delete(uint16)
}

type OfUint16NUintptrIterIf interface {
	Range(func(uint16, uintptr) bool)
}

type OfUint16NUintptr map[uint16]uintptr

func (__ OfUint16NUintptr) Load(k uint16) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NUintptr) Store(k uint16, v uintptr) {
	__[k] = v
}
func (__ OfUint16NUintptr) Delete(k uint16, v uintptr) {
	delete(__, k)
}
func (__ OfUint16NUintptr) Range(f func(k uint16, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NUintptr = OfUint16NUintptr
type OfUint16NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NUintptr
}

func NewOfUint16NUintptrSt(somes OfUint16NUintptr) *OfUint16NUintptrSt {
	return &OfUint16NUintptrSt{
		_OfUint16NUintptr: somes,
	}
}

type OfUint16NInterfaceIf interface {
	Load(uint16) (interface{}, error)
}

type OfUint16NInterfaceMutIf interface {
	Store(uint16, interface{})
	Delete(uint16)
}

type OfUint16NInterfaceIterIf interface {
	Range(func(uint16, interface{}) bool)
}

type OfUint16NInterface map[uint16]interface{}

func (__ OfUint16NInterface) Load(k uint16) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint16NInterface) Store(k uint16, v interface{}) {
	__[k] = v
}
func (__ OfUint16NInterface) Delete(k uint16, v interface{}) {
	delete(__, k)
}
func (__ OfUint16NInterface) Range(f func(k uint16, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint16NInterface = OfUint16NInterface
type OfUint16NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfUint16NInterface
}

func NewOfUint16NInterfaceSt(somes OfUint16NInterface) *OfUint16NInterfaceSt {
	return &OfUint16NInterfaceSt{
		_OfUint16NInterface: somes,
	}
}

type OfUint32NBoolIf interface {
	Load(uint32) (bool, error)
}

type OfUint32NBoolMutIf interface {
	Store(uint32, bool)
	Delete(uint32)
}

type OfUint32NBoolIterIf interface {
	Range(func(uint32, bool) bool)
}

type OfUint32NBool map[uint32]bool

func (__ OfUint32NBool) Load(k uint32) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NBool) Store(k uint32, v bool) {
	__[k] = v
}
func (__ OfUint32NBool) Delete(k uint32, v bool) {
	delete(__, k)
}
func (__ OfUint32NBool) Range(f func(k uint32, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NBool = OfUint32NBool
type OfUint32NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NBool
}

func NewOfUint32NBoolSt(somes OfUint32NBool) *OfUint32NBoolSt {
	return &OfUint32NBoolSt{
		_OfUint32NBool: somes,
	}
}

type OfUint32NByteIf interface {
	Load(uint32) (byte, error)
}

type OfUint32NByteMutIf interface {
	Store(uint32, byte)
	Delete(uint32)
}

type OfUint32NByteIterIf interface {
	Range(func(uint32, byte) bool)
}

type OfUint32NByte map[uint32]byte

func (__ OfUint32NByte) Load(k uint32) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NByte) Store(k uint32, v byte) {
	__[k] = v
}
func (__ OfUint32NByte) Delete(k uint32, v byte) {
	delete(__, k)
}
func (__ OfUint32NByte) Range(f func(k uint32, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NByte = OfUint32NByte
type OfUint32NByteSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NByte
}

func NewOfUint32NByteSt(somes OfUint32NByte) *OfUint32NByteSt {
	return &OfUint32NByteSt{
		_OfUint32NByte: somes,
	}
}

type OfUint32NComplex128If interface {
	Load(uint32) (complex128, error)
}

type OfUint32NComplex128MutIf interface {
	Store(uint32, complex128)
	Delete(uint32)
}

type OfUint32NComplex128IterIf interface {
	Range(func(uint32, complex128) bool)
}

type OfUint32NComplex128 map[uint32]complex128

func (__ OfUint32NComplex128) Load(k uint32) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NComplex128) Store(k uint32, v complex128) {
	__[k] = v
}
func (__ OfUint32NComplex128) Delete(k uint32, v complex128) {
	delete(__, k)
}
func (__ OfUint32NComplex128) Range(f func(k uint32, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NComplex128 = OfUint32NComplex128
type OfUint32NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfUint32NComplex128
}

func NewOfUint32NComplex128St(somes OfUint32NComplex128) *OfUint32NComplex128St {
	return &OfUint32NComplex128St{
		_OfUint32NComplex128: somes,
	}
}

type OfUint32NComplex64If interface {
	Load(uint32) (complex64, error)
}

type OfUint32NComplex64MutIf interface {
	Store(uint32, complex64)
	Delete(uint32)
}

type OfUint32NComplex64IterIf interface {
	Range(func(uint32, complex64) bool)
}

type OfUint32NComplex64 map[uint32]complex64

func (__ OfUint32NComplex64) Load(k uint32) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NComplex64) Store(k uint32, v complex64) {
	__[k] = v
}
func (__ OfUint32NComplex64) Delete(k uint32, v complex64) {
	delete(__, k)
}
func (__ OfUint32NComplex64) Range(f func(k uint32, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NComplex64 = OfUint32NComplex64
type OfUint32NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfUint32NComplex64
}

func NewOfUint32NComplex64St(somes OfUint32NComplex64) *OfUint32NComplex64St {
	return &OfUint32NComplex64St{
		_OfUint32NComplex64: somes,
	}
}

type OfUint32NErrorIf interface {
	Load(uint32) (error, error)
}

type OfUint32NErrorMutIf interface {
	Store(uint32, error)
	Delete(uint32)
}

type OfUint32NErrorIterIf interface {
	Range(func(uint32, error) bool)
}

type OfUint32NError map[uint32]error

func (__ OfUint32NError) Load(k uint32) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NError) Store(k uint32, v error) {
	__[k] = v
}
func (__ OfUint32NError) Delete(k uint32, v error) {
	delete(__, k)
}
func (__ OfUint32NError) Range(f func(k uint32, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NError = OfUint32NError
type OfUint32NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NError
}

func NewOfUint32NErrorSt(somes OfUint32NError) *OfUint32NErrorSt {
	return &OfUint32NErrorSt{
		_OfUint32NError: somes,
	}
}

type OfUint32NFloat32If interface {
	Load(uint32) (float32, error)
}

type OfUint32NFloat32MutIf interface {
	Store(uint32, float32)
	Delete(uint32)
}

type OfUint32NFloat32IterIf interface {
	Range(func(uint32, float32) bool)
}

type OfUint32NFloat32 map[uint32]float32

func (__ OfUint32NFloat32) Load(k uint32) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NFloat32) Store(k uint32, v float32) {
	__[k] = v
}
func (__ OfUint32NFloat32) Delete(k uint32, v float32) {
	delete(__, k)
}
func (__ OfUint32NFloat32) Range(f func(k uint32, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NFloat32 = OfUint32NFloat32
type OfUint32NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfUint32NFloat32
}

func NewOfUint32NFloat32St(somes OfUint32NFloat32) *OfUint32NFloat32St {
	return &OfUint32NFloat32St{
		_OfUint32NFloat32: somes,
	}
}

type OfUint32NFloat64If interface {
	Load(uint32) (float64, error)
}

type OfUint32NFloat64MutIf interface {
	Store(uint32, float64)
	Delete(uint32)
}

type OfUint32NFloat64IterIf interface {
	Range(func(uint32, float64) bool)
}

type OfUint32NFloat64 map[uint32]float64

func (__ OfUint32NFloat64) Load(k uint32) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NFloat64) Store(k uint32, v float64) {
	__[k] = v
}
func (__ OfUint32NFloat64) Delete(k uint32, v float64) {
	delete(__, k)
}
func (__ OfUint32NFloat64) Range(f func(k uint32, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NFloat64 = OfUint32NFloat64
type OfUint32NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfUint32NFloat64
}

func NewOfUint32NFloat64St(somes OfUint32NFloat64) *OfUint32NFloat64St {
	return &OfUint32NFloat64St{
		_OfUint32NFloat64: somes,
	}
}

type OfUint32NIntIf interface {
	Load(uint32) (int, error)
}

type OfUint32NIntMutIf interface {
	Store(uint32, int)
	Delete(uint32)
}

type OfUint32NIntIterIf interface {
	Range(func(uint32, int) bool)
}

type OfUint32NInt map[uint32]int

func (__ OfUint32NInt) Load(k uint32) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NInt) Store(k uint32, v int) {
	__[k] = v
}
func (__ OfUint32NInt) Delete(k uint32, v int) {
	delete(__, k)
}
func (__ OfUint32NInt) Range(f func(k uint32, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NInt = OfUint32NInt
type OfUint32NIntSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NInt
}

func NewOfUint32NIntSt(somes OfUint32NInt) *OfUint32NIntSt {
	return &OfUint32NIntSt{
		_OfUint32NInt: somes,
	}
}

type OfUint32NInt16If interface {
	Load(uint32) (int16, error)
}

type OfUint32NInt16MutIf interface {
	Store(uint32, int16)
	Delete(uint32)
}

type OfUint32NInt16IterIf interface {
	Range(func(uint32, int16) bool)
}

type OfUint32NInt16 map[uint32]int16

func (__ OfUint32NInt16) Load(k uint32) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NInt16) Store(k uint32, v int16) {
	__[k] = v
}
func (__ OfUint32NInt16) Delete(k uint32, v int16) {
	delete(__, k)
}
func (__ OfUint32NInt16) Range(f func(k uint32, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NInt16 = OfUint32NInt16
type OfUint32NInt16St struct {
	// do not want to export but want to use embedding method
	_OfUint32NInt16
}

func NewOfUint32NInt16St(somes OfUint32NInt16) *OfUint32NInt16St {
	return &OfUint32NInt16St{
		_OfUint32NInt16: somes,
	}
}

type OfUint32NInt32If interface {
	Load(uint32) (int32, error)
}

type OfUint32NInt32MutIf interface {
	Store(uint32, int32)
	Delete(uint32)
}

type OfUint32NInt32IterIf interface {
	Range(func(uint32, int32) bool)
}

type OfUint32NInt32 map[uint32]int32

func (__ OfUint32NInt32) Load(k uint32) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NInt32) Store(k uint32, v int32) {
	__[k] = v
}
func (__ OfUint32NInt32) Delete(k uint32, v int32) {
	delete(__, k)
}
func (__ OfUint32NInt32) Range(f func(k uint32, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NInt32 = OfUint32NInt32
type OfUint32NInt32St struct {
	// do not want to export but want to use embedding method
	_OfUint32NInt32
}

func NewOfUint32NInt32St(somes OfUint32NInt32) *OfUint32NInt32St {
	return &OfUint32NInt32St{
		_OfUint32NInt32: somes,
	}
}

type OfUint32NInt64If interface {
	Load(uint32) (int64, error)
}

type OfUint32NInt64MutIf interface {
	Store(uint32, int64)
	Delete(uint32)
}

type OfUint32NInt64IterIf interface {
	Range(func(uint32, int64) bool)
}

type OfUint32NInt64 map[uint32]int64

func (__ OfUint32NInt64) Load(k uint32) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NInt64) Store(k uint32, v int64) {
	__[k] = v
}
func (__ OfUint32NInt64) Delete(k uint32, v int64) {
	delete(__, k)
}
func (__ OfUint32NInt64) Range(f func(k uint32, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NInt64 = OfUint32NInt64
type OfUint32NInt64St struct {
	// do not want to export but want to use embedding method
	_OfUint32NInt64
}

func NewOfUint32NInt64St(somes OfUint32NInt64) *OfUint32NInt64St {
	return &OfUint32NInt64St{
		_OfUint32NInt64: somes,
	}
}

type OfUint32NInt8If interface {
	Load(uint32) (int8, error)
}

type OfUint32NInt8MutIf interface {
	Store(uint32, int8)
	Delete(uint32)
}

type OfUint32NInt8IterIf interface {
	Range(func(uint32, int8) bool)
}

type OfUint32NInt8 map[uint32]int8

func (__ OfUint32NInt8) Load(k uint32) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NInt8) Store(k uint32, v int8) {
	__[k] = v
}
func (__ OfUint32NInt8) Delete(k uint32, v int8) {
	delete(__, k)
}
func (__ OfUint32NInt8) Range(f func(k uint32, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NInt8 = OfUint32NInt8
type OfUint32NInt8St struct {
	// do not want to export but want to use embedding method
	_OfUint32NInt8
}

func NewOfUint32NInt8St(somes OfUint32NInt8) *OfUint32NInt8St {
	return &OfUint32NInt8St{
		_OfUint32NInt8: somes,
	}
}

type OfUint32NRuneIf interface {
	Load(uint32) (rune, error)
}

type OfUint32NRuneMutIf interface {
	Store(uint32, rune)
	Delete(uint32)
}

type OfUint32NRuneIterIf interface {
	Range(func(uint32, rune) bool)
}

type OfUint32NRune map[uint32]rune

func (__ OfUint32NRune) Load(k uint32) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NRune) Store(k uint32, v rune) {
	__[k] = v
}
func (__ OfUint32NRune) Delete(k uint32, v rune) {
	delete(__, k)
}
func (__ OfUint32NRune) Range(f func(k uint32, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NRune = OfUint32NRune
type OfUint32NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NRune
}

func NewOfUint32NRuneSt(somes OfUint32NRune) *OfUint32NRuneSt {
	return &OfUint32NRuneSt{
		_OfUint32NRune: somes,
	}
}

type OfUint32NStringIf interface {
	Load(uint32) (string, error)
}

type OfUint32NStringMutIf interface {
	Store(uint32, string)
	Delete(uint32)
}

type OfUint32NStringIterIf interface {
	Range(func(uint32, string) bool)
}

type OfUint32NString map[uint32]string

func (__ OfUint32NString) Load(k uint32) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NString) Store(k uint32, v string) {
	__[k] = v
}
func (__ OfUint32NString) Delete(k uint32, v string) {
	delete(__, k)
}
func (__ OfUint32NString) Range(f func(k uint32, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NString = OfUint32NString
type OfUint32NStringSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NString
}

func NewOfUint32NStringSt(somes OfUint32NString) *OfUint32NStringSt {
	return &OfUint32NStringSt{
		_OfUint32NString: somes,
	}
}

type OfUint32NUintIf interface {
	Load(uint32) (uint, error)
}

type OfUint32NUintMutIf interface {
	Store(uint32, uint)
	Delete(uint32)
}

type OfUint32NUintIterIf interface {
	Range(func(uint32, uint) bool)
}

type OfUint32NUint map[uint32]uint

func (__ OfUint32NUint) Load(k uint32) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NUint) Store(k uint32, v uint) {
	__[k] = v
}
func (__ OfUint32NUint) Delete(k uint32, v uint) {
	delete(__, k)
}
func (__ OfUint32NUint) Range(f func(k uint32, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NUint = OfUint32NUint
type OfUint32NUintSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NUint
}

func NewOfUint32NUintSt(somes OfUint32NUint) *OfUint32NUintSt {
	return &OfUint32NUintSt{
		_OfUint32NUint: somes,
	}
}

type OfUint32NUint16If interface {
	Load(uint32) (uint16, error)
}

type OfUint32NUint16MutIf interface {
	Store(uint32, uint16)
	Delete(uint32)
}

type OfUint32NUint16IterIf interface {
	Range(func(uint32, uint16) bool)
}

type OfUint32NUint16 map[uint32]uint16

func (__ OfUint32NUint16) Load(k uint32) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NUint16) Store(k uint32, v uint16) {
	__[k] = v
}
func (__ OfUint32NUint16) Delete(k uint32, v uint16) {
	delete(__, k)
}
func (__ OfUint32NUint16) Range(f func(k uint32, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NUint16 = OfUint32NUint16
type OfUint32NUint16St struct {
	// do not want to export but want to use embedding method
	_OfUint32NUint16
}

func NewOfUint32NUint16St(somes OfUint32NUint16) *OfUint32NUint16St {
	return &OfUint32NUint16St{
		_OfUint32NUint16: somes,
	}
}

type OfUint32NUint32If interface {
	Load(uint32) (uint32, error)
}

type OfUint32NUint32MutIf interface {
	Store(uint32, uint32)
	Delete(uint32)
}

type OfUint32NUint32IterIf interface {
	Range(func(uint32, uint32) bool)
}

type OfUint32NUint32 map[uint32]uint32

func (__ OfUint32NUint32) Load(k uint32) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NUint32) Store(k uint32, v uint32) {
	__[k] = v
}
func (__ OfUint32NUint32) Delete(k uint32, v uint32) {
	delete(__, k)
}
func (__ OfUint32NUint32) Range(f func(k uint32, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NUint32 = OfUint32NUint32
type OfUint32NUint32St struct {
	// do not want to export but want to use embedding method
	_OfUint32NUint32
}

func NewOfUint32NUint32St(somes OfUint32NUint32) *OfUint32NUint32St {
	return &OfUint32NUint32St{
		_OfUint32NUint32: somes,
	}
}

type OfUint32NUint64If interface {
	Load(uint32) (uint64, error)
}

type OfUint32NUint64MutIf interface {
	Store(uint32, uint64)
	Delete(uint32)
}

type OfUint32NUint64IterIf interface {
	Range(func(uint32, uint64) bool)
}

type OfUint32NUint64 map[uint32]uint64

func (__ OfUint32NUint64) Load(k uint32) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NUint64) Store(k uint32, v uint64) {
	__[k] = v
}
func (__ OfUint32NUint64) Delete(k uint32, v uint64) {
	delete(__, k)
}
func (__ OfUint32NUint64) Range(f func(k uint32, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NUint64 = OfUint32NUint64
type OfUint32NUint64St struct {
	// do not want to export but want to use embedding method
	_OfUint32NUint64
}

func NewOfUint32NUint64St(somes OfUint32NUint64) *OfUint32NUint64St {
	return &OfUint32NUint64St{
		_OfUint32NUint64: somes,
	}
}

type OfUint32NUint8If interface {
	Load(uint32) (uint8, error)
}

type OfUint32NUint8MutIf interface {
	Store(uint32, uint8)
	Delete(uint32)
}

type OfUint32NUint8IterIf interface {
	Range(func(uint32, uint8) bool)
}

type OfUint32NUint8 map[uint32]uint8

func (__ OfUint32NUint8) Load(k uint32) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NUint8) Store(k uint32, v uint8) {
	__[k] = v
}
func (__ OfUint32NUint8) Delete(k uint32, v uint8) {
	delete(__, k)
}
func (__ OfUint32NUint8) Range(f func(k uint32, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NUint8 = OfUint32NUint8
type OfUint32NUint8St struct {
	// do not want to export but want to use embedding method
	_OfUint32NUint8
}

func NewOfUint32NUint8St(somes OfUint32NUint8) *OfUint32NUint8St {
	return &OfUint32NUint8St{
		_OfUint32NUint8: somes,
	}
}

type OfUint32NUintptrIf interface {
	Load(uint32) (uintptr, error)
}

type OfUint32NUintptrMutIf interface {
	Store(uint32, uintptr)
	Delete(uint32)
}

type OfUint32NUintptrIterIf interface {
	Range(func(uint32, uintptr) bool)
}

type OfUint32NUintptr map[uint32]uintptr

func (__ OfUint32NUintptr) Load(k uint32) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NUintptr) Store(k uint32, v uintptr) {
	__[k] = v
}
func (__ OfUint32NUintptr) Delete(k uint32, v uintptr) {
	delete(__, k)
}
func (__ OfUint32NUintptr) Range(f func(k uint32, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NUintptr = OfUint32NUintptr
type OfUint32NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NUintptr
}

func NewOfUint32NUintptrSt(somes OfUint32NUintptr) *OfUint32NUintptrSt {
	return &OfUint32NUintptrSt{
		_OfUint32NUintptr: somes,
	}
}

type OfUint32NInterfaceIf interface {
	Load(uint32) (interface{}, error)
}

type OfUint32NInterfaceMutIf interface {
	Store(uint32, interface{})
	Delete(uint32)
}

type OfUint32NInterfaceIterIf interface {
	Range(func(uint32, interface{}) bool)
}

type OfUint32NInterface map[uint32]interface{}

func (__ OfUint32NInterface) Load(k uint32) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint32NInterface) Store(k uint32, v interface{}) {
	__[k] = v
}
func (__ OfUint32NInterface) Delete(k uint32, v interface{}) {
	delete(__, k)
}
func (__ OfUint32NInterface) Range(f func(k uint32, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint32NInterface = OfUint32NInterface
type OfUint32NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfUint32NInterface
}

func NewOfUint32NInterfaceSt(somes OfUint32NInterface) *OfUint32NInterfaceSt {
	return &OfUint32NInterfaceSt{
		_OfUint32NInterface: somes,
	}
}

type OfUint64NBoolIf interface {
	Load(uint64) (bool, error)
}

type OfUint64NBoolMutIf interface {
	Store(uint64, bool)
	Delete(uint64)
}

type OfUint64NBoolIterIf interface {
	Range(func(uint64, bool) bool)
}

type OfUint64NBool map[uint64]bool

func (__ OfUint64NBool) Load(k uint64) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NBool) Store(k uint64, v bool) {
	__[k] = v
}
func (__ OfUint64NBool) Delete(k uint64, v bool) {
	delete(__, k)
}
func (__ OfUint64NBool) Range(f func(k uint64, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NBool = OfUint64NBool
type OfUint64NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NBool
}

func NewOfUint64NBoolSt(somes OfUint64NBool) *OfUint64NBoolSt {
	return &OfUint64NBoolSt{
		_OfUint64NBool: somes,
	}
}

type OfUint64NByteIf interface {
	Load(uint64) (byte, error)
}

type OfUint64NByteMutIf interface {
	Store(uint64, byte)
	Delete(uint64)
}

type OfUint64NByteIterIf interface {
	Range(func(uint64, byte) bool)
}

type OfUint64NByte map[uint64]byte

func (__ OfUint64NByte) Load(k uint64) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NByte) Store(k uint64, v byte) {
	__[k] = v
}
func (__ OfUint64NByte) Delete(k uint64, v byte) {
	delete(__, k)
}
func (__ OfUint64NByte) Range(f func(k uint64, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NByte = OfUint64NByte
type OfUint64NByteSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NByte
}

func NewOfUint64NByteSt(somes OfUint64NByte) *OfUint64NByteSt {
	return &OfUint64NByteSt{
		_OfUint64NByte: somes,
	}
}

type OfUint64NComplex128If interface {
	Load(uint64) (complex128, error)
}

type OfUint64NComplex128MutIf interface {
	Store(uint64, complex128)
	Delete(uint64)
}

type OfUint64NComplex128IterIf interface {
	Range(func(uint64, complex128) bool)
}

type OfUint64NComplex128 map[uint64]complex128

func (__ OfUint64NComplex128) Load(k uint64) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NComplex128) Store(k uint64, v complex128) {
	__[k] = v
}
func (__ OfUint64NComplex128) Delete(k uint64, v complex128) {
	delete(__, k)
}
func (__ OfUint64NComplex128) Range(f func(k uint64, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NComplex128 = OfUint64NComplex128
type OfUint64NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfUint64NComplex128
}

func NewOfUint64NComplex128St(somes OfUint64NComplex128) *OfUint64NComplex128St {
	return &OfUint64NComplex128St{
		_OfUint64NComplex128: somes,
	}
}

type OfUint64NComplex64If interface {
	Load(uint64) (complex64, error)
}

type OfUint64NComplex64MutIf interface {
	Store(uint64, complex64)
	Delete(uint64)
}

type OfUint64NComplex64IterIf interface {
	Range(func(uint64, complex64) bool)
}

type OfUint64NComplex64 map[uint64]complex64

func (__ OfUint64NComplex64) Load(k uint64) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NComplex64) Store(k uint64, v complex64) {
	__[k] = v
}
func (__ OfUint64NComplex64) Delete(k uint64, v complex64) {
	delete(__, k)
}
func (__ OfUint64NComplex64) Range(f func(k uint64, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NComplex64 = OfUint64NComplex64
type OfUint64NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfUint64NComplex64
}

func NewOfUint64NComplex64St(somes OfUint64NComplex64) *OfUint64NComplex64St {
	return &OfUint64NComplex64St{
		_OfUint64NComplex64: somes,
	}
}

type OfUint64NErrorIf interface {
	Load(uint64) (error, error)
}

type OfUint64NErrorMutIf interface {
	Store(uint64, error)
	Delete(uint64)
}

type OfUint64NErrorIterIf interface {
	Range(func(uint64, error) bool)
}

type OfUint64NError map[uint64]error

func (__ OfUint64NError) Load(k uint64) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NError) Store(k uint64, v error) {
	__[k] = v
}
func (__ OfUint64NError) Delete(k uint64, v error) {
	delete(__, k)
}
func (__ OfUint64NError) Range(f func(k uint64, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NError = OfUint64NError
type OfUint64NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NError
}

func NewOfUint64NErrorSt(somes OfUint64NError) *OfUint64NErrorSt {
	return &OfUint64NErrorSt{
		_OfUint64NError: somes,
	}
}

type OfUint64NFloat32If interface {
	Load(uint64) (float32, error)
}

type OfUint64NFloat32MutIf interface {
	Store(uint64, float32)
	Delete(uint64)
}

type OfUint64NFloat32IterIf interface {
	Range(func(uint64, float32) bool)
}

type OfUint64NFloat32 map[uint64]float32

func (__ OfUint64NFloat32) Load(k uint64) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NFloat32) Store(k uint64, v float32) {
	__[k] = v
}
func (__ OfUint64NFloat32) Delete(k uint64, v float32) {
	delete(__, k)
}
func (__ OfUint64NFloat32) Range(f func(k uint64, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NFloat32 = OfUint64NFloat32
type OfUint64NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfUint64NFloat32
}

func NewOfUint64NFloat32St(somes OfUint64NFloat32) *OfUint64NFloat32St {
	return &OfUint64NFloat32St{
		_OfUint64NFloat32: somes,
	}
}

type OfUint64NFloat64If interface {
	Load(uint64) (float64, error)
}

type OfUint64NFloat64MutIf interface {
	Store(uint64, float64)
	Delete(uint64)
}

type OfUint64NFloat64IterIf interface {
	Range(func(uint64, float64) bool)
}

type OfUint64NFloat64 map[uint64]float64

func (__ OfUint64NFloat64) Load(k uint64) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NFloat64) Store(k uint64, v float64) {
	__[k] = v
}
func (__ OfUint64NFloat64) Delete(k uint64, v float64) {
	delete(__, k)
}
func (__ OfUint64NFloat64) Range(f func(k uint64, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NFloat64 = OfUint64NFloat64
type OfUint64NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfUint64NFloat64
}

func NewOfUint64NFloat64St(somes OfUint64NFloat64) *OfUint64NFloat64St {
	return &OfUint64NFloat64St{
		_OfUint64NFloat64: somes,
	}
}

type OfUint64NIntIf interface {
	Load(uint64) (int, error)
}

type OfUint64NIntMutIf interface {
	Store(uint64, int)
	Delete(uint64)
}

type OfUint64NIntIterIf interface {
	Range(func(uint64, int) bool)
}

type OfUint64NInt map[uint64]int

func (__ OfUint64NInt) Load(k uint64) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NInt) Store(k uint64, v int) {
	__[k] = v
}
func (__ OfUint64NInt) Delete(k uint64, v int) {
	delete(__, k)
}
func (__ OfUint64NInt) Range(f func(k uint64, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NInt = OfUint64NInt
type OfUint64NIntSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NInt
}

func NewOfUint64NIntSt(somes OfUint64NInt) *OfUint64NIntSt {
	return &OfUint64NIntSt{
		_OfUint64NInt: somes,
	}
}

type OfUint64NInt16If interface {
	Load(uint64) (int16, error)
}

type OfUint64NInt16MutIf interface {
	Store(uint64, int16)
	Delete(uint64)
}

type OfUint64NInt16IterIf interface {
	Range(func(uint64, int16) bool)
}

type OfUint64NInt16 map[uint64]int16

func (__ OfUint64NInt16) Load(k uint64) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NInt16) Store(k uint64, v int16) {
	__[k] = v
}
func (__ OfUint64NInt16) Delete(k uint64, v int16) {
	delete(__, k)
}
func (__ OfUint64NInt16) Range(f func(k uint64, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NInt16 = OfUint64NInt16
type OfUint64NInt16St struct {
	// do not want to export but want to use embedding method
	_OfUint64NInt16
}

func NewOfUint64NInt16St(somes OfUint64NInt16) *OfUint64NInt16St {
	return &OfUint64NInt16St{
		_OfUint64NInt16: somes,
	}
}

type OfUint64NInt32If interface {
	Load(uint64) (int32, error)
}

type OfUint64NInt32MutIf interface {
	Store(uint64, int32)
	Delete(uint64)
}

type OfUint64NInt32IterIf interface {
	Range(func(uint64, int32) bool)
}

type OfUint64NInt32 map[uint64]int32

func (__ OfUint64NInt32) Load(k uint64) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NInt32) Store(k uint64, v int32) {
	__[k] = v
}
func (__ OfUint64NInt32) Delete(k uint64, v int32) {
	delete(__, k)
}
func (__ OfUint64NInt32) Range(f func(k uint64, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NInt32 = OfUint64NInt32
type OfUint64NInt32St struct {
	// do not want to export but want to use embedding method
	_OfUint64NInt32
}

func NewOfUint64NInt32St(somes OfUint64NInt32) *OfUint64NInt32St {
	return &OfUint64NInt32St{
		_OfUint64NInt32: somes,
	}
}

type OfUint64NInt64If interface {
	Load(uint64) (int64, error)
}

type OfUint64NInt64MutIf interface {
	Store(uint64, int64)
	Delete(uint64)
}

type OfUint64NInt64IterIf interface {
	Range(func(uint64, int64) bool)
}

type OfUint64NInt64 map[uint64]int64

func (__ OfUint64NInt64) Load(k uint64) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NInt64) Store(k uint64, v int64) {
	__[k] = v
}
func (__ OfUint64NInt64) Delete(k uint64, v int64) {
	delete(__, k)
}
func (__ OfUint64NInt64) Range(f func(k uint64, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NInt64 = OfUint64NInt64
type OfUint64NInt64St struct {
	// do not want to export but want to use embedding method
	_OfUint64NInt64
}

func NewOfUint64NInt64St(somes OfUint64NInt64) *OfUint64NInt64St {
	return &OfUint64NInt64St{
		_OfUint64NInt64: somes,
	}
}

type OfUint64NInt8If interface {
	Load(uint64) (int8, error)
}

type OfUint64NInt8MutIf interface {
	Store(uint64, int8)
	Delete(uint64)
}

type OfUint64NInt8IterIf interface {
	Range(func(uint64, int8) bool)
}

type OfUint64NInt8 map[uint64]int8

func (__ OfUint64NInt8) Load(k uint64) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NInt8) Store(k uint64, v int8) {
	__[k] = v
}
func (__ OfUint64NInt8) Delete(k uint64, v int8) {
	delete(__, k)
}
func (__ OfUint64NInt8) Range(f func(k uint64, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NInt8 = OfUint64NInt8
type OfUint64NInt8St struct {
	// do not want to export but want to use embedding method
	_OfUint64NInt8
}

func NewOfUint64NInt8St(somes OfUint64NInt8) *OfUint64NInt8St {
	return &OfUint64NInt8St{
		_OfUint64NInt8: somes,
	}
}

type OfUint64NRuneIf interface {
	Load(uint64) (rune, error)
}

type OfUint64NRuneMutIf interface {
	Store(uint64, rune)
	Delete(uint64)
}

type OfUint64NRuneIterIf interface {
	Range(func(uint64, rune) bool)
}

type OfUint64NRune map[uint64]rune

func (__ OfUint64NRune) Load(k uint64) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NRune) Store(k uint64, v rune) {
	__[k] = v
}
func (__ OfUint64NRune) Delete(k uint64, v rune) {
	delete(__, k)
}
func (__ OfUint64NRune) Range(f func(k uint64, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NRune = OfUint64NRune
type OfUint64NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NRune
}

func NewOfUint64NRuneSt(somes OfUint64NRune) *OfUint64NRuneSt {
	return &OfUint64NRuneSt{
		_OfUint64NRune: somes,
	}
}

type OfUint64NStringIf interface {
	Load(uint64) (string, error)
}

type OfUint64NStringMutIf interface {
	Store(uint64, string)
	Delete(uint64)
}

type OfUint64NStringIterIf interface {
	Range(func(uint64, string) bool)
}

type OfUint64NString map[uint64]string

func (__ OfUint64NString) Load(k uint64) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NString) Store(k uint64, v string) {
	__[k] = v
}
func (__ OfUint64NString) Delete(k uint64, v string) {
	delete(__, k)
}
func (__ OfUint64NString) Range(f func(k uint64, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NString = OfUint64NString
type OfUint64NStringSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NString
}

func NewOfUint64NStringSt(somes OfUint64NString) *OfUint64NStringSt {
	return &OfUint64NStringSt{
		_OfUint64NString: somes,
	}
}

type OfUint64NUintIf interface {
	Load(uint64) (uint, error)
}

type OfUint64NUintMutIf interface {
	Store(uint64, uint)
	Delete(uint64)
}

type OfUint64NUintIterIf interface {
	Range(func(uint64, uint) bool)
}

type OfUint64NUint map[uint64]uint

func (__ OfUint64NUint) Load(k uint64) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NUint) Store(k uint64, v uint) {
	__[k] = v
}
func (__ OfUint64NUint) Delete(k uint64, v uint) {
	delete(__, k)
}
func (__ OfUint64NUint) Range(f func(k uint64, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NUint = OfUint64NUint
type OfUint64NUintSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NUint
}

func NewOfUint64NUintSt(somes OfUint64NUint) *OfUint64NUintSt {
	return &OfUint64NUintSt{
		_OfUint64NUint: somes,
	}
}

type OfUint64NUint16If interface {
	Load(uint64) (uint16, error)
}

type OfUint64NUint16MutIf interface {
	Store(uint64, uint16)
	Delete(uint64)
}

type OfUint64NUint16IterIf interface {
	Range(func(uint64, uint16) bool)
}

type OfUint64NUint16 map[uint64]uint16

func (__ OfUint64NUint16) Load(k uint64) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NUint16) Store(k uint64, v uint16) {
	__[k] = v
}
func (__ OfUint64NUint16) Delete(k uint64, v uint16) {
	delete(__, k)
}
func (__ OfUint64NUint16) Range(f func(k uint64, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NUint16 = OfUint64NUint16
type OfUint64NUint16St struct {
	// do not want to export but want to use embedding method
	_OfUint64NUint16
}

func NewOfUint64NUint16St(somes OfUint64NUint16) *OfUint64NUint16St {
	return &OfUint64NUint16St{
		_OfUint64NUint16: somes,
	}
}

type OfUint64NUint32If interface {
	Load(uint64) (uint32, error)
}

type OfUint64NUint32MutIf interface {
	Store(uint64, uint32)
	Delete(uint64)
}

type OfUint64NUint32IterIf interface {
	Range(func(uint64, uint32) bool)
}

type OfUint64NUint32 map[uint64]uint32

func (__ OfUint64NUint32) Load(k uint64) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NUint32) Store(k uint64, v uint32) {
	__[k] = v
}
func (__ OfUint64NUint32) Delete(k uint64, v uint32) {
	delete(__, k)
}
func (__ OfUint64NUint32) Range(f func(k uint64, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NUint32 = OfUint64NUint32
type OfUint64NUint32St struct {
	// do not want to export but want to use embedding method
	_OfUint64NUint32
}

func NewOfUint64NUint32St(somes OfUint64NUint32) *OfUint64NUint32St {
	return &OfUint64NUint32St{
		_OfUint64NUint32: somes,
	}
}

type OfUint64NUint64If interface {
	Load(uint64) (uint64, error)
}

type OfUint64NUint64MutIf interface {
	Store(uint64, uint64)
	Delete(uint64)
}

type OfUint64NUint64IterIf interface {
	Range(func(uint64, uint64) bool)
}

type OfUint64NUint64 map[uint64]uint64

func (__ OfUint64NUint64) Load(k uint64) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NUint64) Store(k uint64, v uint64) {
	__[k] = v
}
func (__ OfUint64NUint64) Delete(k uint64, v uint64) {
	delete(__, k)
}
func (__ OfUint64NUint64) Range(f func(k uint64, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NUint64 = OfUint64NUint64
type OfUint64NUint64St struct {
	// do not want to export but want to use embedding method
	_OfUint64NUint64
}

func NewOfUint64NUint64St(somes OfUint64NUint64) *OfUint64NUint64St {
	return &OfUint64NUint64St{
		_OfUint64NUint64: somes,
	}
}

type OfUint64NUint8If interface {
	Load(uint64) (uint8, error)
}

type OfUint64NUint8MutIf interface {
	Store(uint64, uint8)
	Delete(uint64)
}

type OfUint64NUint8IterIf interface {
	Range(func(uint64, uint8) bool)
}

type OfUint64NUint8 map[uint64]uint8

func (__ OfUint64NUint8) Load(k uint64) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NUint8) Store(k uint64, v uint8) {
	__[k] = v
}
func (__ OfUint64NUint8) Delete(k uint64, v uint8) {
	delete(__, k)
}
func (__ OfUint64NUint8) Range(f func(k uint64, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NUint8 = OfUint64NUint8
type OfUint64NUint8St struct {
	// do not want to export but want to use embedding method
	_OfUint64NUint8
}

func NewOfUint64NUint8St(somes OfUint64NUint8) *OfUint64NUint8St {
	return &OfUint64NUint8St{
		_OfUint64NUint8: somes,
	}
}

type OfUint64NUintptrIf interface {
	Load(uint64) (uintptr, error)
}

type OfUint64NUintptrMutIf interface {
	Store(uint64, uintptr)
	Delete(uint64)
}

type OfUint64NUintptrIterIf interface {
	Range(func(uint64, uintptr) bool)
}

type OfUint64NUintptr map[uint64]uintptr

func (__ OfUint64NUintptr) Load(k uint64) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NUintptr) Store(k uint64, v uintptr) {
	__[k] = v
}
func (__ OfUint64NUintptr) Delete(k uint64, v uintptr) {
	delete(__, k)
}
func (__ OfUint64NUintptr) Range(f func(k uint64, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NUintptr = OfUint64NUintptr
type OfUint64NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NUintptr
}

func NewOfUint64NUintptrSt(somes OfUint64NUintptr) *OfUint64NUintptrSt {
	return &OfUint64NUintptrSt{
		_OfUint64NUintptr: somes,
	}
}

type OfUint64NInterfaceIf interface {
	Load(uint64) (interface{}, error)
}

type OfUint64NInterfaceMutIf interface {
	Store(uint64, interface{})
	Delete(uint64)
}

type OfUint64NInterfaceIterIf interface {
	Range(func(uint64, interface{}) bool)
}

type OfUint64NInterface map[uint64]interface{}

func (__ OfUint64NInterface) Load(k uint64) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint64NInterface) Store(k uint64, v interface{}) {
	__[k] = v
}
func (__ OfUint64NInterface) Delete(k uint64, v interface{}) {
	delete(__, k)
}
func (__ OfUint64NInterface) Range(f func(k uint64, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint64NInterface = OfUint64NInterface
type OfUint64NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfUint64NInterface
}

func NewOfUint64NInterfaceSt(somes OfUint64NInterface) *OfUint64NInterfaceSt {
	return &OfUint64NInterfaceSt{
		_OfUint64NInterface: somes,
	}
}

type OfUint8NBoolIf interface {
	Load(uint8) (bool, error)
}

type OfUint8NBoolMutIf interface {
	Store(uint8, bool)
	Delete(uint8)
}

type OfUint8NBoolIterIf interface {
	Range(func(uint8, bool) bool)
}

type OfUint8NBool map[uint8]bool

func (__ OfUint8NBool) Load(k uint8) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NBool) Store(k uint8, v bool) {
	__[k] = v
}
func (__ OfUint8NBool) Delete(k uint8, v bool) {
	delete(__, k)
}
func (__ OfUint8NBool) Range(f func(k uint8, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NBool = OfUint8NBool
type OfUint8NBoolSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NBool
}

func NewOfUint8NBoolSt(somes OfUint8NBool) *OfUint8NBoolSt {
	return &OfUint8NBoolSt{
		_OfUint8NBool: somes,
	}
}

type OfUint8NByteIf interface {
	Load(uint8) (byte, error)
}

type OfUint8NByteMutIf interface {
	Store(uint8, byte)
	Delete(uint8)
}

type OfUint8NByteIterIf interface {
	Range(func(uint8, byte) bool)
}

type OfUint8NByte map[uint8]byte

func (__ OfUint8NByte) Load(k uint8) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NByte) Store(k uint8, v byte) {
	__[k] = v
}
func (__ OfUint8NByte) Delete(k uint8, v byte) {
	delete(__, k)
}
func (__ OfUint8NByte) Range(f func(k uint8, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NByte = OfUint8NByte
type OfUint8NByteSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NByte
}

func NewOfUint8NByteSt(somes OfUint8NByte) *OfUint8NByteSt {
	return &OfUint8NByteSt{
		_OfUint8NByte: somes,
	}
}

type OfUint8NComplex128If interface {
	Load(uint8) (complex128, error)
}

type OfUint8NComplex128MutIf interface {
	Store(uint8, complex128)
	Delete(uint8)
}

type OfUint8NComplex128IterIf interface {
	Range(func(uint8, complex128) bool)
}

type OfUint8NComplex128 map[uint8]complex128

func (__ OfUint8NComplex128) Load(k uint8) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NComplex128) Store(k uint8, v complex128) {
	__[k] = v
}
func (__ OfUint8NComplex128) Delete(k uint8, v complex128) {
	delete(__, k)
}
func (__ OfUint8NComplex128) Range(f func(k uint8, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NComplex128 = OfUint8NComplex128
type OfUint8NComplex128St struct {
	// do not want to export but want to use embedding method
	_OfUint8NComplex128
}

func NewOfUint8NComplex128St(somes OfUint8NComplex128) *OfUint8NComplex128St {
	return &OfUint8NComplex128St{
		_OfUint8NComplex128: somes,
	}
}

type OfUint8NComplex64If interface {
	Load(uint8) (complex64, error)
}

type OfUint8NComplex64MutIf interface {
	Store(uint8, complex64)
	Delete(uint8)
}

type OfUint8NComplex64IterIf interface {
	Range(func(uint8, complex64) bool)
}

type OfUint8NComplex64 map[uint8]complex64

func (__ OfUint8NComplex64) Load(k uint8) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NComplex64) Store(k uint8, v complex64) {
	__[k] = v
}
func (__ OfUint8NComplex64) Delete(k uint8, v complex64) {
	delete(__, k)
}
func (__ OfUint8NComplex64) Range(f func(k uint8, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NComplex64 = OfUint8NComplex64
type OfUint8NComplex64St struct {
	// do not want to export but want to use embedding method
	_OfUint8NComplex64
}

func NewOfUint8NComplex64St(somes OfUint8NComplex64) *OfUint8NComplex64St {
	return &OfUint8NComplex64St{
		_OfUint8NComplex64: somes,
	}
}

type OfUint8NErrorIf interface {
	Load(uint8) (error, error)
}

type OfUint8NErrorMutIf interface {
	Store(uint8, error)
	Delete(uint8)
}

type OfUint8NErrorIterIf interface {
	Range(func(uint8, error) bool)
}

type OfUint8NError map[uint8]error

func (__ OfUint8NError) Load(k uint8) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NError) Store(k uint8, v error) {
	__[k] = v
}
func (__ OfUint8NError) Delete(k uint8, v error) {
	delete(__, k)
}
func (__ OfUint8NError) Range(f func(k uint8, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NError = OfUint8NError
type OfUint8NErrorSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NError
}

func NewOfUint8NErrorSt(somes OfUint8NError) *OfUint8NErrorSt {
	return &OfUint8NErrorSt{
		_OfUint8NError: somes,
	}
}

type OfUint8NFloat32If interface {
	Load(uint8) (float32, error)
}

type OfUint8NFloat32MutIf interface {
	Store(uint8, float32)
	Delete(uint8)
}

type OfUint8NFloat32IterIf interface {
	Range(func(uint8, float32) bool)
}

type OfUint8NFloat32 map[uint8]float32

func (__ OfUint8NFloat32) Load(k uint8) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NFloat32) Store(k uint8, v float32) {
	__[k] = v
}
func (__ OfUint8NFloat32) Delete(k uint8, v float32) {
	delete(__, k)
}
func (__ OfUint8NFloat32) Range(f func(k uint8, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NFloat32 = OfUint8NFloat32
type OfUint8NFloat32St struct {
	// do not want to export but want to use embedding method
	_OfUint8NFloat32
}

func NewOfUint8NFloat32St(somes OfUint8NFloat32) *OfUint8NFloat32St {
	return &OfUint8NFloat32St{
		_OfUint8NFloat32: somes,
	}
}

type OfUint8NFloat64If interface {
	Load(uint8) (float64, error)
}

type OfUint8NFloat64MutIf interface {
	Store(uint8, float64)
	Delete(uint8)
}

type OfUint8NFloat64IterIf interface {
	Range(func(uint8, float64) bool)
}

type OfUint8NFloat64 map[uint8]float64

func (__ OfUint8NFloat64) Load(k uint8) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NFloat64) Store(k uint8, v float64) {
	__[k] = v
}
func (__ OfUint8NFloat64) Delete(k uint8, v float64) {
	delete(__, k)
}
func (__ OfUint8NFloat64) Range(f func(k uint8, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NFloat64 = OfUint8NFloat64
type OfUint8NFloat64St struct {
	// do not want to export but want to use embedding method
	_OfUint8NFloat64
}

func NewOfUint8NFloat64St(somes OfUint8NFloat64) *OfUint8NFloat64St {
	return &OfUint8NFloat64St{
		_OfUint8NFloat64: somes,
	}
}

type OfUint8NIntIf interface {
	Load(uint8) (int, error)
}

type OfUint8NIntMutIf interface {
	Store(uint8, int)
	Delete(uint8)
}

type OfUint8NIntIterIf interface {
	Range(func(uint8, int) bool)
}

type OfUint8NInt map[uint8]int

func (__ OfUint8NInt) Load(k uint8) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NInt) Store(k uint8, v int) {
	__[k] = v
}
func (__ OfUint8NInt) Delete(k uint8, v int) {
	delete(__, k)
}
func (__ OfUint8NInt) Range(f func(k uint8, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NInt = OfUint8NInt
type OfUint8NIntSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NInt
}

func NewOfUint8NIntSt(somes OfUint8NInt) *OfUint8NIntSt {
	return &OfUint8NIntSt{
		_OfUint8NInt: somes,
	}
}

type OfUint8NInt16If interface {
	Load(uint8) (int16, error)
}

type OfUint8NInt16MutIf interface {
	Store(uint8, int16)
	Delete(uint8)
}

type OfUint8NInt16IterIf interface {
	Range(func(uint8, int16) bool)
}

type OfUint8NInt16 map[uint8]int16

func (__ OfUint8NInt16) Load(k uint8) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NInt16) Store(k uint8, v int16) {
	__[k] = v
}
func (__ OfUint8NInt16) Delete(k uint8, v int16) {
	delete(__, k)
}
func (__ OfUint8NInt16) Range(f func(k uint8, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NInt16 = OfUint8NInt16
type OfUint8NInt16St struct {
	// do not want to export but want to use embedding method
	_OfUint8NInt16
}

func NewOfUint8NInt16St(somes OfUint8NInt16) *OfUint8NInt16St {
	return &OfUint8NInt16St{
		_OfUint8NInt16: somes,
	}
}

type OfUint8NInt32If interface {
	Load(uint8) (int32, error)
}

type OfUint8NInt32MutIf interface {
	Store(uint8, int32)
	Delete(uint8)
}

type OfUint8NInt32IterIf interface {
	Range(func(uint8, int32) bool)
}

type OfUint8NInt32 map[uint8]int32

func (__ OfUint8NInt32) Load(k uint8) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NInt32) Store(k uint8, v int32) {
	__[k] = v
}
func (__ OfUint8NInt32) Delete(k uint8, v int32) {
	delete(__, k)
}
func (__ OfUint8NInt32) Range(f func(k uint8, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NInt32 = OfUint8NInt32
type OfUint8NInt32St struct {
	// do not want to export but want to use embedding method
	_OfUint8NInt32
}

func NewOfUint8NInt32St(somes OfUint8NInt32) *OfUint8NInt32St {
	return &OfUint8NInt32St{
		_OfUint8NInt32: somes,
	}
}

type OfUint8NInt64If interface {
	Load(uint8) (int64, error)
}

type OfUint8NInt64MutIf interface {
	Store(uint8, int64)
	Delete(uint8)
}

type OfUint8NInt64IterIf interface {
	Range(func(uint8, int64) bool)
}

type OfUint8NInt64 map[uint8]int64

func (__ OfUint8NInt64) Load(k uint8) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NInt64) Store(k uint8, v int64) {
	__[k] = v
}
func (__ OfUint8NInt64) Delete(k uint8, v int64) {
	delete(__, k)
}
func (__ OfUint8NInt64) Range(f func(k uint8, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NInt64 = OfUint8NInt64
type OfUint8NInt64St struct {
	// do not want to export but want to use embedding method
	_OfUint8NInt64
}

func NewOfUint8NInt64St(somes OfUint8NInt64) *OfUint8NInt64St {
	return &OfUint8NInt64St{
		_OfUint8NInt64: somes,
	}
}

type OfUint8NInt8If interface {
	Load(uint8) (int8, error)
}

type OfUint8NInt8MutIf interface {
	Store(uint8, int8)
	Delete(uint8)
}

type OfUint8NInt8IterIf interface {
	Range(func(uint8, int8) bool)
}

type OfUint8NInt8 map[uint8]int8

func (__ OfUint8NInt8) Load(k uint8) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NInt8) Store(k uint8, v int8) {
	__[k] = v
}
func (__ OfUint8NInt8) Delete(k uint8, v int8) {
	delete(__, k)
}
func (__ OfUint8NInt8) Range(f func(k uint8, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NInt8 = OfUint8NInt8
type OfUint8NInt8St struct {
	// do not want to export but want to use embedding method
	_OfUint8NInt8
}

func NewOfUint8NInt8St(somes OfUint8NInt8) *OfUint8NInt8St {
	return &OfUint8NInt8St{
		_OfUint8NInt8: somes,
	}
}

type OfUint8NRuneIf interface {
	Load(uint8) (rune, error)
}

type OfUint8NRuneMutIf interface {
	Store(uint8, rune)
	Delete(uint8)
}

type OfUint8NRuneIterIf interface {
	Range(func(uint8, rune) bool)
}

type OfUint8NRune map[uint8]rune

func (__ OfUint8NRune) Load(k uint8) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NRune) Store(k uint8, v rune) {
	__[k] = v
}
func (__ OfUint8NRune) Delete(k uint8, v rune) {
	delete(__, k)
}
func (__ OfUint8NRune) Range(f func(k uint8, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NRune = OfUint8NRune
type OfUint8NRuneSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NRune
}

func NewOfUint8NRuneSt(somes OfUint8NRune) *OfUint8NRuneSt {
	return &OfUint8NRuneSt{
		_OfUint8NRune: somes,
	}
}

type OfUint8NStringIf interface {
	Load(uint8) (string, error)
}

type OfUint8NStringMutIf interface {
	Store(uint8, string)
	Delete(uint8)
}

type OfUint8NStringIterIf interface {
	Range(func(uint8, string) bool)
}

type OfUint8NString map[uint8]string

func (__ OfUint8NString) Load(k uint8) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NString) Store(k uint8, v string) {
	__[k] = v
}
func (__ OfUint8NString) Delete(k uint8, v string) {
	delete(__, k)
}
func (__ OfUint8NString) Range(f func(k uint8, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NString = OfUint8NString
type OfUint8NStringSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NString
}

func NewOfUint8NStringSt(somes OfUint8NString) *OfUint8NStringSt {
	return &OfUint8NStringSt{
		_OfUint8NString: somes,
	}
}

type OfUint8NUintIf interface {
	Load(uint8) (uint, error)
}

type OfUint8NUintMutIf interface {
	Store(uint8, uint)
	Delete(uint8)
}

type OfUint8NUintIterIf interface {
	Range(func(uint8, uint) bool)
}

type OfUint8NUint map[uint8]uint

func (__ OfUint8NUint) Load(k uint8) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NUint) Store(k uint8, v uint) {
	__[k] = v
}
func (__ OfUint8NUint) Delete(k uint8, v uint) {
	delete(__, k)
}
func (__ OfUint8NUint) Range(f func(k uint8, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NUint = OfUint8NUint
type OfUint8NUintSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NUint
}

func NewOfUint8NUintSt(somes OfUint8NUint) *OfUint8NUintSt {
	return &OfUint8NUintSt{
		_OfUint8NUint: somes,
	}
}

type OfUint8NUint16If interface {
	Load(uint8) (uint16, error)
}

type OfUint8NUint16MutIf interface {
	Store(uint8, uint16)
	Delete(uint8)
}

type OfUint8NUint16IterIf interface {
	Range(func(uint8, uint16) bool)
}

type OfUint8NUint16 map[uint8]uint16

func (__ OfUint8NUint16) Load(k uint8) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NUint16) Store(k uint8, v uint16) {
	__[k] = v
}
func (__ OfUint8NUint16) Delete(k uint8, v uint16) {
	delete(__, k)
}
func (__ OfUint8NUint16) Range(f func(k uint8, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NUint16 = OfUint8NUint16
type OfUint8NUint16St struct {
	// do not want to export but want to use embedding method
	_OfUint8NUint16
}

func NewOfUint8NUint16St(somes OfUint8NUint16) *OfUint8NUint16St {
	return &OfUint8NUint16St{
		_OfUint8NUint16: somes,
	}
}

type OfUint8NUint32If interface {
	Load(uint8) (uint32, error)
}

type OfUint8NUint32MutIf interface {
	Store(uint8, uint32)
	Delete(uint8)
}

type OfUint8NUint32IterIf interface {
	Range(func(uint8, uint32) bool)
}

type OfUint8NUint32 map[uint8]uint32

func (__ OfUint8NUint32) Load(k uint8) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NUint32) Store(k uint8, v uint32) {
	__[k] = v
}
func (__ OfUint8NUint32) Delete(k uint8, v uint32) {
	delete(__, k)
}
func (__ OfUint8NUint32) Range(f func(k uint8, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NUint32 = OfUint8NUint32
type OfUint8NUint32St struct {
	// do not want to export but want to use embedding method
	_OfUint8NUint32
}

func NewOfUint8NUint32St(somes OfUint8NUint32) *OfUint8NUint32St {
	return &OfUint8NUint32St{
		_OfUint8NUint32: somes,
	}
}

type OfUint8NUint64If interface {
	Load(uint8) (uint64, error)
}

type OfUint8NUint64MutIf interface {
	Store(uint8, uint64)
	Delete(uint8)
}

type OfUint8NUint64IterIf interface {
	Range(func(uint8, uint64) bool)
}

type OfUint8NUint64 map[uint8]uint64

func (__ OfUint8NUint64) Load(k uint8) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NUint64) Store(k uint8, v uint64) {
	__[k] = v
}
func (__ OfUint8NUint64) Delete(k uint8, v uint64) {
	delete(__, k)
}
func (__ OfUint8NUint64) Range(f func(k uint8, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NUint64 = OfUint8NUint64
type OfUint8NUint64St struct {
	// do not want to export but want to use embedding method
	_OfUint8NUint64
}

func NewOfUint8NUint64St(somes OfUint8NUint64) *OfUint8NUint64St {
	return &OfUint8NUint64St{
		_OfUint8NUint64: somes,
	}
}

type OfUint8NUint8If interface {
	Load(uint8) (uint8, error)
}

type OfUint8NUint8MutIf interface {
	Store(uint8, uint8)
	Delete(uint8)
}

type OfUint8NUint8IterIf interface {
	Range(func(uint8, uint8) bool)
}

type OfUint8NUint8 map[uint8]uint8

func (__ OfUint8NUint8) Load(k uint8) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NUint8) Store(k uint8, v uint8) {
	__[k] = v
}
func (__ OfUint8NUint8) Delete(k uint8, v uint8) {
	delete(__, k)
}
func (__ OfUint8NUint8) Range(f func(k uint8, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NUint8 = OfUint8NUint8
type OfUint8NUint8St struct {
	// do not want to export but want to use embedding method
	_OfUint8NUint8
}

func NewOfUint8NUint8St(somes OfUint8NUint8) *OfUint8NUint8St {
	return &OfUint8NUint8St{
		_OfUint8NUint8: somes,
	}
}

type OfUint8NUintptrIf interface {
	Load(uint8) (uintptr, error)
}

type OfUint8NUintptrMutIf interface {
	Store(uint8, uintptr)
	Delete(uint8)
}

type OfUint8NUintptrIterIf interface {
	Range(func(uint8, uintptr) bool)
}

type OfUint8NUintptr map[uint8]uintptr

func (__ OfUint8NUintptr) Load(k uint8) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NUintptr) Store(k uint8, v uintptr) {
	__[k] = v
}
func (__ OfUint8NUintptr) Delete(k uint8, v uintptr) {
	delete(__, k)
}
func (__ OfUint8NUintptr) Range(f func(k uint8, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NUintptr = OfUint8NUintptr
type OfUint8NUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NUintptr
}

func NewOfUint8NUintptrSt(somes OfUint8NUintptr) *OfUint8NUintptrSt {
	return &OfUint8NUintptrSt{
		_OfUint8NUintptr: somes,
	}
}

type OfUint8NInterfaceIf interface {
	Load(uint8) (interface{}, error)
}

type OfUint8NInterfaceMutIf interface {
	Store(uint8, interface{})
	Delete(uint8)
}

type OfUint8NInterfaceIterIf interface {
	Range(func(uint8, interface{}) bool)
}

type OfUint8NInterface map[uint8]interface{}

func (__ OfUint8NInterface) Load(k uint8) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUint8NInterface) Store(k uint8, v interface{}) {
	__[k] = v
}
func (__ OfUint8NInterface) Delete(k uint8, v interface{}) {
	delete(__, k)
}
func (__ OfUint8NInterface) Range(f func(k uint8, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUint8NInterface = OfUint8NInterface
type OfUint8NInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfUint8NInterface
}

func NewOfUint8NInterfaceSt(somes OfUint8NInterface) *OfUint8NInterfaceSt {
	return &OfUint8NInterfaceSt{
		_OfUint8NInterface: somes,
	}
}

type OfUintptrNBoolIf interface {
	Load(uintptr) (bool, error)
}

type OfUintptrNBoolMutIf interface {
	Store(uintptr, bool)
	Delete(uintptr)
}

type OfUintptrNBoolIterIf interface {
	Range(func(uintptr, bool) bool)
}

type OfUintptrNBool map[uintptr]bool

func (__ OfUintptrNBool) Load(k uintptr) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNBool) Store(k uintptr, v bool) {
	__[k] = v
}
func (__ OfUintptrNBool) Delete(k uintptr, v bool) {
	delete(__, k)
}
func (__ OfUintptrNBool) Range(f func(k uintptr, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNBool = OfUintptrNBool
type OfUintptrNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNBool
}

func NewOfUintptrNBoolSt(somes OfUintptrNBool) *OfUintptrNBoolSt {
	return &OfUintptrNBoolSt{
		_OfUintptrNBool: somes,
	}
}

type OfUintptrNByteIf interface {
	Load(uintptr) (byte, error)
}

type OfUintptrNByteMutIf interface {
	Store(uintptr, byte)
	Delete(uintptr)
}

type OfUintptrNByteIterIf interface {
	Range(func(uintptr, byte) bool)
}

type OfUintptrNByte map[uintptr]byte

func (__ OfUintptrNByte) Load(k uintptr) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNByte) Store(k uintptr, v byte) {
	__[k] = v
}
func (__ OfUintptrNByte) Delete(k uintptr, v byte) {
	delete(__, k)
}
func (__ OfUintptrNByte) Range(f func(k uintptr, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNByte = OfUintptrNByte
type OfUintptrNByteSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNByte
}

func NewOfUintptrNByteSt(somes OfUintptrNByte) *OfUintptrNByteSt {
	return &OfUintptrNByteSt{
		_OfUintptrNByte: somes,
	}
}

type OfUintptrNComplex128If interface {
	Load(uintptr) (complex128, error)
}

type OfUintptrNComplex128MutIf interface {
	Store(uintptr, complex128)
	Delete(uintptr)
}

type OfUintptrNComplex128IterIf interface {
	Range(func(uintptr, complex128) bool)
}

type OfUintptrNComplex128 map[uintptr]complex128

func (__ OfUintptrNComplex128) Load(k uintptr) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNComplex128) Store(k uintptr, v complex128) {
	__[k] = v
}
func (__ OfUintptrNComplex128) Delete(k uintptr, v complex128) {
	delete(__, k)
}
func (__ OfUintptrNComplex128) Range(f func(k uintptr, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNComplex128 = OfUintptrNComplex128
type OfUintptrNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNComplex128
}

func NewOfUintptrNComplex128St(somes OfUintptrNComplex128) *OfUintptrNComplex128St {
	return &OfUintptrNComplex128St{
		_OfUintptrNComplex128: somes,
	}
}

type OfUintptrNComplex64If interface {
	Load(uintptr) (complex64, error)
}

type OfUintptrNComplex64MutIf interface {
	Store(uintptr, complex64)
	Delete(uintptr)
}

type OfUintptrNComplex64IterIf interface {
	Range(func(uintptr, complex64) bool)
}

type OfUintptrNComplex64 map[uintptr]complex64

func (__ OfUintptrNComplex64) Load(k uintptr) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNComplex64) Store(k uintptr, v complex64) {
	__[k] = v
}
func (__ OfUintptrNComplex64) Delete(k uintptr, v complex64) {
	delete(__, k)
}
func (__ OfUintptrNComplex64) Range(f func(k uintptr, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNComplex64 = OfUintptrNComplex64
type OfUintptrNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNComplex64
}

func NewOfUintptrNComplex64St(somes OfUintptrNComplex64) *OfUintptrNComplex64St {
	return &OfUintptrNComplex64St{
		_OfUintptrNComplex64: somes,
	}
}

type OfUintptrNErrorIf interface {
	Load(uintptr) (error, error)
}

type OfUintptrNErrorMutIf interface {
	Store(uintptr, error)
	Delete(uintptr)
}

type OfUintptrNErrorIterIf interface {
	Range(func(uintptr, error) bool)
}

type OfUintptrNError map[uintptr]error

func (__ OfUintptrNError) Load(k uintptr) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNError) Store(k uintptr, v error) {
	__[k] = v
}
func (__ OfUintptrNError) Delete(k uintptr, v error) {
	delete(__, k)
}
func (__ OfUintptrNError) Range(f func(k uintptr, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNError = OfUintptrNError
type OfUintptrNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNError
}

func NewOfUintptrNErrorSt(somes OfUintptrNError) *OfUintptrNErrorSt {
	return &OfUintptrNErrorSt{
		_OfUintptrNError: somes,
	}
}

type OfUintptrNFloat32If interface {
	Load(uintptr) (float32, error)
}

type OfUintptrNFloat32MutIf interface {
	Store(uintptr, float32)
	Delete(uintptr)
}

type OfUintptrNFloat32IterIf interface {
	Range(func(uintptr, float32) bool)
}

type OfUintptrNFloat32 map[uintptr]float32

func (__ OfUintptrNFloat32) Load(k uintptr) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNFloat32) Store(k uintptr, v float32) {
	__[k] = v
}
func (__ OfUintptrNFloat32) Delete(k uintptr, v float32) {
	delete(__, k)
}
func (__ OfUintptrNFloat32) Range(f func(k uintptr, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNFloat32 = OfUintptrNFloat32
type OfUintptrNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNFloat32
}

func NewOfUintptrNFloat32St(somes OfUintptrNFloat32) *OfUintptrNFloat32St {
	return &OfUintptrNFloat32St{
		_OfUintptrNFloat32: somes,
	}
}

type OfUintptrNFloat64If interface {
	Load(uintptr) (float64, error)
}

type OfUintptrNFloat64MutIf interface {
	Store(uintptr, float64)
	Delete(uintptr)
}

type OfUintptrNFloat64IterIf interface {
	Range(func(uintptr, float64) bool)
}

type OfUintptrNFloat64 map[uintptr]float64

func (__ OfUintptrNFloat64) Load(k uintptr) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNFloat64) Store(k uintptr, v float64) {
	__[k] = v
}
func (__ OfUintptrNFloat64) Delete(k uintptr, v float64) {
	delete(__, k)
}
func (__ OfUintptrNFloat64) Range(f func(k uintptr, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNFloat64 = OfUintptrNFloat64
type OfUintptrNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNFloat64
}

func NewOfUintptrNFloat64St(somes OfUintptrNFloat64) *OfUintptrNFloat64St {
	return &OfUintptrNFloat64St{
		_OfUintptrNFloat64: somes,
	}
}

type OfUintptrNIntIf interface {
	Load(uintptr) (int, error)
}

type OfUintptrNIntMutIf interface {
	Store(uintptr, int)
	Delete(uintptr)
}

type OfUintptrNIntIterIf interface {
	Range(func(uintptr, int) bool)
}

type OfUintptrNInt map[uintptr]int

func (__ OfUintptrNInt) Load(k uintptr) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNInt) Store(k uintptr, v int) {
	__[k] = v
}
func (__ OfUintptrNInt) Delete(k uintptr, v int) {
	delete(__, k)
}
func (__ OfUintptrNInt) Range(f func(k uintptr, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNInt = OfUintptrNInt
type OfUintptrNIntSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNInt
}

func NewOfUintptrNIntSt(somes OfUintptrNInt) *OfUintptrNIntSt {
	return &OfUintptrNIntSt{
		_OfUintptrNInt: somes,
	}
}

type OfUintptrNInt16If interface {
	Load(uintptr) (int16, error)
}

type OfUintptrNInt16MutIf interface {
	Store(uintptr, int16)
	Delete(uintptr)
}

type OfUintptrNInt16IterIf interface {
	Range(func(uintptr, int16) bool)
}

type OfUintptrNInt16 map[uintptr]int16

func (__ OfUintptrNInt16) Load(k uintptr) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNInt16) Store(k uintptr, v int16) {
	__[k] = v
}
func (__ OfUintptrNInt16) Delete(k uintptr, v int16) {
	delete(__, k)
}
func (__ OfUintptrNInt16) Range(f func(k uintptr, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNInt16 = OfUintptrNInt16
type OfUintptrNInt16St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNInt16
}

func NewOfUintptrNInt16St(somes OfUintptrNInt16) *OfUintptrNInt16St {
	return &OfUintptrNInt16St{
		_OfUintptrNInt16: somes,
	}
}

type OfUintptrNInt32If interface {
	Load(uintptr) (int32, error)
}

type OfUintptrNInt32MutIf interface {
	Store(uintptr, int32)
	Delete(uintptr)
}

type OfUintptrNInt32IterIf interface {
	Range(func(uintptr, int32) bool)
}

type OfUintptrNInt32 map[uintptr]int32

func (__ OfUintptrNInt32) Load(k uintptr) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNInt32) Store(k uintptr, v int32) {
	__[k] = v
}
func (__ OfUintptrNInt32) Delete(k uintptr, v int32) {
	delete(__, k)
}
func (__ OfUintptrNInt32) Range(f func(k uintptr, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNInt32 = OfUintptrNInt32
type OfUintptrNInt32St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNInt32
}

func NewOfUintptrNInt32St(somes OfUintptrNInt32) *OfUintptrNInt32St {
	return &OfUintptrNInt32St{
		_OfUintptrNInt32: somes,
	}
}

type OfUintptrNInt64If interface {
	Load(uintptr) (int64, error)
}

type OfUintptrNInt64MutIf interface {
	Store(uintptr, int64)
	Delete(uintptr)
}

type OfUintptrNInt64IterIf interface {
	Range(func(uintptr, int64) bool)
}

type OfUintptrNInt64 map[uintptr]int64

func (__ OfUintptrNInt64) Load(k uintptr) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNInt64) Store(k uintptr, v int64) {
	__[k] = v
}
func (__ OfUintptrNInt64) Delete(k uintptr, v int64) {
	delete(__, k)
}
func (__ OfUintptrNInt64) Range(f func(k uintptr, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNInt64 = OfUintptrNInt64
type OfUintptrNInt64St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNInt64
}

func NewOfUintptrNInt64St(somes OfUintptrNInt64) *OfUintptrNInt64St {
	return &OfUintptrNInt64St{
		_OfUintptrNInt64: somes,
	}
}

type OfUintptrNInt8If interface {
	Load(uintptr) (int8, error)
}

type OfUintptrNInt8MutIf interface {
	Store(uintptr, int8)
	Delete(uintptr)
}

type OfUintptrNInt8IterIf interface {
	Range(func(uintptr, int8) bool)
}

type OfUintptrNInt8 map[uintptr]int8

func (__ OfUintptrNInt8) Load(k uintptr) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNInt8) Store(k uintptr, v int8) {
	__[k] = v
}
func (__ OfUintptrNInt8) Delete(k uintptr, v int8) {
	delete(__, k)
}
func (__ OfUintptrNInt8) Range(f func(k uintptr, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNInt8 = OfUintptrNInt8
type OfUintptrNInt8St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNInt8
}

func NewOfUintptrNInt8St(somes OfUintptrNInt8) *OfUintptrNInt8St {
	return &OfUintptrNInt8St{
		_OfUintptrNInt8: somes,
	}
}

type OfUintptrNRuneIf interface {
	Load(uintptr) (rune, error)
}

type OfUintptrNRuneMutIf interface {
	Store(uintptr, rune)
	Delete(uintptr)
}

type OfUintptrNRuneIterIf interface {
	Range(func(uintptr, rune) bool)
}

type OfUintptrNRune map[uintptr]rune

func (__ OfUintptrNRune) Load(k uintptr) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNRune) Store(k uintptr, v rune) {
	__[k] = v
}
func (__ OfUintptrNRune) Delete(k uintptr, v rune) {
	delete(__, k)
}
func (__ OfUintptrNRune) Range(f func(k uintptr, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNRune = OfUintptrNRune
type OfUintptrNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNRune
}

func NewOfUintptrNRuneSt(somes OfUintptrNRune) *OfUintptrNRuneSt {
	return &OfUintptrNRuneSt{
		_OfUintptrNRune: somes,
	}
}

type OfUintptrNStringIf interface {
	Load(uintptr) (string, error)
}

type OfUintptrNStringMutIf interface {
	Store(uintptr, string)
	Delete(uintptr)
}

type OfUintptrNStringIterIf interface {
	Range(func(uintptr, string) bool)
}

type OfUintptrNString map[uintptr]string

func (__ OfUintptrNString) Load(k uintptr) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNString) Store(k uintptr, v string) {
	__[k] = v
}
func (__ OfUintptrNString) Delete(k uintptr, v string) {
	delete(__, k)
}
func (__ OfUintptrNString) Range(f func(k uintptr, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNString = OfUintptrNString
type OfUintptrNStringSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNString
}

func NewOfUintptrNStringSt(somes OfUintptrNString) *OfUintptrNStringSt {
	return &OfUintptrNStringSt{
		_OfUintptrNString: somes,
	}
}

type OfUintptrNUintIf interface {
	Load(uintptr) (uint, error)
}

type OfUintptrNUintMutIf interface {
	Store(uintptr, uint)
	Delete(uintptr)
}

type OfUintptrNUintIterIf interface {
	Range(func(uintptr, uint) bool)
}

type OfUintptrNUint map[uintptr]uint

func (__ OfUintptrNUint) Load(k uintptr) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNUint) Store(k uintptr, v uint) {
	__[k] = v
}
func (__ OfUintptrNUint) Delete(k uintptr, v uint) {
	delete(__, k)
}
func (__ OfUintptrNUint) Range(f func(k uintptr, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNUint = OfUintptrNUint
type OfUintptrNUintSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNUint
}

func NewOfUintptrNUintSt(somes OfUintptrNUint) *OfUintptrNUintSt {
	return &OfUintptrNUintSt{
		_OfUintptrNUint: somes,
	}
}

type OfUintptrNUint16If interface {
	Load(uintptr) (uint16, error)
}

type OfUintptrNUint16MutIf interface {
	Store(uintptr, uint16)
	Delete(uintptr)
}

type OfUintptrNUint16IterIf interface {
	Range(func(uintptr, uint16) bool)
}

type OfUintptrNUint16 map[uintptr]uint16

func (__ OfUintptrNUint16) Load(k uintptr) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNUint16) Store(k uintptr, v uint16) {
	__[k] = v
}
func (__ OfUintptrNUint16) Delete(k uintptr, v uint16) {
	delete(__, k)
}
func (__ OfUintptrNUint16) Range(f func(k uintptr, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNUint16 = OfUintptrNUint16
type OfUintptrNUint16St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNUint16
}

func NewOfUintptrNUint16St(somes OfUintptrNUint16) *OfUintptrNUint16St {
	return &OfUintptrNUint16St{
		_OfUintptrNUint16: somes,
	}
}

type OfUintptrNUint32If interface {
	Load(uintptr) (uint32, error)
}

type OfUintptrNUint32MutIf interface {
	Store(uintptr, uint32)
	Delete(uintptr)
}

type OfUintptrNUint32IterIf interface {
	Range(func(uintptr, uint32) bool)
}

type OfUintptrNUint32 map[uintptr]uint32

func (__ OfUintptrNUint32) Load(k uintptr) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNUint32) Store(k uintptr, v uint32) {
	__[k] = v
}
func (__ OfUintptrNUint32) Delete(k uintptr, v uint32) {
	delete(__, k)
}
func (__ OfUintptrNUint32) Range(f func(k uintptr, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNUint32 = OfUintptrNUint32
type OfUintptrNUint32St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNUint32
}

func NewOfUintptrNUint32St(somes OfUintptrNUint32) *OfUintptrNUint32St {
	return &OfUintptrNUint32St{
		_OfUintptrNUint32: somes,
	}
}

type OfUintptrNUint64If interface {
	Load(uintptr) (uint64, error)
}

type OfUintptrNUint64MutIf interface {
	Store(uintptr, uint64)
	Delete(uintptr)
}

type OfUintptrNUint64IterIf interface {
	Range(func(uintptr, uint64) bool)
}

type OfUintptrNUint64 map[uintptr]uint64

func (__ OfUintptrNUint64) Load(k uintptr) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNUint64) Store(k uintptr, v uint64) {
	__[k] = v
}
func (__ OfUintptrNUint64) Delete(k uintptr, v uint64) {
	delete(__, k)
}
func (__ OfUintptrNUint64) Range(f func(k uintptr, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNUint64 = OfUintptrNUint64
type OfUintptrNUint64St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNUint64
}

func NewOfUintptrNUint64St(somes OfUintptrNUint64) *OfUintptrNUint64St {
	return &OfUintptrNUint64St{
		_OfUintptrNUint64: somes,
	}
}

type OfUintptrNUint8If interface {
	Load(uintptr) (uint8, error)
}

type OfUintptrNUint8MutIf interface {
	Store(uintptr, uint8)
	Delete(uintptr)
}

type OfUintptrNUint8IterIf interface {
	Range(func(uintptr, uint8) bool)
}

type OfUintptrNUint8 map[uintptr]uint8

func (__ OfUintptrNUint8) Load(k uintptr) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNUint8) Store(k uintptr, v uint8) {
	__[k] = v
}
func (__ OfUintptrNUint8) Delete(k uintptr, v uint8) {
	delete(__, k)
}
func (__ OfUintptrNUint8) Range(f func(k uintptr, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNUint8 = OfUintptrNUint8
type OfUintptrNUint8St struct {
	// do not want to export but want to use embedding method
	_OfUintptrNUint8
}

func NewOfUintptrNUint8St(somes OfUintptrNUint8) *OfUintptrNUint8St {
	return &OfUintptrNUint8St{
		_OfUintptrNUint8: somes,
	}
}

type OfUintptrNUintptrIf interface {
	Load(uintptr) (uintptr, error)
}

type OfUintptrNUintptrMutIf interface {
	Store(uintptr, uintptr)
	Delete(uintptr)
}

type OfUintptrNUintptrIterIf interface {
	Range(func(uintptr, uintptr) bool)
}

type OfUintptrNUintptr map[uintptr]uintptr

func (__ OfUintptrNUintptr) Load(k uintptr) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNUintptr) Store(k uintptr, v uintptr) {
	__[k] = v
}
func (__ OfUintptrNUintptr) Delete(k uintptr, v uintptr) {
	delete(__, k)
}
func (__ OfUintptrNUintptr) Range(f func(k uintptr, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNUintptr = OfUintptrNUintptr
type OfUintptrNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNUintptr
}

func NewOfUintptrNUintptrSt(somes OfUintptrNUintptr) *OfUintptrNUintptrSt {
	return &OfUintptrNUintptrSt{
		_OfUintptrNUintptr: somes,
	}
}

type OfUintptrNInterfaceIf interface {
	Load(uintptr) (interface{}, error)
}

type OfUintptrNInterfaceMutIf interface {
	Store(uintptr, interface{})
	Delete(uintptr)
}

type OfUintptrNInterfaceIterIf interface {
	Range(func(uintptr, interface{}) bool)
}

type OfUintptrNInterface map[uintptr]interface{}

func (__ OfUintptrNInterface) Load(k uintptr) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfUintptrNInterface) Store(k uintptr, v interface{}) {
	__[k] = v
}
func (__ OfUintptrNInterface) Delete(k uintptr, v interface{}) {
	delete(__, k)
}
func (__ OfUintptrNInterface) Range(f func(k uintptr, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfUintptrNInterface = OfUintptrNInterface
type OfUintptrNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfUintptrNInterface
}

func NewOfUintptrNInterfaceSt(somes OfUintptrNInterface) *OfUintptrNInterfaceSt {
	return &OfUintptrNInterfaceSt{
		_OfUintptrNInterface: somes,
	}
}

type OfInterfaceNBoolIf interface {
	Load(interface{}) (bool, error)
}

type OfInterfaceNBoolMutIf interface {
	Store(interface{}, bool)
	Delete(interface{})
}

type OfInterfaceNBoolIterIf interface {
	Range(func(interface{}, bool) bool)
}

type OfInterfaceNBool map[interface{}]bool

func (__ OfInterfaceNBool) Load(k interface{}) (bool, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNBool) Store(k interface{}, v bool) {
	__[k] = v
}
func (__ OfInterfaceNBool) Delete(k interface{}, v bool) {
	delete(__, k)
}
func (__ OfInterfaceNBool) Range(f func(k interface{}, v bool) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNBool = OfInterfaceNBool
type OfInterfaceNBoolSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNBool
}

func NewOfInterfaceNBoolSt(somes OfInterfaceNBool) *OfInterfaceNBoolSt {
	return &OfInterfaceNBoolSt{
		_OfInterfaceNBool: somes,
	}
}

type OfInterfaceNByteIf interface {
	Load(interface{}) (byte, error)
}

type OfInterfaceNByteMutIf interface {
	Store(interface{}, byte)
	Delete(interface{})
}

type OfInterfaceNByteIterIf interface {
	Range(func(interface{}, byte) bool)
}

type OfInterfaceNByte map[interface{}]byte

func (__ OfInterfaceNByte) Load(k interface{}) (byte, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNByte) Store(k interface{}, v byte) {
	__[k] = v
}
func (__ OfInterfaceNByte) Delete(k interface{}, v byte) {
	delete(__, k)
}
func (__ OfInterfaceNByte) Range(f func(k interface{}, v byte) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNByte = OfInterfaceNByte
type OfInterfaceNByteSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNByte
}

func NewOfInterfaceNByteSt(somes OfInterfaceNByte) *OfInterfaceNByteSt {
	return &OfInterfaceNByteSt{
		_OfInterfaceNByte: somes,
	}
}

type OfInterfaceNComplex128If interface {
	Load(interface{}) (complex128, error)
}

type OfInterfaceNComplex128MutIf interface {
	Store(interface{}, complex128)
	Delete(interface{})
}

type OfInterfaceNComplex128IterIf interface {
	Range(func(interface{}, complex128) bool)
}

type OfInterfaceNComplex128 map[interface{}]complex128

func (__ OfInterfaceNComplex128) Load(k interface{}) (complex128, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNComplex128) Store(k interface{}, v complex128) {
	__[k] = v
}
func (__ OfInterfaceNComplex128) Delete(k interface{}, v complex128) {
	delete(__, k)
}
func (__ OfInterfaceNComplex128) Range(f func(k interface{}, v complex128) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNComplex128 = OfInterfaceNComplex128
type OfInterfaceNComplex128St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNComplex128
}

func NewOfInterfaceNComplex128St(somes OfInterfaceNComplex128) *OfInterfaceNComplex128St {
	return &OfInterfaceNComplex128St{
		_OfInterfaceNComplex128: somes,
	}
}

type OfInterfaceNComplex64If interface {
	Load(interface{}) (complex64, error)
}

type OfInterfaceNComplex64MutIf interface {
	Store(interface{}, complex64)
	Delete(interface{})
}

type OfInterfaceNComplex64IterIf interface {
	Range(func(interface{}, complex64) bool)
}

type OfInterfaceNComplex64 map[interface{}]complex64

func (__ OfInterfaceNComplex64) Load(k interface{}) (complex64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNComplex64) Store(k interface{}, v complex64) {
	__[k] = v
}
func (__ OfInterfaceNComplex64) Delete(k interface{}, v complex64) {
	delete(__, k)
}
func (__ OfInterfaceNComplex64) Range(f func(k interface{}, v complex64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNComplex64 = OfInterfaceNComplex64
type OfInterfaceNComplex64St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNComplex64
}

func NewOfInterfaceNComplex64St(somes OfInterfaceNComplex64) *OfInterfaceNComplex64St {
	return &OfInterfaceNComplex64St{
		_OfInterfaceNComplex64: somes,
	}
}

type OfInterfaceNErrorIf interface {
	Load(interface{}) (error, error)
}

type OfInterfaceNErrorMutIf interface {
	Store(interface{}, error)
	Delete(interface{})
}

type OfInterfaceNErrorIterIf interface {
	Range(func(interface{}, error) bool)
}

type OfInterfaceNError map[interface{}]error

func (__ OfInterfaceNError) Load(k interface{}) (error, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNError) Store(k interface{}, v error) {
	__[k] = v
}
func (__ OfInterfaceNError) Delete(k interface{}, v error) {
	delete(__, k)
}
func (__ OfInterfaceNError) Range(f func(k interface{}, v error) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNError = OfInterfaceNError
type OfInterfaceNErrorSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNError
}

func NewOfInterfaceNErrorSt(somes OfInterfaceNError) *OfInterfaceNErrorSt {
	return &OfInterfaceNErrorSt{
		_OfInterfaceNError: somes,
	}
}

type OfInterfaceNFloat32If interface {
	Load(interface{}) (float32, error)
}

type OfInterfaceNFloat32MutIf interface {
	Store(interface{}, float32)
	Delete(interface{})
}

type OfInterfaceNFloat32IterIf interface {
	Range(func(interface{}, float32) bool)
}

type OfInterfaceNFloat32 map[interface{}]float32

func (__ OfInterfaceNFloat32) Load(k interface{}) (float32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNFloat32) Store(k interface{}, v float32) {
	__[k] = v
}
func (__ OfInterfaceNFloat32) Delete(k interface{}, v float32) {
	delete(__, k)
}
func (__ OfInterfaceNFloat32) Range(f func(k interface{}, v float32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNFloat32 = OfInterfaceNFloat32
type OfInterfaceNFloat32St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNFloat32
}

func NewOfInterfaceNFloat32St(somes OfInterfaceNFloat32) *OfInterfaceNFloat32St {
	return &OfInterfaceNFloat32St{
		_OfInterfaceNFloat32: somes,
	}
}

type OfInterfaceNFloat64If interface {
	Load(interface{}) (float64, error)
}

type OfInterfaceNFloat64MutIf interface {
	Store(interface{}, float64)
	Delete(interface{})
}

type OfInterfaceNFloat64IterIf interface {
	Range(func(interface{}, float64) bool)
}

type OfInterfaceNFloat64 map[interface{}]float64

func (__ OfInterfaceNFloat64) Load(k interface{}) (float64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNFloat64) Store(k interface{}, v float64) {
	__[k] = v
}
func (__ OfInterfaceNFloat64) Delete(k interface{}, v float64) {
	delete(__, k)
}
func (__ OfInterfaceNFloat64) Range(f func(k interface{}, v float64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNFloat64 = OfInterfaceNFloat64
type OfInterfaceNFloat64St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNFloat64
}

func NewOfInterfaceNFloat64St(somes OfInterfaceNFloat64) *OfInterfaceNFloat64St {
	return &OfInterfaceNFloat64St{
		_OfInterfaceNFloat64: somes,
	}
}

type OfInterfaceNIntIf interface {
	Load(interface{}) (int, error)
}

type OfInterfaceNIntMutIf interface {
	Store(interface{}, int)
	Delete(interface{})
}

type OfInterfaceNIntIterIf interface {
	Range(func(interface{}, int) bool)
}

type OfInterfaceNInt map[interface{}]int

func (__ OfInterfaceNInt) Load(k interface{}) (int, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNInt) Store(k interface{}, v int) {
	__[k] = v
}
func (__ OfInterfaceNInt) Delete(k interface{}, v int) {
	delete(__, k)
}
func (__ OfInterfaceNInt) Range(f func(k interface{}, v int) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNInt = OfInterfaceNInt
type OfInterfaceNIntSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNInt
}

func NewOfInterfaceNIntSt(somes OfInterfaceNInt) *OfInterfaceNIntSt {
	return &OfInterfaceNIntSt{
		_OfInterfaceNInt: somes,
	}
}

type OfInterfaceNInt16If interface {
	Load(interface{}) (int16, error)
}

type OfInterfaceNInt16MutIf interface {
	Store(interface{}, int16)
	Delete(interface{})
}

type OfInterfaceNInt16IterIf interface {
	Range(func(interface{}, int16) bool)
}

type OfInterfaceNInt16 map[interface{}]int16

func (__ OfInterfaceNInt16) Load(k interface{}) (int16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNInt16) Store(k interface{}, v int16) {
	__[k] = v
}
func (__ OfInterfaceNInt16) Delete(k interface{}, v int16) {
	delete(__, k)
}
func (__ OfInterfaceNInt16) Range(f func(k interface{}, v int16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNInt16 = OfInterfaceNInt16
type OfInterfaceNInt16St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNInt16
}

func NewOfInterfaceNInt16St(somes OfInterfaceNInt16) *OfInterfaceNInt16St {
	return &OfInterfaceNInt16St{
		_OfInterfaceNInt16: somes,
	}
}

type OfInterfaceNInt32If interface {
	Load(interface{}) (int32, error)
}

type OfInterfaceNInt32MutIf interface {
	Store(interface{}, int32)
	Delete(interface{})
}

type OfInterfaceNInt32IterIf interface {
	Range(func(interface{}, int32) bool)
}

type OfInterfaceNInt32 map[interface{}]int32

func (__ OfInterfaceNInt32) Load(k interface{}) (int32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNInt32) Store(k interface{}, v int32) {
	__[k] = v
}
func (__ OfInterfaceNInt32) Delete(k interface{}, v int32) {
	delete(__, k)
}
func (__ OfInterfaceNInt32) Range(f func(k interface{}, v int32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNInt32 = OfInterfaceNInt32
type OfInterfaceNInt32St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNInt32
}

func NewOfInterfaceNInt32St(somes OfInterfaceNInt32) *OfInterfaceNInt32St {
	return &OfInterfaceNInt32St{
		_OfInterfaceNInt32: somes,
	}
}

type OfInterfaceNInt64If interface {
	Load(interface{}) (int64, error)
}

type OfInterfaceNInt64MutIf interface {
	Store(interface{}, int64)
	Delete(interface{})
}

type OfInterfaceNInt64IterIf interface {
	Range(func(interface{}, int64) bool)
}

type OfInterfaceNInt64 map[interface{}]int64

func (__ OfInterfaceNInt64) Load(k interface{}) (int64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNInt64) Store(k interface{}, v int64) {
	__[k] = v
}
func (__ OfInterfaceNInt64) Delete(k interface{}, v int64) {
	delete(__, k)
}
func (__ OfInterfaceNInt64) Range(f func(k interface{}, v int64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNInt64 = OfInterfaceNInt64
type OfInterfaceNInt64St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNInt64
}

func NewOfInterfaceNInt64St(somes OfInterfaceNInt64) *OfInterfaceNInt64St {
	return &OfInterfaceNInt64St{
		_OfInterfaceNInt64: somes,
	}
}

type OfInterfaceNInt8If interface {
	Load(interface{}) (int8, error)
}

type OfInterfaceNInt8MutIf interface {
	Store(interface{}, int8)
	Delete(interface{})
}

type OfInterfaceNInt8IterIf interface {
	Range(func(interface{}, int8) bool)
}

type OfInterfaceNInt8 map[interface{}]int8

func (__ OfInterfaceNInt8) Load(k interface{}) (int8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNInt8) Store(k interface{}, v int8) {
	__[k] = v
}
func (__ OfInterfaceNInt8) Delete(k interface{}, v int8) {
	delete(__, k)
}
func (__ OfInterfaceNInt8) Range(f func(k interface{}, v int8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNInt8 = OfInterfaceNInt8
type OfInterfaceNInt8St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNInt8
}

func NewOfInterfaceNInt8St(somes OfInterfaceNInt8) *OfInterfaceNInt8St {
	return &OfInterfaceNInt8St{
		_OfInterfaceNInt8: somes,
	}
}

type OfInterfaceNRuneIf interface {
	Load(interface{}) (rune, error)
}

type OfInterfaceNRuneMutIf interface {
	Store(interface{}, rune)
	Delete(interface{})
}

type OfInterfaceNRuneIterIf interface {
	Range(func(interface{}, rune) bool)
}

type OfInterfaceNRune map[interface{}]rune

func (__ OfInterfaceNRune) Load(k interface{}) (rune, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNRune) Store(k interface{}, v rune) {
	__[k] = v
}
func (__ OfInterfaceNRune) Delete(k interface{}, v rune) {
	delete(__, k)
}
func (__ OfInterfaceNRune) Range(f func(k interface{}, v rune) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNRune = OfInterfaceNRune
type OfInterfaceNRuneSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNRune
}

func NewOfInterfaceNRuneSt(somes OfInterfaceNRune) *OfInterfaceNRuneSt {
	return &OfInterfaceNRuneSt{
		_OfInterfaceNRune: somes,
	}
}

type OfInterfaceNStringIf interface {
	Load(interface{}) (string, error)
}

type OfInterfaceNStringMutIf interface {
	Store(interface{}, string)
	Delete(interface{})
}

type OfInterfaceNStringIterIf interface {
	Range(func(interface{}, string) bool)
}

type OfInterfaceNString map[interface{}]string

func (__ OfInterfaceNString) Load(k interface{}) (string, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNString) Store(k interface{}, v string) {
	__[k] = v
}
func (__ OfInterfaceNString) Delete(k interface{}, v string) {
	delete(__, k)
}
func (__ OfInterfaceNString) Range(f func(k interface{}, v string) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNString = OfInterfaceNString
type OfInterfaceNStringSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNString
}

func NewOfInterfaceNStringSt(somes OfInterfaceNString) *OfInterfaceNStringSt {
	return &OfInterfaceNStringSt{
		_OfInterfaceNString: somes,
	}
}

type OfInterfaceNUintIf interface {
	Load(interface{}) (uint, error)
}

type OfInterfaceNUintMutIf interface {
	Store(interface{}, uint)
	Delete(interface{})
}

type OfInterfaceNUintIterIf interface {
	Range(func(interface{}, uint) bool)
}

type OfInterfaceNUint map[interface{}]uint

func (__ OfInterfaceNUint) Load(k interface{}) (uint, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNUint) Store(k interface{}, v uint) {
	__[k] = v
}
func (__ OfInterfaceNUint) Delete(k interface{}, v uint) {
	delete(__, k)
}
func (__ OfInterfaceNUint) Range(f func(k interface{}, v uint) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNUint = OfInterfaceNUint
type OfInterfaceNUintSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNUint
}

func NewOfInterfaceNUintSt(somes OfInterfaceNUint) *OfInterfaceNUintSt {
	return &OfInterfaceNUintSt{
		_OfInterfaceNUint: somes,
	}
}

type OfInterfaceNUint16If interface {
	Load(interface{}) (uint16, error)
}

type OfInterfaceNUint16MutIf interface {
	Store(interface{}, uint16)
	Delete(interface{})
}

type OfInterfaceNUint16IterIf interface {
	Range(func(interface{}, uint16) bool)
}

type OfInterfaceNUint16 map[interface{}]uint16

func (__ OfInterfaceNUint16) Load(k interface{}) (uint16, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNUint16) Store(k interface{}, v uint16) {
	__[k] = v
}
func (__ OfInterfaceNUint16) Delete(k interface{}, v uint16) {
	delete(__, k)
}
func (__ OfInterfaceNUint16) Range(f func(k interface{}, v uint16) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNUint16 = OfInterfaceNUint16
type OfInterfaceNUint16St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNUint16
}

func NewOfInterfaceNUint16St(somes OfInterfaceNUint16) *OfInterfaceNUint16St {
	return &OfInterfaceNUint16St{
		_OfInterfaceNUint16: somes,
	}
}

type OfInterfaceNUint32If interface {
	Load(interface{}) (uint32, error)
}

type OfInterfaceNUint32MutIf interface {
	Store(interface{}, uint32)
	Delete(interface{})
}

type OfInterfaceNUint32IterIf interface {
	Range(func(interface{}, uint32) bool)
}

type OfInterfaceNUint32 map[interface{}]uint32

func (__ OfInterfaceNUint32) Load(k interface{}) (uint32, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNUint32) Store(k interface{}, v uint32) {
	__[k] = v
}
func (__ OfInterfaceNUint32) Delete(k interface{}, v uint32) {
	delete(__, k)
}
func (__ OfInterfaceNUint32) Range(f func(k interface{}, v uint32) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNUint32 = OfInterfaceNUint32
type OfInterfaceNUint32St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNUint32
}

func NewOfInterfaceNUint32St(somes OfInterfaceNUint32) *OfInterfaceNUint32St {
	return &OfInterfaceNUint32St{
		_OfInterfaceNUint32: somes,
	}
}

type OfInterfaceNUint64If interface {
	Load(interface{}) (uint64, error)
}

type OfInterfaceNUint64MutIf interface {
	Store(interface{}, uint64)
	Delete(interface{})
}

type OfInterfaceNUint64IterIf interface {
	Range(func(interface{}, uint64) bool)
}

type OfInterfaceNUint64 map[interface{}]uint64

func (__ OfInterfaceNUint64) Load(k interface{}) (uint64, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNUint64) Store(k interface{}, v uint64) {
	__[k] = v
}
func (__ OfInterfaceNUint64) Delete(k interface{}, v uint64) {
	delete(__, k)
}
func (__ OfInterfaceNUint64) Range(f func(k interface{}, v uint64) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNUint64 = OfInterfaceNUint64
type OfInterfaceNUint64St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNUint64
}

func NewOfInterfaceNUint64St(somes OfInterfaceNUint64) *OfInterfaceNUint64St {
	return &OfInterfaceNUint64St{
		_OfInterfaceNUint64: somes,
	}
}

type OfInterfaceNUint8If interface {
	Load(interface{}) (uint8, error)
}

type OfInterfaceNUint8MutIf interface {
	Store(interface{}, uint8)
	Delete(interface{})
}

type OfInterfaceNUint8IterIf interface {
	Range(func(interface{}, uint8) bool)
}

type OfInterfaceNUint8 map[interface{}]uint8

func (__ OfInterfaceNUint8) Load(k interface{}) (uint8, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNUint8) Store(k interface{}, v uint8) {
	__[k] = v
}
func (__ OfInterfaceNUint8) Delete(k interface{}, v uint8) {
	delete(__, k)
}
func (__ OfInterfaceNUint8) Range(f func(k interface{}, v uint8) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNUint8 = OfInterfaceNUint8
type OfInterfaceNUint8St struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNUint8
}

func NewOfInterfaceNUint8St(somes OfInterfaceNUint8) *OfInterfaceNUint8St {
	return &OfInterfaceNUint8St{
		_OfInterfaceNUint8: somes,
	}
}

type OfInterfaceNUintptrIf interface {
	Load(interface{}) (uintptr, error)
}

type OfInterfaceNUintptrMutIf interface {
	Store(interface{}, uintptr)
	Delete(interface{})
}

type OfInterfaceNUintptrIterIf interface {
	Range(func(interface{}, uintptr) bool)
}

type OfInterfaceNUintptr map[interface{}]uintptr

func (__ OfInterfaceNUintptr) Load(k interface{}) (uintptr, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNUintptr) Store(k interface{}, v uintptr) {
	__[k] = v
}
func (__ OfInterfaceNUintptr) Delete(k interface{}, v uintptr) {
	delete(__, k)
}
func (__ OfInterfaceNUintptr) Range(f func(k interface{}, v uintptr) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNUintptr = OfInterfaceNUintptr
type OfInterfaceNUintptrSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNUintptr
}

func NewOfInterfaceNUintptrSt(somes OfInterfaceNUintptr) *OfInterfaceNUintptrSt {
	return &OfInterfaceNUintptrSt{
		_OfInterfaceNUintptr: somes,
	}
}

type OfInterfaceNInterfaceIf interface {
	Load(interface{}) (interface{}, error)
}

type OfInterfaceNInterfaceMutIf interface {
	Store(interface{}, interface{})
	Delete(interface{})
}

type OfInterfaceNInterfaceIterIf interface {
	Range(func(interface{}, interface{}) bool)
}

type OfInterfaceNInterface map[interface{}]interface{}

func (__ OfInterfaceNInterface) Load(k interface{}) (interface{}, error) {
	v, ok := __[k]
	var err error
	if !ok {
		err = fmt.Errorf("not found for key %v", k)
	}
	return v, err
}

func (__ OfInterfaceNInterface) Store(k interface{}, v interface{}) {
	__[k] = v
}
func (__ OfInterfaceNInterface) Delete(k interface{}, v interface{}) {
	delete(__, k)
}
func (__ OfInterfaceNInterface) Range(f func(k interface{}, v interface{}) bool) {
	for k, v := range __ {
		if !f(k, v) {
			break
		}
	}
}

type _OfInterfaceNInterface = OfInterfaceNInterface
type OfInterfaceNInterfaceSt struct {
	// do not want to export but want to use embedding method
	_OfInterfaceNInterface
}

func NewOfInterfaceNInterfaceSt(somes OfInterfaceNInterface) *OfInterfaceNInterfaceSt {
	return &OfInterfaceNInterfaceSt{
		_OfInterfaceNInterface: somes,
	}
}
